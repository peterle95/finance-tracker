from finance_tracker.app import main

if __name__ == "__main__":
    main()import matplotlib.pyplot as plt
import sys
import os
sys.path.append(os.getcwd())
from finance_tracker.ui.charts import create_budget_depletion_figure

class MockState:
    def __init__(self):
        self.budget_settings = {"daily_savings_goal": 5}
        self.incomes = []
        self.expenses = []

state = MockState()
try:
    fig = create_budget_depletion_figure(state, "2026-01")
    width, height = fig.get_size_inches()
    print(f"Figure size: {width}x{height}")
except Exception as e:
    print(f"Error: {e}")
"""
finance_tracker/state.py

Manages the application state, including data loading, saving, and transaction management.
"""

from pathlib import Path
from datetime import datetime
import json

DEFAULT_EXPENSE_CATEGORIES = [
    "Food", "Transportation", "Entertainment", "Utilities",
    "Shopping", "Healthcare", "Money Lent", "Other"
]
DEFAULT_INCOME_CATEGORIES = ["Salary", "Side Gig", "Bonus", "Gift", "Investment", "Other"]

class AppState:
    def __init__(self, data_file: Path = Path("finance_data.json")):
        self.data_file = data_file
        self.expenses = []
        self.incomes = []
        self.budget_settings = {}
        self.categories = {}
        self.load()

    def load(self):
        if self.data_file.exists():
            with open(self.data_file, "r", encoding="utf-8") as f:
                data = json.load(f)
        else:
            data = {}

        self.expenses = data.get("expenses", [])
        self.incomes = data.get("incomes", [])
        self.budget_settings = data.get("budget_settings", {})
        self.categories = data.get("categories", {})

        # Ensure defaults
        bs = self.budget_settings
        bs.setdefault("fixed_costs", [])
        
        # KEY CHANGE: "monthly_income" might be a float (old) or a list (new)
        # We want to normalize it to a list of dicts: 
        # [{"amount": float, "description": str, "start_date": str, "end_date": str|None}]
        current_income = bs.get("monthly_income")
        if current_income is None:
            # Default to empty list if not present
            bs["monthly_income"] = []
        elif isinstance(current_income, (int, float)):
            # MIgrate old single value to list
            if current_income > 0:
                bs["monthly_income"] = [{
                    "amount": float(current_income),
                    "description": "Base Income",
                    "start_date": "2025-01-01",
                    "end_date": None
                }]
            else:
                bs["monthly_income"] = []
        # else: it's already a list (hopefully), or we assume it is correct
            
        bs.setdefault("bank_account_balance", 0)
        bs.setdefault("savings_balance", 0)
        bs.setdefault("investment_balance", 0)
        bs.setdefault("wallet_balance", 0)
        bs.setdefault("daily_savings_goal", 0)
        bs.setdefault("money_lent_balance", 0)
        bs.setdefault("category_budgets", {"Expense": {}, "Income": {}})
        bs.setdefault("loans", [])  # Each loan: {"id": str, "borrower": str, "amount": float, "description": str, "date": str}

        # Migrate fixed costs to include start_date and end_date
        for fc in bs.get("fixed_costs", []):
            if 'start_date' not in fc:
                fc['start_date'] = '2000-01-01'  # Default to a very early date for existing costs
            if 'end_date' not in fc:
                fc['end_date'] = None  # None means still active
        
        if "Expense" not in self.categories or not self.categories["Expense"]:
            self.categories["Expense"] = DEFAULT_EXPENSE_CATEGORIES.copy()
        if "Income" not in self.categories or not self.categories["Income"]:
            self.categories["Income"] = DEFAULT_INCOME_CATEGORIES.copy()

    def save(self):
        data = {
            "expenses": self.expenses,
            "incomes": self.incomes,
            "budget_settings": self.budget_settings,
            "categories": self.categories,
        }
        with open(self.data_file, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4)

    def add_transaction(self, trans_type: str, date_str: str, amount: float, category: str, description: str):
        trans_id = f"{datetime.now().timestamp()}"
        record = {"id": trans_id, "date": date_str, "amount": amount, "category": category, "description": description}
        if trans_type == "Expense":
            self.expenses.append(record)
        else:
            self.incomes.append(record)
        self.save()

    def delete_transaction_by_id(self, trans_type: str, trans_id: str) -> bool:
        target = self.expenses if trans_type == "Expense" else self.incomes
        for i, t in enumerate(target):
            if t.get("id") == trans_id:
                del target[i]
                self.save()
                return True
        return False"""
finance_tracker/app.py

Main application entry point and initialization.
"""

import tkinter as tk
from .state import AppState
from .ui.main_view import MainView

def main():
    root = tk.Tk()
    state = AppState()
    MainView(root, state)
    root.mainloop()# Finance Tracker package"""
finance_tracker/ui/tabs/net_worth_tab.py

Tab for tracking and visualizing net worth over time.
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from datetime import datetime, date
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

from ...services.asset_tracking_service import (
    record_asset_snapshot, 
    get_asset_snapshots, 
    get_current_net_worth, 
    get_net_worth_change, 
    delete_snapshot, 
    generate_net_worth_report,
    get_asset_allocation_data
)
from ..charts import create_net_worth_figure, create_allocation_figure, create_breakdown_figure

class NetWorthTab:
    def __init__(self, notebook, state):
        self.state = state
        self.canvas = None
        self.chart_type = "net_worth"  # "net_worth" or "allocation"

        main = ttk.Frame(notebook, padding="10")
        notebook.add(main, text="Net Worth")
        main.rowconfigure(2, weight=1)
        main.columnconfigure(0, weight=1)
        
        # Current status section
        status_frame = ttk.LabelFrame(main, text="Current Net Worth", padding="10")
        status_frame.grid(row=0, column=0, sticky='ew', pady=(0, 10))
        
        self.status_label = ttk.Label(status_frame, text="", font=('Arial', 12, 'bold'))
        self.status_label.pack()
        
        self.change_label = ttk.Label(status_frame, text="", font=('Arial', 10))
        self.change_label.pack(pady=(5, 0))
        
        # Controls section
        controls = ttk.Frame(main)
        controls.grid(row=1, column=0, sticky='ew', pady=(0, 10))
        
        # Left side - snapshot recording
        left_controls = ttk.LabelFrame(controls, text="Record Snapshot", padding="10")
        left_controls.pack(side='left', fill='x', expand=True, padx=(0, 5))
        
        snapshot_form = ttk.Frame(left_controls)
        snapshot_form.pack(fill='x')
        
        ttk.Label(snapshot_form, text="Date:").pack(side='left', padx=(0, 5))
        self.snapshot_date_entry = ttk.Entry(snapshot_form, width=12)
        self.snapshot_date_entry.insert(0, date.today().strftime('%Y-%m-%d'))
        self.snapshot_date_entry.pack(side='left', padx=(0, 5))
        
        ttk.Label(snapshot_form, text="Note:").pack(side='left', padx=(10, 5))
        self.snapshot_note_entry = ttk.Entry(snapshot_form, width=20)
        self.snapshot_note_entry.pack(side='left', padx=(0, 5))
        
        ttk.Button(snapshot_form, text="Record Snapshot", 
                  command=self.record_snapshot).pack(side='left', padx=(10, 0))
        
        # Right side - chart controls
        right_controls = ttk.LabelFrame(controls, text="Visualization", padding="10")
        right_controls.pack(side='right', fill='x', expand=True, padx=(5, 0))
        
        chart_form = ttk.Frame(right_controls)
        chart_form.pack(fill='x')
        
        ttk.Label(chart_form, text="Chart Type:").pack(side='left', padx=(0, 5))
        
        self.chart_type_var = tk.StringVar(value="net_worth")
        ttk.Radiobutton(chart_form, text="Net Worth Over Time", 
                       variable=self.chart_type_var, value="net_worth",
                       command=self.generate_chart).pack(side='left', padx=5)
        ttk.Radiobutton(chart_form, text="Asset Allocation", 
                       variable=self.chart_type_var, value="allocation",
                       command=self.generate_chart).pack(side='left', padx=5)
        ttk.Radiobutton(chart_form, text="Asset Breakdown", 
                       variable=self.chart_type_var, value="breakdown",
                       command=self.generate_chart).pack(side='left', padx=5)
        
        ttk.Button(chart_form, text="Refresh", 
                  command=self.generate_chart).pack(side='left', padx=(10, 0))
        
        # Main content area
        content = ttk.Frame(main)
        content.grid(row=2, column=0, sticky='nsew')
        content.rowconfigure(0, weight=1)
        content.columnconfigure(0, weight=2)
        content.columnconfigure(1, weight=1)
        
        # Left - Chart
        chart_frame = ttk.LabelFrame(content, text="Visualization", padding="10")
        chart_frame.grid(row=0, column=0, sticky='nsew', padx=(0, 5))
        chart_frame.rowconfigure(0, weight=1)
        chart_frame.columnconfigure(0, weight=1)
        
        self.chart_container = ttk.Frame(chart_frame)
        self.chart_container.grid(row=0, column=0, sticky='nsew')
        
        # Right - Snapshots list
        right_frame = ttk.LabelFrame(content, text="Snapshot History", padding="10")
        right_frame.grid(row=0, column=1, sticky='nsew', padx=(5, 0))
        right_frame.rowconfigure(0, weight=1)
        right_frame.columnconfigure(0, weight=1)
        
        # Snapshots tree
        tree_frame = ttk.Frame(right_frame)
        tree_frame.grid(row=0, column=0, sticky='nsew')
        tree_frame.rowconfigure(0, weight=1)
        tree_frame.columnconfigure(0, weight=1)
        
        columns = ('Date', 'Net Worth', 'Change')
        self.snapshots_tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=10)
        self.snapshots_tree.heading('Date', text='Date')
        self.snapshots_tree.heading('Net Worth', text='Net Worth')
        self.snapshots_tree.heading('Change', text='Change')
        
        self.snapshots_tree.column('Date', width=100)
        self.snapshots_tree.column('Net Worth', width=120, anchor='e')
        self.snapshots_tree.column('Change', width=100, anchor='e')
        
        self.snapshots_tree.grid(row=0, column=0, sticky='nsew')
        
        scroll = ttk.Scrollbar(tree_frame, orient='vertical', command=self.snapshots_tree.yview)
        scroll.grid(row=0, column=1, sticky='ns')
        self.snapshots_tree.configure(yscrollcommand=scroll.set)
        
        # Buttons
        button_frame = ttk.Frame(right_frame)
        button_frame.grid(row=1, column=0, sticky='ew', pady=(10, 0))
        
        ttk.Button(button_frame, text="Delete Selected", 
                  command=self.delete_selected_snapshot).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Generate Report", 
                  command=self.show_report).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Export Report", 
                  command=self.export_report).pack(side='left', padx=5)
        
        # Initialize
        self.refresh()

    def refresh(self):
        """Refresh all data and displays"""
        self.update_status()
        self.refresh_snapshots_tree()
        self.generate_chart()

    def update_status(self):
        """Update the current net worth display"""
        current = get_current_net_worth(self.state)
        
        # Color code based on positive/negative
        color = 'green' if current >= 0 else 'red'
        self.status_label.config(text=f"€{current:,.2f}", foreground=color)
        
        # Show 1-month change
        change_data, error = get_net_worth_change(self.state, 1)
        if change_data:
            change = change_data['change']
            change_pct = change_data['change_pct']
            sign = "+" if change >= 0 else ""
            color = 'green' if change >= 0 else 'red'
            
            text = f"1-month change: {sign}€{change:,.2f} ({sign}{change_pct:.1f}%)"
            self.change_label.config(text=text, foreground=color)
        else:
            self.change_label.config(text="No historical data for comparison", foreground='gray')

    def refresh_snapshots_tree(self):
        """Refresh the snapshots tree view"""
        for item in self.snapshots_tree.get_children():
            self.snapshots_tree.delete(item)
        
        snapshots = get_asset_snapshots(self.state)
        
        for i, snapshot in enumerate(snapshots):
            net_worth = snapshot['net_worth']
            
            # Calculate change from previous
            if i > 0:
                prev_net_worth = snapshots[i-1]['net_worth']
                change = net_worth - prev_net_worth
                sign = "+" if change >= 0 else ""
                change_str = f"{sign}€{change:,.2f}"
            else:
                change_str = "—"
            
            self.snapshots_tree.insert('', 'end', values=(
                snapshot['date'],
                f"€{net_worth:,.2f}",
                change_str
            ))

    def record_snapshot(self):
        """Record a new asset snapshot"""
        try:
            snapshot_date = self.snapshot_date_entry.get()
            datetime.strptime(snapshot_date, '%Y-%m-%d')
            
            note = self.snapshot_note_entry.get().strip()
            
            snapshot = record_asset_snapshot(self.state, snapshot_date, note)
            self.state.save()
            
            messagebox.showinfo("Success", 
                              f"Snapshot recorded for {snapshot_date}\n"
                              f"Net Worth: €{snapshot['net_worth']:,.2f}")
            
            self.snapshot_note_entry.delete(0, tk.END)
            self.snapshot_date_entry.delete(0, tk.END)
            self.snapshot_date_entry.insert(0, date.today().strftime('%Y-%m-%d'))
            
            self.refresh()
            
        except ValueError:
            messagebox.showerror("Error", "Invalid date format. Use YYYY-MM-DD")

    def delete_selected_snapshot(self):
        """Delete the selected snapshot"""
        selected = self.snapshots_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a snapshot to delete.")
            return
        
        values = self.snapshots_tree.item(selected[0])['values']
        snapshot_date = values[0]
        
        if not messagebox.askyesno("Confirm Delete", 
                                 f"Delete snapshot from {snapshot_date}?"):
            return
        
        delete_snapshot(self.state, snapshot_date)
        self.state.save()
        self.refresh()

    def generate_chart(self):
        """Generate the selected chart type"""
        if self.canvas:
            self.canvas.get_tk_widget().destroy()
            self.canvas = None
        
        chart_type = self.chart_type_var.get()
        
        if chart_type == "net_worth":
            self._generate_net_worth_chart()
        elif chart_type == "allocation":
            self._generate_allocation_chart()
        elif chart_type == "breakdown":
            self._generate_breakdown_chart()

    def _generate_net_worth_chart(self):
        """Generate net worth over time line chart"""
        snapshots = get_asset_snapshots(self.state)
        
        if not snapshots:
            # Show message
            label = ttk.Label(self.chart_container, 
                            text="No snapshots recorded yet.\nRecord your first snapshot to see the chart!",
                            font=('Arial', 11), foreground='gray')
            label.pack(expand=True)
            return
        
        # Add current as the latest point if not today
        current_date = date.today().strftime('%Y-%m-%d')
        if not snapshots or snapshots[-1]['date'] != current_date:
            current_snapshot = {
                'date': current_date,
                'net_worth': get_current_net_worth(self.state),
                'note': 'Current'
            }
            snapshots = snapshots + [current_snapshot]
        
        fig = create_net_worth_figure(snapshots)
        
        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_container)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill='both', expand=True)

    def _generate_allocation_chart(self):
        """Generate current asset allocation pie chart"""
        bs = self.state.budget_settings
        
        # Get all assets (including negative ones)
        assets = {
            'Bank Account': bs.get('bank_account_balance', 0),
            'Wallet': bs.get('wallet_balance', 0),
            'Savings': bs.get('savings_balance', 0),
            'Investments': bs.get('investment_balance', 0),
            'Money Lent': bs.get('money_lent_balance', 0)
        }
        
        # Filter to only positive assets for pie chart
        positive_assets = {k: v for k, v in assets.items() if v > 0}
        negative_assets = {k: v for k, v in assets.items() if v < 0}
        
        if not positive_assets:
            label = ttk.Label(self.chart_container, 
                            text="No positive assets to display.\n\n"
                                 "Pie charts can only show positive values.\n"
                                 "Add some positive balances in Budget Report tab!",
                            font=('Arial', 11), foreground='gray')
            label.pack(expand=True)
            return
        
        fig = create_allocation_figure(positive_assets, negative_assets, sum(positive_assets.values()))
        
        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_container)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill='both', expand=True)

    def _generate_breakdown_chart(self):
        """Generate asset breakdown over time stacked area chart"""
        snapshots = get_asset_snapshots(self.state)
        
        if not snapshots:
            label = ttk.Label(self.chart_container, 
                            text="No snapshots recorded yet.\nRecord your first snapshot to see the chart!",
                            font=('Arial', 11), foreground='gray')
            label.pack(expand=True)
            return
        
        fig = create_breakdown_figure(snapshots)
        
        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_container)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill='both', expand=True)

    def show_report(self):
        """Show the net worth report in a dialog"""
        report = generate_net_worth_report(self.state)
        
        report_win = tk.Toplevel()
        report_win.title("Net Worth Report")
        report_win.geometry("700x600")
        
        # Text widget for report
        text_frame = ttk.Frame(report_win)
        text_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        text = tk.Text(text_frame, wrap='word', font=('Courier New', 10))
        text.insert('1.0', report)
        text.config(state='disabled')
        
        scroll = ttk.Scrollbar(text_frame, orient='vertical', command=text.yview)
        text.configure(yscrollcommand=scroll.set)
        
        scroll.pack(side='right', fill='y')
        text.pack(side='left', fill='both', expand=True)
        
        # Buttons
        button_frame = ttk.Frame(report_win)
        button_frame.pack(fill='x', padx=10, pady=(0, 10))
        
        ttk.Button(button_frame, text="Close", 
                  command=report_win.destroy).pack(side='right', padx=5)
        ttk.Button(button_frame, text="Export to File", 
                  command=lambda: self.export_report(report)).pack(side='right', padx=5)
    
    def export_report(self, report_text=None):
        """Export the net worth report to a text file"""
        if report_text is None:
            report_text = generate_net_worth_report(self.state)
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
            title="Save Net Worth Report As"
        )
        
        if filename:
            try:
                with open(filename, 'w') as f:
                    f.write(report_text)
                messagebox.showinfo("Success", f"Report saved to {filename}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save report: {str(e)}")
"""
finance_tracker/ui/tabs/add_transaction_tab.py

Tab for adding new income or expense transactions.
"""

import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime

class AddTransactionTab:
    def __init__(self, notebook, state, on_data_changed):
        self.state = state
        self.on_data_changed = on_data_changed

        self.frame = ttk.Frame(notebook, padding="20")
        notebook.add(self.frame, text="Add Transaction")

        form = ttk.Frame(self.frame)
        form.pack(anchor='center')

        ttk.Label(form, text="Transaction Type:").grid(row=0, column=0, sticky='w', pady=10)
        self.transaction_type_var = tk.StringVar(value="Expense")
        type_frame = ttk.Frame(form)
        type_frame.grid(row=0, column=1, sticky='w', pady=5)
        ttk.Radiobutton(type_frame, text="Expense", variable=self.transaction_type_var,
                        value="Expense", command=self.update_categories).pack(side='left', padx=5)
        ttk.Radiobutton(type_frame, text="Income", variable=self.transaction_type_var,
                        value="Income", command=self.update_categories).pack(side='left', padx=5)

        ttk.Label(form, text="Date:").grid(row=1, column=0, sticky='w', pady=5)
        self.date_entry = ttk.Entry(form, width=30)
        self.date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.date_entry.grid(row=1, column=1, pady=5, sticky='w')
        ttk.Label(form, text="(YYYY-MM-DD)", foreground="gray").grid(row=1, column=2, sticky='w', padx=5)

        ttk.Label(form, text="Amount:").grid(row=2, column=0, sticky='w', pady=5)
        self.amount_entry = ttk.Entry(form, width=30)
        self.amount_entry.grid(row=2, column=1, pady=5, sticky='w')

        ttk.Label(form, text="Category:").grid(row=3, column=0, sticky='w', pady=5)
        self.category_var = tk.StringVar()
        self.category_combo = ttk.Combobox(form, textvariable=self.category_var, width=28, state='readonly')
        self.category_combo.grid(row=3, column=1, pady=5, sticky='w')

        ttk.Label(form, text="Description:").grid(row=4, column=0, sticky='w', pady=5)
        self.description_entry = ttk.Entry(form, width=30)
        self.description_entry.grid(row=4, column=1, pady=5, sticky='w')

        ttk.Button(form, text="Add Transaction", command=self.add_transaction).grid(row=5, column=1, pady=20, sticky='w')

        self.update_categories()

    def update_categories(self):
        t = self.transaction_type_var.get()
        categories = self.state.categories.get(t, [])
        self.category_combo.config(values=categories)
        self.category_combo.set(categories[0] if categories else "")

    def add_transaction(self):
        try:
            date_str = self.date_entry.get()
            datetime.strptime(date_str, "%Y-%m-%d")
            amount = float(self.amount_entry.get())
            category = self.category_var.get()
            description = self.description_entry.get()
            trans_type = self.transaction_type_var.get()

            if not category:
                messagebox.showerror("Error", "Please select a category.")
                return

            self.state.add_transaction(trans_type, date_str, amount, category, description)
            self.amount_entry.delete(0, tk.END)
            self.description_entry.delete(0, tk.END)
            messagebox.showinfo("Success", f"{trans_type} added successfully!")
            self.on_data_changed()
        except ValueError:
            messagebox.showerror("Error", "Invalid amount or date format (YYYY-MM-DD).")"""
finance_tracker/ui/tabs/settings_tab.py

Tab for configuring budget settings, fixed costs, and viewing daily reports.
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from datetime import datetime
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from ...services.budget_calculator import generate_daily_budget_report
from ..charts import create_budget_depletion_figure

class SettingsTab:
    def __init__(self, notebook, state):
        self.state = state

        main = ttk.Frame(notebook, padding="10")
        notebook.add(main, text="Budget Report")
        main.rowconfigure(1, weight=1)
        main.columnconfigure(0, weight=1)

        top = ttk.Frame(main)
        top.grid(row=0, column=0, sticky='ew', pady=(0, 10))
        top.columnconfigure(1, weight=1)

        settings = ttk.LabelFrame(top, text="Monthly Settings & Balances", padding="10")
        settings.grid(row=0, column=0, sticky='ns', padx=(0, 10))

        settings.grid(row=0, column=0, sticky='ns', padx=(0, 10))

        # Base Monthly Income Button + Readonly Display
        self.income_btn = ttk.Button(settings, text="Base Monthly Income:", command=self._open_income_manager)
        self.income_btn.grid(row=0, column=0, sticky='w', pady=5)
        self.income_entry_display = ttk.Entry(settings, width=15, state='readonly')
        self.income_entry_display.grid(row=0, column=1, pady=5)
        
        # Base Monthly Costs Button + Readonly Display
        self.costs_btn = ttk.Button(settings, text="Base Monthly Costs:", command=self._open_fixed_costs_manager)
        self.costs_btn.grid(row=1, column=0, sticky='w', pady=5)
        self.costs_entry_display = ttk.Entry(settings, width=15, state='readonly')
        self.costs_entry_display.grid(row=1, column=1, pady=5)
        
        ttk.Label(settings, text="Bank Account Balance:").grid(row=2, column=0, sticky='w', pady=5)
        self.bank_entry = ttk.Entry(settings, width=15)
        self.bank_entry.grid(row=2, column=1, pady=5)

        ttk.Label(settings, text="Wallet Balance:").grid(row=3, column=0, sticky='w', pady=5)
        self.wallet_entry = ttk.Entry(settings, width=15)
        self.wallet_entry.grid(row=3, column=1, pady=5)

        ttk.Label(settings, text="Current Savings:").grid(row=4, column=0, sticky='w', pady=5)
        self.savings_entry = ttk.Entry(settings, width=15)
        self.savings_entry.grid(row=4, column=1, pady=5)

        ttk.Label(settings, text="Current Investments:").grid(row=5, column=0, sticky='w', pady=5)
        self.investment_entry = ttk.Entry(settings, width=15)
        self.investment_entry.grid(row=5, column=1, pady=5)

        # Money Lent: button label + readonly entry
        self.money_lent_btn = ttk.Button(settings, text="Money Lent:", command=self._open_lending_manager)
        self.money_lent_btn.grid(row=6, column=0, sticky='w', pady=5)
        self.money_lent_entry = ttk.Entry(settings, width=15, state='readonly')
        self.money_lent_entry.grid(row=6, column=1, pady=5)

        ttk.Label(settings, text="Daily Savings Goal:").grid(row=7, column=0, sticky='w', pady=5)
        self.daily_savings_entry = ttk.Entry(settings, width=15)
        self.daily_savings_entry.grid(row=7, column=1, pady=5)

        ttk.Button(settings, text="Save Settings", command=self.save_settings).grid(row=8, column=1, pady=10, sticky='e')

        # === Budget Depletion Graph ===
        manage = ttk.Frame(top)
        manage.grid(row=0, column=1, sticky='nsew')
        manage.columnconfigure(0, weight=1)
        manage.rowconfigure(0, weight=1)

        graph_frame = ttk.LabelFrame(manage, text="Budget Depletion", padding="5")
        graph_frame.grid(row=0, column=0, sticky='nsew')
        graph_frame.rowconfigure(0, weight=1)
        graph_frame.columnconfigure(0, weight=1)
        
        # Canvas placeholder for matplotlib figure
        self.budget_graph_frame = graph_frame
        self.budget_canvas = None

        report = ttk.LabelFrame(main, text="Daily Budget Report", padding="10")
        report.grid(row=1, column=0, sticky='nsew', pady=(10, 0))
        report.rowconfigure(1, weight=1)
        report.columnconfigure(0, weight=1)

        month_frame = ttk.Frame(report)
        month_frame.grid(row=0, column=0, sticky='ew', pady=5)
        ttk.Label(month_frame, text="Select Month:").pack(side='left', padx=5)
        self.budget_month_entry = ttk.Entry(month_frame, width=15)
        self.budget_month_entry.insert(0, datetime.now().strftime("%Y-%m"))
        self.budget_month_entry.pack(side='left', padx=5)
        ttk.Button(month_frame, text="Generate Report", command=self.generate_report).pack(side='left', padx=10)
        ttk.Button(month_frame, text="Export Report", command=self.export_report).pack(side='left', padx=5)

        text_frame = ttk.Frame(report)
        text_frame.grid(row=1, column=0, sticky='nsew', pady=(10, 0))
        text_frame.rowconfigure(0, weight=1)
        text_frame.columnconfigure(0, weight=1)
        self.report_text = tk.Text(text_frame, height=20, width=90, font=('Courier New', 9))
        self.report_text.grid(row=0, column=0, sticky='nsew')
        scroll = ttk.Scrollbar(text_frame, orient='vertical', command=self.report_text.yview)
        scroll.grid(row=0, column=1, sticky='ns')
        self.report_text.configure(yscrollcommand=scroll.set)

        self.refresh_balance_entries()
        # self.refresh_income_tree() # Moved to manager window
        self._update_costs_display()
        self._refresh_budget_graph()

    def _update_income_display(self):
        """Update the readonly income display with CURRENT month's active income."""
        from ...services.budget_calculator import get_active_monthly_income
        current_month = datetime.now().strftime("%Y-%m")
        active_income = get_active_monthly_income(self.state, current_month)
        self.income_entry_display.config(state='normal')
        self.income_entry_display.delete(0, tk.END)
        self.income_entry_display.insert(0, f"{active_income:.2f}")
        self.income_entry_display.config(state='readonly')

    def _update_costs_display(self):
        """Update the readonly costs display with CURRENT month's active fixed costs."""
        from ...services.budget_calculator import get_active_fixed_costs
        current_month = datetime.now().strftime("%Y-%m")
        active_costs = get_active_fixed_costs(self.state, current_month)
        total_costs = sum(fc['amount'] for fc in active_costs)
        self.costs_entry_display.config(state='normal')
        self.costs_entry_display.delete(0, tk.END)
        self.costs_entry_display.insert(0, f"{total_costs:.2f}")
        self.costs_entry_display.config(state='readonly')

    def _refresh_budget_graph(self):
        """Render the budget depletion graph in the main UI."""
        # Use current month or the one selected in report if they match? 
        # Usually dashboard should show CURRENT month.
        current_month = datetime.now().strftime("%Y-%m")
        fig = create_budget_depletion_figure(self.state, current_month)
        
        # Clear previous canvas if exists
        if self.budget_canvas:
            self.budget_canvas.get_tk_widget().destroy()
            
        self.budget_canvas = FigureCanvasTkAgg(fig, master=self.budget_graph_frame)
        self.budget_canvas.draw()
        self.budget_canvas.get_tk_widget().pack(fill='both', expand=True)

    def _open_income_manager(self):
        win = tk.Toplevel()
        win.title("Base Monthly Income Manager")
        win.geometry("700x500")
        win.transient()
        win.grab_set()

        main = ttk.Frame(win, padding=10)
        main.pack(fill='both', expand=True)
        
        ttk.Label(main, text="Manage source of base monthly income here.\n(Historical changes will be preserved)", 
                 font=('Arial', 10, 'italic'), foreground='gray').pack(pady=(0, 10))

        # ID wrapper for refresh
        self.inc_win = win

        # Treeview
        tree_frame = ttk.Frame(main)
        tree_frame.pack(fill='both', expand=True)

        self.income_tree = ttk.Treeview(tree_frame, columns=('Description', 'Amount', 'Start Date', 'End Date'), show='headings', height=8)
        self.income_tree.heading('Description', text='Description')
        self.income_tree.heading('Amount', text='Amount (€)')
        self.income_tree.heading('Start Date', text='Start Date')
        self.income_tree.heading('End Date', text='End Date')
        self.income_tree.column('Description', width=150)
        self.income_tree.column('Amount', width=100, anchor='e')
        self.income_tree.column('Start Date', width=100, anchor='center')
        self.income_tree.column('End Date', width=100, anchor='center')
        self.income_tree.pack(side='left', fill='both', expand=True)
        
        inc_scroll = ttk.Scrollbar(tree_frame, orient='vertical', command=self.income_tree.yview)
        inc_scroll.pack(side='right', fill='y')
        self.income_tree.configure(yscrollcommand=inc_scroll.set)

        # Form
        form = ttk.LabelFrame(main, text="Add/Edit Income Source", padding=10)
        form.pack(fill='x', pady=10)
        
        r1 = ttk.Frame(form)
        r1.pack(fill='x', pady=2)
        ttk.Label(r1, text="Description:").pack(side='left', padx=5)
        self.inc_desc_entry = ttk.Entry(r1)
        self.inc_desc_entry.pack(side='left', expand=True, fill='x', padx=5)
        ttk.Label(r1, text="Amount:").pack(side='left', padx=5)
        self.inc_amount_entry = ttk.Entry(r1, width=15)
        self.inc_amount_entry.pack(side='left', padx=5)

        r2 = ttk.Frame(form)
        r2.pack(fill='x', pady=5)
        ttk.Label(r2, text="Start Date:").pack(side='left', padx=5)
        self.inc_start_date_entry = ttk.Entry(r2, width=15)
        self.inc_start_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.inc_start_date_entry.pack(side='left', padx=5)
        
        ttk.Label(r2, text="End Date (Optional):").pack(side='left', padx=5)
        self.inc_end_date_entry = ttk.Entry(r2, width=15)
        self.inc_end_date_entry.pack(side='left', padx=5)

        btns = ttk.Frame(main)
        btns.pack(fill='x')
        ttk.Button(btns, text="Add New Income", command=self.add_income).pack(side='left', padx=5)
        ttk.Button(btns, text="Update Selected", command=self.update_income).pack(side='left', padx=5)
        ttk.Button(btns, text="Delete Selected", command=self.delete_income).pack(side='left', padx=5)
        ttk.Button(btns, text="Close", command=win.destroy).pack(side='right', padx=5)

        self.refresh_income_tree()

    def _open_fixed_costs_manager(self):
        win = tk.Toplevel()
        win.title("Base Monthly Costs Manager")
        win.geometry("800x600")
        win.transient()
        win.grab_set()

        # Bind ESC to close window
        win.bind('<Escape>', lambda e: win.destroy())

        main = ttk.Frame(win, padding=10)
        main.pack(fill='both', expand=True)
        
        ttk.Label(main, text="Manage recurring fixed monthly costs here.\n(Historical changes will be preserved)", 
                 font=('Arial', 10, 'italic'), foreground='gray').pack(pady=(0, 10))

        # ID wrapper for refresh
        self.fc_win = win

        # Treeview
        tree_frame = ttk.Frame(main)
        tree_frame.pack(fill='both', expand=True)

        self.fixed_costs_tree = ttk.Treeview(tree_frame, columns=('Description', 'Amount', 'Start Date', 'End Date'), show='headings', height=10)
        self.fixed_costs_tree.heading('Description', text='Description')
        self.fixed_costs_tree.heading('Amount', text='Amount (€)')
        self.fixed_costs_tree.heading('Start Date', text='Start Date')
        self.fixed_costs_tree.heading('End Date', text='End Date')
        self.fixed_costs_tree.column('Description', width=200)
        self.fixed_costs_tree.column('Amount', width=100, anchor='e')
        self.fixed_costs_tree.column('Start Date', width=120, anchor='center')
        self.fixed_costs_tree.column('End Date', width=120, anchor='center')
        self.fixed_costs_tree.pack(side='left', fill='both', expand=True)
        
        fc_scroll = ttk.Scrollbar(tree_frame, orient='vertical', command=self.fixed_costs_tree.yview)
        fc_scroll.pack(side='right', fill='y')
        self.fixed_costs_tree.configure(yscrollcommand=fc_scroll.set)

        # Form
        form = ttk.LabelFrame(main, text="Add/Edit Fixed Cost Source", padding=10)
        form.pack(fill='x', pady=10)
        
        r1 = ttk.Frame(form)
        r1.pack(fill='x', pady=2)
        ttk.Label(r1, text="Description:").pack(side='left', padx=5)
        self.fc_desc_entry = ttk.Entry(r1)
        self.fc_desc_entry.pack(side='left', expand=True, fill='x', padx=5)
        ttk.Label(r1, text="Amount:").pack(side='left', padx=5)
        self.fc_amount_entry = ttk.Entry(r1, width=15)
        self.fc_amount_entry.pack(side='left', padx=5)

        r2 = ttk.Frame(form)
        r2.pack(fill='x', pady=5)
        ttk.Label(r2, text="Start Date:").pack(side='left', padx=5)
        self.fc_start_date_entry = ttk.Entry(r2, width=15)
        self.fc_start_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.fc_start_date_entry.pack(side='left', padx=5)
        
        ttk.Label(r2, text="End Date (Optional):").pack(side='left', padx=5)
        self.fc_end_date_entry = ttk.Entry(r2, width=15)
        self.fc_end_date_entry.pack(side='left', padx=5)

        btns = ttk.Frame(main)
        btns.pack(fill='x')
        ttk.Button(btns, text="Add New Cost", command=self.add_fixed_cost).pack(side='left', padx=5)
        ttk.Button(btns, text="Update Selected", command=self.update_fixed_cost).pack(side='left', padx=5)
        ttk.Button(btns, text="Delete Selected", command=self.delete_fixed_cost).pack(side='left', padx=5)
        ttk.Button(btns, text="Close", command=win.destroy).pack(side='right', padx=5)

        self.refresh_fixed_costs_tree()

    def _update_money_lent_button(self):
        """Update the money lent entry with current balance."""
        balance = self.state.budget_settings.get('money_lent_balance', 0)
        self.money_lent_entry.config(state='normal')
        self.money_lent_entry.delete(0, tk.END)
        self.money_lent_entry.insert(0, f"{balance:.2f}")
        self.money_lent_entry.config(state='readonly')

    def _open_lending_manager(self):
        """Open the lending manager window to manage individual loans."""
        loan_win = tk.Toplevel()
        loan_win.title("Lending Manager")
        loan_win.geometry("800x600")
        loan_win.minsize(600, 500)
        loan_win.transient()
        loan_win.grab_set()
        
        # Bind ESC to close window
        loan_win.bind('<Escape>', lambda e: loan_win.destroy())

        main_frame = ttk.Frame(loan_win, padding=10)
        main_frame.pack(fill='both', expand=True)

        # Current balance display
        balance = self.state.budget_settings.get('money_lent_balance', 0)
        self.loan_balance_label = ttk.Label(main_frame, text=f"Total Money Lent: €{balance:.2f}", font=('Arial', 12, 'bold'))
        self.loan_balance_label.pack(pady=(0, 10))

        # Loans treeview
        tree_frame = ttk.Frame(main_frame)
        tree_frame.pack(fill='both', expand=True)
        tree_frame.columnconfigure(0, weight=1)
        tree_frame.rowconfigure(0, weight=1)

        self.loans_tree = ttk.Treeview(tree_frame, columns=('Borrower', 'Amount', 'Description', 'Date'), show='headings', height=8)
        self.loans_tree.heading('Borrower', text='Borrower')
        self.loans_tree.heading('Amount', text='Amount (€)')
        self.loans_tree.heading('Description', text='Description')
        self.loans_tree.heading('Date', text='Date')
        self.loans_tree.column('Borrower', width=120)
        self.loans_tree.column('Amount', width=80, anchor='e')
        self.loans_tree.column('Description', width=150)
        self.loans_tree.column('Date', width=90, anchor='center')
        self.loans_tree.grid(row=0, column=0, sticky='nsew')
        
        loans_scroll = ttk.Scrollbar(tree_frame, orient='vertical', command=self.loans_tree.yview)
        loans_scroll.grid(row=0, column=1, sticky='ns')
        self.loans_tree.configure(yscrollcommand=loans_scroll.set)

        # Add loan form
        form_frame = ttk.LabelFrame(main_frame, text="Add New Loan", padding=10)
        form_frame.pack(fill='x', pady=10)

        ttk.Label(form_frame, text="Borrower:").grid(row=0, column=0, sticky='w', padx=5)
        self.loan_borrower_entry = ttk.Entry(form_frame, width=15)
        self.loan_borrower_entry.grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(form_frame, text="Amount:").grid(row=0, column=2, sticky='w', padx=5)
        self.loan_amount_entry = ttk.Entry(form_frame, width=10)
        self.loan_amount_entry.grid(row=0, column=3, padx=5, pady=5)

        ttk.Label(form_frame, text="Description:").grid(row=0, column=4, sticky='w', padx=5)
        self.loan_desc_entry = ttk.Entry(form_frame, width=20)
        self.loan_desc_entry.grid(row=0, column=5, padx=5, pady=5)

        ttk.Button(form_frame, text="Add Loan", command=lambda: self._add_loan(loan_win)).grid(row=0, column=6, padx=10)

        # Buttons frame
        btn_frame = ttk.Frame(main_frame)
        btn_frame.pack(fill='x', pady=(0, 5))

        ttk.Button(btn_frame, text="Mark as Returned", command=lambda: self._mark_loan_returned(loan_win)).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="Close", command=loan_win.destroy).pack(side='right', padx=5)

        # Populate loans list
        self._refresh_loans_tree()

    def _refresh_loans_tree(self):
        """Refresh the loans treeview with current data."""
        for item in self.loans_tree.get_children():
            self.loans_tree.delete(item)
        
        loans = self.state.budget_settings.get('loans', [])
        for loan in loans:
            self.loans_tree.insert('', 'end', iid=loan['id'], 
                                   values=(loan['borrower'], f"{loan['amount']:.2f}", loan.get('description', ''), loan['date']))

    def _add_loan(self, loan_win):
        """Add a new loan and update the balance."""
        borrower = self.loan_borrower_entry.get().strip()
        amount_str = self.loan_amount_entry.get().strip()

        if not borrower:
            messagebox.showerror("Error", "Please enter a borrower name.", parent=loan_win)
            return

        try:
            amount = float(amount_str)
            if amount <= 0:
                messagebox.showerror("Error", "Amount must be positive.", parent=loan_win)
                return
        except ValueError:
            messagebox.showerror("Error", "Invalid amount.", parent=loan_win)
            return

        # Create loan record
        loan_id = f"{datetime.now().timestamp()}"
        description = self.loan_desc_entry.get().strip()
        loan = {
            'id': loan_id,
            'borrower': borrower,
            'amount': amount,
            'description': description,
            'date': datetime.now().strftime("%Y-%m-%d")
        }

        # Add to loans list
        if 'loans' not in self.state.budget_settings:
            self.state.budget_settings['loans'] = []
        self.state.budget_settings['loans'].append(loan)

        # Update money lent balance
        self.state.budget_settings['money_lent_balance'] = self.state.budget_settings.get('money_lent_balance', 0) + amount
        self.state.save()

        # Refresh UI
        self._refresh_loans_tree()
        self._update_loan_balance_label()
        self._update_money_lent_button()

        # Clear form
        self.loan_borrower_entry.delete(0, tk.END)
        self.loan_amount_entry.delete(0, tk.END)
        self.loan_desc_entry.delete(0, tk.END)

        messagebox.showinfo("Success", f"Loan of €{amount:.2f} to {borrower} recorded.", parent=loan_win)

    def _mark_loan_returned(self, loan_win):
        """Mark a loan as returned and update the balance."""
        selected = self.loans_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a loan to mark as returned.", parent=loan_win)
            return

        loan_id = selected[0]
        loans = self.state.budget_settings.get('loans', [])

        # Find and remove the loan
        for i, loan in enumerate(loans):
            if loan['id'] == loan_id:
                amount = loan['amount']
                borrower = loan['borrower']
                del loans[i]
                
                # Update money lent balance
                self.state.budget_settings['money_lent_balance'] = max(0, 
                    self.state.budget_settings.get('money_lent_balance', 0) - amount)
                self.state.save()

                # Refresh UI
                self._refresh_loans_tree()
                self._update_loan_balance_label()
                self._update_money_lent_button()

                messagebox.showinfo("Success", f"Loan of €{amount:.2f} from {borrower} marked as returned.", parent=loan_win)
                return

        messagebox.showerror("Error", "Could not find the selected loan.", parent=loan_win)

    def _update_loan_balance_label(self):
        """Update the balance label in the lending manager window."""
        balance = self.state.budget_settings.get('money_lent_balance', 0)
        self.loan_balance_label.config(text=f"Total Money Lent: €{balance:.2f}")

    def refresh_balance_entries(self):
        s = self.state.budget_settings
        def set_entry(entry, key):
            entry.delete(0, tk.END)
            entry.delete(0, tk.END)
            entry.insert(0, str(s.get(key, 0)))
        
        self._update_income_display() # New display update logic
        self._update_costs_display()
        
        set_entry(self.bank_entry, 'bank_account_balance')
        set_entry(self.wallet_entry, 'wallet_balance')
        set_entry(self.savings_entry, 'savings_balance')
        set_entry(self.investment_entry, 'investment_balance')
        set_entry(self.daily_savings_entry, 'daily_savings_goal')
        self._update_money_lent_button()

    def save_settings(self):
        try:
            s = self.state.budget_settings
            # s['monthly_income'] = float(self.income_entry.get() or 0) # REMOVED
            s['bank_account_balance'] = float(self.bank_entry.get() or 0)
            s['wallet_balance'] = float(self.wallet_entry.get() or 0)
            s['savings_balance'] = float(self.savings_entry.get() or 0)
            s['investment_balance'] = float(self.investment_entry.get() or 0)
            s['daily_savings_goal'] = float(self.daily_savings_entry.get() or 0)
            self.state.save()
            messagebox.showinfo("Success", "Settings saved!")
        except ValueError:
            messagebox.showerror("Error", "Invalid amount in one of the fields.")

    def refresh_fixed_costs_tree(self):
        for i in self.fixed_costs_tree.get_children():
            self.fixed_costs_tree.delete(i)
        for cost in self.state.budget_settings.get('fixed_costs', []):
            end_date_display = cost.get('end_date', 'Active') or 'Active'
            self.fixed_costs_tree.insert('', 'end', values=(
                cost['desc'], 
                f"{cost['amount']:.2f}",
                cost.get('start_date', '2000-01-01'),
                end_date_display
            ))

    def add_fixed_cost(self):
        try:
            desc = self.fc_desc_entry.get().strip()
            amount = float(self.fc_amount_entry.get())
            start_date = self.fc_start_date_entry.get().strip()
            end_date = self.fc_end_date_entry.get().strip()
            
            if not desc:
                messagebox.showerror("Error", "Description cannot be empty.")
                return
            
            # Validate start date
            if not start_date:
                messagebox.showerror("Error", "Start date is required.")
                return
            try:
                datetime.strptime(start_date, "%Y-%m-%d")
            except ValueError:
                messagebox.showerror("Error", "Invalid start date format. Use YYYY-MM-DD.")
                return
            
            # Validate end date if provided
            if end_date:
                try:
                    datetime.strptime(end_date, "%Y-%m-%d")
                except ValueError:
                    messagebox.showerror("Error", "Invalid end date format. Use YYYY-MM-DD.")
                    return
            else:
                end_date = None
            
            self.state.budget_settings['fixed_costs'].append({
                'desc': desc, 
                'amount': amount,
                'start_date': start_date,
                'end_date': end_date
            })
            self.state.save()
            self.refresh_fixed_costs_tree()
            self._update_costs_display()
            self._refresh_budget_graph()
            
            self.fc_desc_entry.delete(0, tk.END)
            self.fc_amount_entry.delete(0, tk.END)
            self.fc_start_date_entry.delete(0, tk.END)
            self.fc_start_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
            self.fc_end_date_entry.delete(0, tk.END)
        except ValueError:
            messagebox.showerror("Error", "Invalid amount for fixed cost.", parent=getattr(self, 'fc_win', None))

    def update_fixed_cost(self):
        selected = self.fixed_costs_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a fixed cost to update.")
            return
        try:
            desc = self.fc_desc_entry.get().strip()
            amount = float(self.fc_amount_entry.get())
            start_date = self.fc_start_date_entry.get().strip()
            end_date = self.fc_end_date_entry.get().strip()
            
            if not desc:
                messagebox.showerror("Error", "Description cannot be empty.")
                return
            
            # Validate dates
            if not start_date:
                messagebox.showerror("Error", "Start date is required.")
                return
            try:
                datetime.strptime(start_date, "%Y-%m-%d")
            except ValueError:
                messagebox.showerror("Error", "Invalid start date format. Use YYYY-MM-DD.")
                return
            
            if end_date:
                try:
                    datetime.strptime(end_date, "%Y-%m-%d")
                except ValueError:
                    messagebox.showerror("Error", "Invalid end date format. Use YYYY-MM-DD.")
                    return
            else:
                end_date = None
            
            original_values = self.fixed_costs_tree.item(selected[0])['values']
            for i, cost in enumerate(self.state.budget_settings['fixed_costs']):
                if cost['desc'] == original_values[0] and f"{cost['amount']:.2f}" == original_values[1]:
                    self.state.budget_settings['fixed_costs'][i] = {
                        'desc': desc, 
                        'amount': amount,
                        'start_date': start_date,
                        'end_date': end_date
                    }
                    break
            self.state.save()
            self.refresh_fixed_costs_tree()
            self._update_costs_display()
            self._refresh_budget_graph()
        except ValueError:
            messagebox.showerror("Error", "Invalid amount for fixed cost.", parent=getattr(self, 'fc_win', None))

        except ValueError:
            messagebox.showerror("Error", "Invalid amount for fixed cost.")

    def refresh_income_tree(self):
        for i in self.income_tree.get_children():
            self.income_tree.delete(i)
        
        income_data = self.state.budget_settings.get('monthly_income', [])
        # Handle migration case just in case
        if isinstance(income_data, (int, float)):
             income_data = [] # Should have been migrated by state load, but be safe
        
        for inc in income_data:
            end_date_display = inc.get('end_date') or 'Active'
            start_date_display = inc.get('start_date') or '2000-01-01'
            self.income_tree.insert('', 'end', values=(
                inc.get('description', 'Base Income'), 
                f"{inc.get('amount', 0):.2f}",
                start_date_display,
                end_date_display
            ))

    def _validate_income_input(self):
        desc = self.inc_desc_entry.get().strip()
        amount_str = self.inc_amount_entry.get()
        start_date = self.inc_start_date_entry.get().strip()
        end_date = self.inc_end_date_entry.get().strip()

        parent = getattr(self, 'inc_win', None)

        if not desc:
            messagebox.showerror("Error", "Description cannot be empty.", parent=parent)
            return None
        
        try:
            amount = float(amount_str)
        except ValueError:
            messagebox.showerror("Error", "Invalid amount.", parent=parent)
            return None

        if not start_date:
            messagebox.showerror("Error", "Start date is required.", parent=parent)
            return None
        try:
            datetime.strptime(start_date, "%Y-%m-%d")
        except ValueError:
            messagebox.showerror("Error", "Invalid start date format. Use YYYY-MM-DD.", parent=parent)
            return None
        
        if end_date:
            try:
                datetime.strptime(end_date, "%Y-%m-%d")
            except ValueError:
                messagebox.showerror("Error", "Invalid end date format. Use YYYY-MM-DD.", parent=parent)
                return None
        else:
            end_date = None

        return {
            'description': desc,
            'amount': amount,
            'start_date': start_date,
            'end_date': end_date
        }

    def add_income(self):
        data = self._validate_income_input()
        if not data:
            return

        # Ensure it's a list
        if not isinstance(self.state.budget_settings.get('monthly_income'), list):
             self.state.budget_settings['monthly_income'] = []

        self.state.budget_settings['monthly_income'].append(data)
        self.state.save()
        self.refresh_income_tree()
        self._update_income_display()
        self._refresh_budget_graph()
        
        self.inc_desc_entry.delete(0, tk.END)
        self.inc_amount_entry.delete(0, tk.END)
        self.inc_start_date_entry.delete(0, tk.END)
        self.inc_start_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.inc_end_date_entry.delete(0, tk.END)

    def update_income(self):
        selected = self.income_tree.selection()
        parent = getattr(self, 'inc_win', None)
        if not selected:
            messagebox.showwarning("Warning", "Please select an income source to update.", parent=parent)
            return
        
        data = self._validate_income_input()
        if not data:
            return

        original_values = self.income_tree.item(selected[0])['values']
        # Find match - this is slightly fragile if duplicates exist, but sufficient for this scope
        incomes = self.state.budget_settings.get('monthly_income', [])
        for i, inc in enumerate(incomes):
            # Compare basic fields to identify
            orig_desc = inc.get('description', 'Base Income')
            orig_amt = f"{inc.get('amount', 0):.2f}"
            if orig_desc == original_values[0] and orig_amt == original_values[1]:
                incomes[i] = data
                break
        
        self.state.save()
        self.refresh_income_tree()
        self._update_income_display()
        self._refresh_budget_graph()

    def delete_income(self):
        selected = self.income_tree.selection()
        parent = getattr(self, 'inc_win', None)
        if not selected:
            messagebox.showwarning("Warning", "Please select an income source to delete.", parent=parent)
            return
        
        values = self.income_tree.item(selected[0])['values']
        desc_to_del = values[0]
        amt_to_del = values[1]

        incomes = self.state.budget_settings.get('monthly_income', [])
        for i, inc in enumerate(incomes):
            if inc.get('description', 'Base Income') == desc_to_del and f"{inc.get('amount', 0):.2f}" == amt_to_del:
                
                # Archive option
                if inc.get('end_date') is None:
                    response = messagebox.askyesnocancel(
                        "Delete or Archive?",
                        f"Do you want to:\n\n"
                        f"YES - Set an end date (archives it)\n"
                        f"NO - Permanently delete\n"
                        f"CANCEL - Keep it",
                        parent=parent
                    )
                    if response is None: return
                    elif response:
                        inc['end_date'] = datetime.now().strftime("%Y-%m-%d")
                        self.state.save()
                        self.refresh_income_tree()
                        self._update_income_display()
                        self._refresh_budget_graph()
                        return
                
                del incomes[i]
                self.state.save()
                self.refresh_income_tree()
                self._update_income_display()
                self._refresh_budget_graph()
                return

    def delete_fixed_cost(self):
        selected = self.fixed_costs_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a fixed cost to delete.")
            return
        
        values = self.fixed_costs_tree.item(selected[0])['values']
        desc_to_delete = values[0]
        amount_to_delete = float(values[1])
        
        # Find and remove the matching cost
        for i, cost in enumerate(self.state.budget_settings['fixed_costs']):
            if cost['desc'] == desc_to_delete and cost['amount'] == amount_to_delete:
                # Instead of deleting, ask if user wants to set end date
                if cost.get('end_date') is None:
                    response = messagebox.askyesnocancel(
                        "Delete or Archive?",
                        f"Do you want to:\n\n"
                        f"YES - Set an end date (archives the cost)\n"
                        f"NO - Permanently delete this cost\n"
                        f"CANCEL - Keep the cost as-is"
                    )
                    if response is None:  # Cancel
                        return
                    elif response:  # Yes - set end date
                        end_date = datetime.now().strftime("%Y-%m-%d")
                        cost['end_date'] = end_date
                        self.state.save()
                        self.refresh_fixed_costs_tree()
                        messagebox.showinfo("Success", f"Cost archived with end date: {end_date}")
                        return
                    # else: fall through to delete
                
                # Permanently delete
                del self.state.budget_settings['fixed_costs'][i]
                self.state.save()
                self.refresh_fixed_costs_tree()
                self._update_costs_display()
                self._refresh_budget_graph()
                return
        
        messagebox.showerror("Error", "Could not find the selected fixed cost item.", parent=getattr(self, 'fc_win', None))

    def generate_report(self):
        month = self.budget_month_entry.get()
        text = generate_daily_budget_report(self.state, month)
        self.report_text.delete("1.0", tk.END)
        self.report_text.insert("1.0", text)
        
        # Also refresh graph for the selected month
        fig = create_budget_depletion_figure(self.state, month)
        if self.budget_canvas:
            self.budget_canvas.get_tk_widget().destroy()
        self.budget_canvas = FigureCanvasTkAgg(fig, master=self.budget_graph_frame)
        self.budget_canvas.draw()
        self.budget_canvas.get_tk_widget().pack(fill='both', expand=True)

    def export_report(self):
        content = self.report_text.get("1.0", tk.END).strip()
        if not content:
            messagebox.showwarning("Warning", "Please generate a report before exporting.")
            return
        today = datetime.now().strftime("%Y-%m-%d")
        month_str = self.budget_month_entry.get()
        default_filename = f"day_report_{month_str}_{today}.txt"
        path = filedialog.asksaveasfilename(
            initialfile=default_filename,
            defaultextension=".txt",
            filetypes=[("Text Documents", "*.txt"), ("All Files", "*.*")]
        )
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(content)
            messagebox.showinfo("Success", f"Report successfully exported to:\n{path}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export report.\nError: {e}")"""
finance_tracker/ui/tabs/reports_tab.py

Tab for generating and viewing various financial reports and charts.
"""

import tkinter as tk
from tkinter import ttk, messagebox
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

from ...services.report_builder import pie_data, history_data
from ...services.budget_calculator import compute_net_available_for_spending, get_active_fixed_costs, get_active_monthly_income
from ..charts import create_bar_figure, create_pie_figure

class ReportsTab:
    def __init__(self, notebook, state):
        self.state = state
        self.canvas = None
        self.bar_breakdown_mode = "total"  # "total", "categories", "flexible", or "over_under"
        self.bar_display_mode = "value"  # "value" or "percentage"

        main = ttk.Frame(notebook, padding="10")
        notebook.add(main, text="Charts")
        main.rowconfigure(1, weight=1)
        main.columnconfigure(0, weight=1)

        controls = ttk.LabelFrame(main, text="Chart Options", padding="10")
        controls.grid(row=0, column=0, sticky='ew', pady=5)

        top = ttk.Frame(controls)
        top.pack(fill='x', expand=True, pady=(0, 10))

        # Chart style
        style_frame = ttk.Frame(top)
        style_frame.pack(side='left', padx=(0, 20))
        ttk.Label(style_frame, text="Chart Style:").pack(side='left')
        self.style_var = tk.StringVar(value="Pie Chart")
        ttk.Radiobutton(style_frame, text="Pie Chart", variable=self.style_var, value="Pie Chart",
                        command=self._toggle_controls).pack(anchor='w')
        ttk.Radiobutton(style_frame, text="Historical Bar Chart", variable=self.style_var, value="Bar Chart",
                        command=self._toggle_controls).pack(anchor='w')

        # Data type
        type_frame = ttk.Frame(top)
        type_frame.pack(side='left', padx=(0, 20))
        ttk.Label(type_frame, text="Data Type:").pack(side='left')
        self.chart_type_var = tk.StringVar(value="Expense")
        ttk.Radiobutton(type_frame, text="Expenses", variable=self.chart_type_var, value="Expense",
                        command=self._toggle_fixed_controls).pack(side='left')
        ttk.Radiobutton(type_frame, text="Incomes", variable=self.chart_type_var, value="Income",
                        command=self._toggle_fixed_controls).pack(side='left', padx=5)

        # Pie controls
        self.pie_controls = ttk.Frame(top)
        self.pie_controls.pack(side='left', padx=(0, 15))
        ttk.Label(self.pie_controls, text="Select Month:").pack(side='left')
        self.month_entry = ttk.Entry(self.pie_controls, width=15)
        from datetime import datetime
        self.month_entry.insert(0, datetime.now().strftime("%Y-%m"))
        self.month_entry.pack(side='left', padx=5)
        ttk.Label(self.pie_controls, text="Display As:").pack(side='left', padx=(10, 0))
        self.value_type_var = tk.StringVar(value="Total")
        ttk.Radiobutton(self.pie_controls, text="%", variable=self.value_type_var, value="Percentage").pack(side='left')
        ttk.Radiobutton(self.pie_controls, text="€", variable=self.value_type_var, value="Total").pack(side='left', padx=5)

        # Bar controls
        self.bar_controls = ttk.Frame(top)
        ttk.Label(self.bar_controls, text="Number of Months:").pack(side='left')
        self.months_entry = ttk.Entry(self.bar_controls, width=10)
        self.months_entry.insert(0, "6")
        self.months_entry.pack(side='left', padx=5)

        bottom = ttk.Frame(controls)
        bottom.pack(fill='x', expand=True)

        self.fixed_frame = ttk.Frame(bottom)
        self.fixed_frame.pack(side='left', padx=(0, 15))
        self.include_fixed_var = tk.BooleanVar(value=False)
        self.fixed_check = ttk.Checkbutton(self.fixed_frame, text="Include Fixed Costs", variable=self.include_fixed_var)
        self.include_base_var = tk.BooleanVar(value=False)
        self.base_check = ttk.Checkbutton(self.fixed_frame, text="Include Base Income", variable=self.include_base_var)
        self._toggle_fixed_controls()

        self.show_budget_lines_var = tk.BooleanVar(value=False)
        self.budget_lines_check = ttk.Checkbutton(bottom, text="Show Budget Limits", variable=self.show_budget_lines_var)
        self.budget_lines_check.pack(side='left', padx=(0, 15))

        ttk.Button(bottom, text="Generate Chart", command=self.generate).pack(side='right')

        # Split view for Chart and Info
        self.paned = ttk.PanedWindow(main, orient='horizontal')
        self.paned.grid(row=1, column=0, sticky='nsew', pady=10)
        
        self.chart_frame = ttk.Frame(self.paned)
        self.paned.add(self.chart_frame, weight=4)
        
        self.info_frame = ttk.LabelFrame(self.paned, text="Details", padding=10)
        self.paned.add(self.info_frame, weight=1)
        
        # Info text widget
        self.info_text = tk.Text(self.info_frame, wrap='word', width=30, height=20, state='disabled', 
                               bg='#f0f0f0', relief='flat', font=('Arial', 10))
        self.info_text.pack(fill='both', expand=True)

        self._toggle_controls()

    def _toggle_controls(self):
        s = self.style_var.get()
        self.pie_controls.pack_forget()
        self.bar_controls.pack_forget()
        self.budget_lines_check.pack_forget()
        if s == "Pie Chart":
            self.pie_controls.pack(side='left', padx=(0, 15))
            self.budget_lines_check.pack(side='left', padx=(0, 15))
            self._update_info_panel([])
            self.paned.pane(self.chart_frame, weight=110)
            self.paned.pane(self.info_frame, weight=1)
        else:
            self.bar_controls.pack(side='left', padx=(0, 15))
            self._update_info_panel(["Click on chart to toggle: Total → Categories → Flexible → Over/Under view", 
                                   "Right-click to toggle: Value/Percentage display"], title="Instructions")
            self.paned.pane(self.chart_frame, weight=90)
            self.paned.pane(self.info_frame, weight=1)

    def _toggle_fixed_controls(self):
        self.fixed_check.pack_forget()
        self.base_check.pack_forget()
        if self.chart_type_var.get() == "Expense":
            self.fixed_check.pack()
        else:
            self.base_check.pack()

    def generate(self):
        if self.canvas:
            self.canvas.get_tk_widget().destroy()
            self.canvas = None
        style = self.style_var.get()
        if style == "Pie Chart":
            self._make_pie()
        else:
            # Reset to defaults when generating new chart
            self.bar_breakdown_mode = "total"
            self.bar_display_mode = "value"
            self._make_bar()

    def _update_info_panel(self, lines, title="Details"):
        self.info_frame.config(text=title)
        self.info_text.config(state='normal')
        self.info_text.delete('1.0', tk.END)
        if lines:
            for line in lines:
                self.info_text.insert(tk.END, line + "\n\n")
        self.info_text.config(state='disabled')

    def _make_bar(self):
        try:
            n = int(self.months_entry.get())
            if n <= 1:
                messagebox.showerror("Error", "Number of months must be greater than 1.")
                return
        except ValueError:
            messagebox.showerror("Error", "Invalid number of months.")
            return

        title, labels, values = history_data(
            self.state, n, self.chart_type_var.get(),
            include_fixed=self.include_fixed_var.get(),
            include_base_income=self.include_base_var.get()
        )
        if not any(values):
            messagebox.showinfo("No Data", "No data to display for the selected period.")
            return

        # Store data for interactive updates
        self.bar_chart_data = {
            'labels': labels,
            'values': values,
            'title': title,
            'num_months': n
        }

        self._render_bar_chart()

    def _render_bar_chart(self):
        """Render the bar chart based on current breakdown and display modes"""
        if self.canvas:
            self.canvas.get_tk_widget().destroy()
            self.canvas = None

        labels = self.bar_chart_data['labels']
        title = self.bar_chart_data['title']
        values = self.bar_chart_data['values']
        
        category_data = None
        if self.bar_breakdown_mode == "categories":
            category_data = self._get_category_breakdown_data(labels)
            if not category_data:
                messagebox.showinfo("No Data", "No category data available for breakdown.")
                self.bar_breakdown_mode = "total"
                # Fallback to total view
                category_data = None
        elif self.bar_breakdown_mode == "flexible":
            category_data = self._get_flexible_breakdown_data(labels)
            if not category_data:
                messagebox.showinfo("No Data", "No flexible data available.")
                self.bar_breakdown_mode = "total"
                category_data = None
        elif self.bar_breakdown_mode == "over_under":
            category_data = self._get_over_under_data(labels)
            if not category_data:
                messagebox.showinfo("No Data", "No data available for Over/Under view.")
                self.bar_breakdown_mode = "total"
                category_data = None

        fig = create_bar_figure(labels, values, title, 
                              breakdown_mode=self.bar_breakdown_mode,
                              display_mode=self.bar_display_mode,
                              category_data=category_data)
        
        if not fig:
            return

        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill='both', expand=True)
        
        # Bind click events
        self.canvas.mpl_connect('button_press_event', self._on_bar_click)

    def _get_category_breakdown_data(self, months):
        """Get category-wise data for each month"""
        chart_type = self.chart_type_var.get()
        data_source = self.state.expenses if chart_type == "Expense" else self.state.incomes
        
        # Get all categories
        categories = self.state.categories.get(chart_type, [])
        
        # Initialize data structure
        category_data = {cat: [0.0] * len(months) for cat in categories}
        
        # Populate data
        for month_idx, month in enumerate(months):
            for item in data_source:
                if item['date'].startswith(month):
                    cat = item['category']
                    if cat in category_data:
                        category_data[cat][month_idx] += item['amount']
        
        # Remove categories with no data
        category_data = {cat: values for cat, values in category_data.items() if sum(values) > 0}
        
        # Add fixed costs or base income if needed
        if chart_type == "Expense" and self.include_fixed_var.get():
            # Calculate fixed costs for each month individually
            fixed_costs_by_month = []
            for month in months:
                month_fixed = sum(fc['amount'] for fc in get_active_fixed_costs(self.state, month))
                fixed_costs_by_month.append(month_fixed)
            if sum(fixed_costs_by_month) > 0:
                category_data["Fixed Costs"] = fixed_costs_by_month
        elif chart_type == "Income" and self.include_base_var.get():
            base_incomes = []
            for month in months:
                base_incomes.append(get_active_monthly_income(self.state, month))
            
            if sum(base_incomes) > 0:
                category_data["Base Income"] = base_incomes
        
        return category_data

    def _get_flexible_breakdown_data(self, months):
        """Get flexible income vs flexible costs data for each month"""
        flexible_income = [0.0] * len(months)
        flexible_costs = [0.0] * len(months)
        
        # Calculate flexible income (incomes without base income)
        for month_idx, month in enumerate(months):
            for item in self.state.incomes:
                if item['date'].startswith(month):
                    flexible_income[month_idx] += item['amount']
        
        # Calculate flexible costs (expenses without fixed costs)
        for month_idx, month in enumerate(months):
            for item in self.state.expenses:
                if item['date'].startswith(month):
                    flexible_costs[month_idx] += item['amount']
        
        # Only return if there's some data
        if sum(flexible_income) == 0 and sum(flexible_costs) == 0:
            return None
        
        return {
            "Flexible Income": flexible_income,
            "Flexible Costs": flexible_costs
        }

    def _get_over_under_data(self, months):
        """Get total income vs total expenses for each month"""
        total_income = [0.0] * len(months)
        total_expenses = [0.0] * len(months)

        # 1. Total Income = Base Income + All Incomes
        # base_income = self.state.budget_settings.get('monthly_income', 0) # REMOVED
        
        for month_idx, month in enumerate(months):
            # Add base income
            total_income[month_idx] += get_active_monthly_income(self.state, month)
            
            # Add variable incomes
            for item in self.state.incomes:
                if item['date'].startswith(month):
                    total_income[month_idx] += item['amount']
                    
            # 2. Total Expenses = Fixed Costs + All Expenses
            # Add fixed costs (only those active in this specific month)
            month_fixed_costs = sum(fc['amount'] for fc in get_active_fixed_costs(self.state, month))
            total_expenses[month_idx] += month_fixed_costs
            
            # Add variable expenses
            for item in self.state.expenses:
                if item['date'].startswith(month):
                    total_expenses[month_idx] += item['amount']
                    
        # Only return if there's some data
        if sum(total_income) == 0 and sum(total_expenses) == 0:
            return None
            
        return {
            "Total Income": total_income,
            "Total Expenses": total_expenses
        }

    def _on_bar_click(self, event):
        """Handle click events on the bar chart"""
        if event.inaxes is None:
            return
        
        # Left click: toggle breakdown mode (total -> categories -> flexible -> total)
        if event.button == 1:
            if self.bar_breakdown_mode == "total":
                self.bar_breakdown_mode = "categories"
            elif self.bar_breakdown_mode == "categories":
                self.bar_breakdown_mode = "flexible"
            elif self.bar_breakdown_mode == "flexible":
                self.bar_breakdown_mode = "over_under"
            else:
                self.bar_breakdown_mode = "total"
            self._render_bar_chart()
        
        # Right click: toggle display mode (in category or flexible view)
        elif event.button == 3:
            if self.bar_breakdown_mode in ("categories", "flexible", "over_under"):
                if self.bar_display_mode == "value":
                    self.bar_display_mode = "percentage"
                else:
                    self.bar_display_mode = "value"
                self._render_bar_chart()

    def _make_pie(self):
        month = self.month_entry.get()
        title, totals = pie_data(
            self.state, month, self.chart_type_var.get(),
            include_fixed=self.include_fixed_var.get(),
            include_base_income=self.include_base_var.get()
        )
        if not totals:
            from tkinter import messagebox
            messagebox.showinfo("No Data", f"No data to display for {month}.")
            return
        labels = list(totals.keys())
        sizes = list(totals.values())

        budget_info = []
        if self.show_budget_lines_var.get() and self.chart_type_var.get() == "Expense":
            expense_budgets = self.state.budget_settings.get('category_budgets', {}).get('Expense', {})
            nav = compute_net_available_for_spending(self.state, month)
            for cat in labels:
                pct_limit = expense_budgets.get(cat, 0)
                if pct_limit > 0 and nav > 0:
                    actual = totals.get(cat, 0)
                    budget_amount = (pct_limit / 100.0) * nav
                    used_pct = (actual / budget_amount) * 100 if budget_amount > 0 else 0
                    remaining = max(budget_amount - actual, 0)
                    budget_info.append(f"{cat}:\n{used_pct:.0f}% of budget\nLeft: €{remaining:.2f}")

        if budget_info:
            self._update_info_panel(budget_info, title="Budget Status")
        else:
            self._update_info_panel([], title="Details")

        fig = create_pie_figure(labels, sizes, title, 
                              value_type=self.value_type_var.get())
        
        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill='both', expand=True)# tabs package"""
finance_tracker/ui/tabs/budgets_tab.py

Tab for managing category budget limits and viewing budget status.
"""

import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime
from ...services.budget_calculator import compute_net_available_for_spending, auto_assign_percentages

class BudgetsTab:
    def __init__(self, notebook, state):
        self.state = state
        self.budget_sliders = {}
        self._slider_lock = False

        main = ttk.Frame(notebook, padding="10")
        notebook.add(main, text="Budgets Limits")
        main.rowconfigure(1, weight=1)
        main.columnconfigure(0, weight=1)

        toolbar = ttk.Frame(main)
        toolbar.grid(row=0, column=0, sticky='ew', pady=(0, 5))
        ttk.Label(toolbar, text="Budget Month (YYYY-MM):").pack(side='left', padx=(0, 5))
        self.month_var = tk.StringVar(value=datetime.now().strftime("%Y-%m"))
        ttk.Entry(toolbar, textvariable=self.month_var, width=10).pack(side='left')
        ttk.Button(toolbar, text="Refresh Amounts", command=self._update_monetary_labels).pack(side='left', padx=10)

        group = ttk.LabelFrame(main, text="Category Budget Limits", padding="10")
        group.grid(row=1, column=0, sticky='nsew')

        self._create_widgets(group)

    def _create_widgets(self, parent):
        parent.rowconfigure(3, weight=1)
        parent.columnconfigure(0, weight=1)

        self.cat_type_var = tk.StringVar(value="Expense")
        type_frame = ttk.Frame(parent)
        type_frame.grid(row=0, column=0, sticky='ew', pady=2)
        ttk.Label(type_frame, text="Type:").pack(side='left')
        ttk.Radiobutton(type_frame, text="Expense", variable=self.cat_type_var, value="Expense",
                        command=self._on_category_type_changed).pack(side='left', padx=5)
        ttk.Radiobutton(type_frame, text="Income", variable=self.cat_type_var, value="Income",
                        command=self._on_category_type_changed).pack(side='left', padx=5)

        manage = ttk.Frame(parent)
        manage.grid(row=1, column=0, sticky='ew', pady=5)
        ttk.Label(manage, text="New Category:").pack(side='left', padx=(0, 5))
        self.new_cat_entry = ttk.Entry(manage, width=20)
        self.new_cat_entry.pack(side='left')
        ttk.Button(manage, text="Add", command=self.add_category).pack(side='left', padx=5)

        ttk.Label(manage, text="Remove Category:").pack(side='left', padx=(10, 5))
        self.remove_cat_combo = ttk.Combobox(manage, width=20, state='readonly')
        self.remove_cat_combo.pack(side='left')
        ttk.Button(manage, text="Remove", command=self.remove_category).pack(side='left', padx=5)

        self.sliders_frame = ttk.Frame(parent)
        self.sliders_frame.grid(row=2, column=0, sticky='nsew', pady=5)

        btns = ttk.Frame(parent)
        btns.grid(row=3, column=0, sticky='ew', pady=5)
        
        # Create buttons and labels
        self.auto_assign_btn = ttk.Button(btns, text="Auto-Assign From Expenses", command=self.auto_assign)
        self.auto_assign_btn.pack(side='left', padx=(0, 5))
        
        self.normalize_btn = ttk.Button(btns, text="Normalize to 100%", 
                                      command=lambda: (self._normalize_sliders(), self._update_total_percentage_label()))
        self.normalize_btn.pack(side='left', padx=(0, 10))
        
        spacer = ttk.Frame(btns)
        spacer.pack(side='left', expand=True, fill='x')
        
        self.total_pct_label = ttk.Label(btns, text="Total: 0.0%")
        self.total_pct_label.pack(side='left', padx=(0, 10))
        
        self.save_btn = ttk.Button(btns, text="Save Budgets", command=self.save_budgets)
        self.save_btn.pack(side='left', padx=5)
        
        # Update button visibility based on category type
        self._update_button_visibility()

        self._create_budget_sliders()

    def _on_category_type_changed(self):
        """Handle category type change (Expense/Income)"""
        self._create_budget_sliders()
        self._update_button_visibility()

    def _update_button_visibility(self):
        cat_type = self.cat_type_var.get()
        if cat_type == 'Expense':
            self.auto_assign_btn.pack(side='left', padx=(0, 5))
            self.normalize_btn.pack(side='left', padx=(0, 10))
            self.total_pct_label.pack(side='left', padx=(0, 10))
            self.save_btn.pack(side='left', padx=5)
        else:
            self.auto_assign_btn.pack_forget()
            self.normalize_btn.pack_forget()
            self.total_pct_label.pack_forget()
            self.save_btn.pack_forget()

    def _create_budget_sliders(self):
        for w in self.sliders_frame.winfo_children():
            w.destroy()
        self.budget_sliders = {}

        cat_type = self.cat_type_var.get()
        categories = self.state.categories.get(cat_type, [])
        saved = self.state.budget_settings.get('category_budgets', {}).get(cat_type, {}).copy()

        if not saved:
            if categories:
                even = 100.0 / len(categories) if cat_type == 'Expense' else 0.0
                for c in categories:
                    saved[c] = even
        else:
            for c in categories:
                if c not in saved:
                    saved[c] = 0.0

        self.remove_cat_combo['values'] = categories

        for c in categories:
            frame = ttk.Frame(self.sliders_frame)
            frame.pack(fill='x', pady=2)

            if cat_type == 'Expense':
                ttk.Label(frame, text=c, width=15).pack(side='left')
                var = tk.DoubleVar(value=float(saved.get(c, 0)))
                slider = ttk.Scale(frame, from_=0, to=100, orient='horizontal', variable=var,
                                command=lambda v, cat=c: self._on_slider_change(cat, float(v)))
                slider.pack(side='left', fill='x', expand=True, padx=5)
                label = ttk.Label(frame, text=f"{var.get():.1f}%", width=7)
                label.pack(side='left')
                amount_label = ttk.Label(frame, text="€0.00", width=12)
                amount_label.pack(side='left')
                self.budget_sliders[c] = {'var': var, 'slider': slider, 'label': label, 'amount_label': amount_label}
            else:
                # For income categories, use a single label with proper padding
                ttk.Label(frame, text=c, width=50, anchor='w').pack(side='left', padx=5)
                self.budget_sliders[c] = {'var': tk.DoubleVar(value=0), 'slider': None, 'label': None, 'amount_label': None}

        self._update_monetary_labels()
        self._update_total_percentage_label()

    def _on_slider_change(self, changed_category, new_value):
        if self._slider_lock:
            return
        self._slider_lock = True
        old_value = self.budget_sliders[changed_category]['var'].get()
        self.budget_sliders[changed_category]['var'].set(new_value)
        self.budget_sliders[changed_category]['label'].config(text=f"{new_value:.1f}%")
        self._adjust_other_sliders(changed_category, new_value, old_value)
        self._slider_lock = False
        self._update_monetary_labels()
        self._update_total_percentage_label()

    def _adjust_other_sliders(self, changed_category, new_value, old_value):
        delta = new_value - old_value
        others = {k: v for k, v in self.budget_sliders.items() if k != changed_category}
        other_total = sum(s['var'].get() for s in others.values())
        if other_total > 0:
            for cat, info in others.items():
                cur = info['var'].get()
                adj = delta * (cur / other_total)
                val = max(0, min(100, cur - adj))
                info['var'].set(val)
                info['label'].config(text=f"{val:.1f}%")
        else:
            if len(others) > 0:
                per = delta / len(others)
                for info in others.values():
                    val = max(0, min(100, info['var'].get() - per))
                    info['var'].set(val)
                    info['label'].config(text=f"{val:.1f}%")

    def _normalize_sliders(self):
        total = sum(s['var'].get() for s in self.budget_sliders.values())
        if total == 0:
            return
        if abs(total - 100.0) > 0.01:
            for info in self.budget_sliders.values():
                cur = info['var'].get()
                norm = (cur / total) * 100.0
                info['var'].set(norm)
                info['label'].config(text=f"{norm:.1f}%")
        self._update_monetary_labels()

    def _update_monetary_labels(self):
        if self.cat_type_var.get() == 'Expense':
            month = self.month_var.get()
            nav = compute_net_available_for_spending(self.state, month)
            for _, info in self.budget_sliders.items():
                if info['amount_label']:  # Only update if amount_label exists
                    pct = info['var'].get()
                    amount = (pct / 100.0) * nav
                    info['amount_label'].config(text=f"€{amount:.2f}")

    def _update_total_percentage_label(self):
        if self.cat_type_var.get() == 'Expense':
            total = sum(s['var'].get() for s in self.budget_sliders.values())
            self.total_pct_label.config(text=f"Total: {total:.1f}%")
        else:
            self.total_pct_label.config(text="")

    def add_category(self):
        cat_type = self.cat_type_var.get()
        new_cat = self.new_cat_entry.get().strip()
        if not new_cat:
            messagebox.showerror("Error", "Category name cannot be empty.")
            return
        if new_cat.lower() in [c.lower() for c in self.state.categories[cat_type]]:
            messagebox.showwarning("Warning", "This category already exists.")
            return
        self.state.categories[cat_type].append(new_cat)
        self.state.categories[cat_type].sort()
        self.state.save()
        self._create_budget_sliders()
        self.new_cat_entry.delete(0, tk.END)

    def remove_category(self):
        cat_type = self.cat_type_var.get()
        cat = self.remove_cat_combo.get()
        if not cat:
            messagebox.showwarning("Warning", "Please select a category to delete.")
            return
        if cat.lower() == "other":
            messagebox.showerror("Error", "Cannot delete the 'Other' category.")
            return
        if not messagebox.askyesno("Confirm", f"Delete '{cat}'? Existing transactions won't be changed."):
            return
        self.state.categories[cat_type].remove(cat)
        budgets = self.state.budget_settings['category_budgets'].get(cat_type, {})
        if cat in budgets:
            del budgets[cat]
        self.state.save()
        self._create_budget_sliders()

    def save_budgets(self):
        cat_type = self.cat_type_var.get()
        if cat_type not in self.state.budget_settings['category_budgets']:
            self.state.budget_settings['category_budgets'][cat_type] = {}
        for cat, info in self.budget_sliders.items():
            self.state.budget_settings['category_budgets'][cat_type][cat] = float(info['var'].get())
        self.state.save()
        self._create_budget_sliders()
        messagebox.showinfo("Success", "Category budgets have been saved.")

    def auto_assign(self):
        cat_type = self.cat_type_var.get()
        categories = list(self.budget_sliders.keys())
        month = self.month_var.get()
        percentages, msg, overspent = auto_assign_percentages(self.state, month, cat_type, categories)
        if not percentages:
            if msg:
                messagebox.showinfo("Info", msg)
            return
        for cat, pct in percentages.items():
            if cat in self.budget_sliders:
                self.budget_sliders[cat]['var'].set(pct)
                self.budget_sliders[cat]['label'].config(text=f"{pct:.1f}%")
        self._update_monetary_labels()
        self._update_total_percentage_label()
        if overspent:
            messagebox.showwarning("Overspent", msg)
        else:
            messagebox.showinfo("Remaining Budget", msg)"""
finance_tracker/ui/tabs/view_transactions_tab.py

Tab for viewing, filtering, modifying, and deleting transactions.
"""

import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime
from ...services.budget_calculator import get_active_fixed_costs, get_active_monthly_income

class ViewTransactionsTab:
    def __init__(self, notebook, state, on_data_changed):
        self.state = state
        self.on_data_changed = on_data_changed

        frame = ttk.Frame(notebook, padding="20")
        notebook.add(frame, text="View Transactions")
        self.frame = frame

        filter_frame = ttk.Frame(frame)
        filter_frame.pack(fill='x', pady=10)

        ttk.Label(filter_frame, text="Filter by month:").pack(side='left', padx=5)
        self.month_filter = ttk.Entry(filter_frame, width=15)
        self.month_filter.insert(0, datetime.now().strftime("%Y-%m"))
        self.month_filter.pack(side='left', padx=5)
        ttk.Button(filter_frame, text="Refresh", command=self.refresh).pack(side='left', padx=10)

        tree_frame = ttk.Frame(frame)
        tree_frame.pack(fill='both', expand=True, pady=10)

        columns = ('ID', 'Date', 'Type', 'Amount', 'Category', 'Description')
        self.transaction_tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=15)
        for col in columns:
            self.transaction_tree.heading(col, text=col)
            width = 120
            if col == 'Amount': width = 100
            if col == 'Description': width = 250
            if col == 'Type': width = 80
            self.transaction_tree.column(col, width=width, anchor='w')

        self.transaction_tree.column('ID', width=0, stretch=tk.NO)
        self.transaction_tree.tag_configure('expense', foreground='red')
        self.transaction_tree.tag_configure('income', foreground='green')
        self.transaction_tree.pack(side='left', fill='both', expand=True)

        scrollbar = ttk.Scrollbar(tree_frame, orient='vertical', command=self.transaction_tree.yview)
        scrollbar.pack(side='right', fill='y')
        self.transaction_tree.configure(yscrollcommand=scrollbar.set)

        button_frame = ttk.Frame(frame)
        button_frame.pack(fill='x', pady=5)
        spacer = ttk.Frame(button_frame)
        spacer.pack(side='left', expand=True, fill='x')
        ttk.Button(button_frame, text="Modify Selected", command=self.open_modify_window).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Delete Selected", command=self.delete_transaction).pack(side='left')

        self.summary_label = ttk.Label(frame, text="", font=('Arial', 10, 'bold'))
        self.summary_label.pack(pady=10, fill='x')

        self.refresh()

    def refresh(self):
        for item in self.transaction_tree.get_children():
            self.transaction_tree.delete(item)
        filter_month = self.month_filter.get()
        all_transactions = []
        for e in self.state.expenses:
            if e['date'].startswith(filter_month):
                all_transactions.append({**e, 'type': 'Expense'})
        for i in self.state.incomes:
            if i['date'].startswith(filter_month):
                all_transactions.append({**i, 'type': 'Income'})
        all_transactions.sort(key=lambda x: x['date'])

        for trans in all_transactions:
            tag = 'expense' if trans['type'] == 'Expense' else 'income'
            trans_id = trans.get('id', '')
            self.transaction_tree.insert('', 'end', values=(
                trans_id, trans['date'], trans['type'], f"€{trans['amount']:.2f}",
                trans['category'], trans['description']), tags=(tag,))
        self.update_summary()

    def update_summary(self):
        fm = self.month_filter.get()
        base_income = get_active_monthly_income(self.state, fm)
        total_flex_income = sum(i['amount'] for i in self.state.incomes if i['date'].startswith(fm))
        total_income = base_income + total_flex_income

        total_flex_expenses = sum(e['amount'] for e in self.state.expenses if e['date'].startswith(fm))
        # Get fixed costs active in this specific month
        total_fixed_costs = sum(fc['amount'] for fc in get_active_fixed_costs(self.state, fm))
        total_expenses = total_flex_expenses + total_fixed_costs
        net = total_income - total_expenses

        self.summary_label.config(text=(f"Total Income: €{total_income:.2f}  |  "
                                        f"Total Expenses: €{total_expenses:.2f}  |  "
                                        f"Flexible Costs Incurred: €{total_flex_expenses:.2f}  |  "
                                        f"Net: €{net:.2f}"))

    def delete_transaction(self):
        selected = self.transaction_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a transaction to delete.")
            return
        if not messagebox.askyesno("Confirm", "Are you sure you want to delete the selected transaction?"):
            return

        v = self.transaction_tree.item(selected[0])['values']
        trans_id = v[0]
        trans_type = v[2]
        if trans_id:
            ok = self.state.delete_transaction_by_id(trans_type, trans_id)
            if not ok:
                messagebox.showerror("Error", "Could not delete the transaction.")
        else:
            # Legacy no-id fallback
            date_str, _, amount_str, category, desc = v[1:]
            target = self.state.expenses if trans_type == "Expense" else self.state.incomes
            try:
                target.remove({
                    'date': date_str,
                    'amount': float(amount_str.replace('€', '')),
                    'category': category,
                    'description': desc
                })
                self.state.save()
            except ValueError:
                messagebox.showerror("Error", "Could not delete the transaction (fallback failed).")
                return
        self.on_data_changed()

    def open_modify_window(self):
        selected = self.transaction_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a transaction to modify.")
            return
        values = self.transaction_tree.item(selected[0])['values']
        trans_id = values[0]

        original = None
        original_list_name = None
        for t in self.state.expenses:
            if t.get('id') == trans_id:
                original = t
                original_list_name = "Expense"
                break
        if not original:
            for t in self.state.incomes:
                if t.get('id') == trans_id:
                    original = t
                    original_list_name = "Income"
                    break
        if not original:
            messagebox.showerror("Error", "Could not find the selected transaction in the data.")
            return

        win = tk.Toplevel(self.frame)
        win.title("Modify Transaction")
        win.transient(self.frame)
        win.grab_set()

        win.bind('<Escape>', lambda e: win.destroy())

        form = ttk.Frame(win, padding="20")
        form.pack(fill='both', expand=True)

        ttk.Label(form, text="Transaction Type:").grid(row=0, column=0, sticky='w', pady=10)
        mod_type_var = tk.StringVar(value=original_list_name)
        type_frame = ttk.Frame(form)
        type_frame.grid(row=0, column=1, sticky='w', pady=5)

        mod_category_var = tk.StringVar(value=original.get('category', ''))
        mod_category_combo = ttk.Combobox(form, textvariable=mod_category_var, width=28, state='readonly')

        def update_mod_cats():
            cats = self.state.categories.get(mod_type_var.get(), [])
            mod_category_combo.config(values=cats)
            if mod_category_var.get() in cats:
                mod_category_combo.set(mod_category_var.get())
            else:
                mod_category_combo.set(cats[0] if cats else "")

        ttk.Radiobutton(type_frame, text="Expense", variable=mod_type_var, value="Expense",
                        command=update_mod_cats).pack(side='left', padx=5)
        ttk.Radiobutton(type_frame, text="Income", variable=mod_type_var, value="Income",
                        command=update_mod_cats).pack(side='left', padx=5)

        ttk.Label(form, text="Date:").grid(row=1, column=0, sticky='w', pady=5)
        mod_date_entry = ttk.Entry(form, width=30)
        mod_date_entry.insert(0, original.get('date', ''))
        mod_date_entry.grid(row=1, column=1, pady=5, sticky='w')

        ttk.Label(form, text="Amount:").grid(row=2, column=0, sticky='w', pady=5)
        mod_amount_entry = ttk.Entry(form, width=30)
        mod_amount_entry.insert(0, original.get('amount', ''))
        mod_amount_entry.grid(row=2, column=1, pady=5, sticky='w')

        ttk.Label(form, text="Category:").grid(row=3, column=0, sticky='w', pady=5)
        mod_category_combo.grid(row=3, column=1, pady=5, sticky='w')
        update_mod_cats()

        ttk.Label(form, text="Description:").grid(row=4, column=0, sticky='w', pady=5)
        mod_desc_entry = ttk.Entry(form, width=30)
        mod_desc_entry.insert(0, original.get('description', ''))
        mod_desc_entry.grid(row=4, column=1, pady=5, sticky='w')

        def save_changes():
            try:
                new_date = mod_date_entry.get()
                datetime.strptime(new_date, "%Y-%m-%d")
                new_amount = float(mod_amount_entry.get())
                new_cat = mod_category_var.get()
                new_desc = mod_desc_entry.get()
                new_type = mod_type_var.get()
                if not new_cat:
                    messagebox.showerror("Error", "Please select a category.", parent=win)
                    return

                # Update existing
                original['date'] = new_date
                original['amount'] = new_amount
                original['category'] = new_cat
                original['description'] = new_desc

                if new_type != original_list_name:
                    source = self.state.expenses if original_list_name == "Expense" else self.state.incomes
                    source.remove(original)
                    (self.state.expenses if new_type == "Expense" else self.state.incomes).append(original)

                self.state.save()
                self.on_data_changed()
                win.destroy()
            except ValueError:
                messagebox.showerror("Error", "Invalid amount or date format (YYYY-MM-DD).", parent=win)

        ttk.Button(form, text="Save Changes", command=save_changes).grid(row=5, column=1, pady=20, sticky='w')"""
finance_tracker/ui/tabs/projection_tab.py

Tab for projecting future financial state based on current trends.
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from datetime import datetime
from ...services.projection_service import projection_text

class ProjectionTab:
    def __init__(self, notebook, state):
        self.state = state

        main = ttk.Frame(notebook, padding="10")
        notebook.add(main, text="Projection")
        main.rowconfigure(1, weight=1)
        main.columnconfigure(0, weight=1)

        controls = ttk.LabelFrame(main, text="Projection Options", padding="10")
        controls.grid(row=0, column=0, sticky='ew', pady=5)
        ttk.Label(controls, text="Number of months to project:").pack(side='left', padx=5)
        self.months_entry = ttk.Entry(controls, width=10)
        self.months_entry.insert(0, "12")
        self.months_entry.pack(side='left', padx=5)
        ttk.Button(controls, text="Generate Projection", command=self.generate).pack(side='left', padx=20)
        ttk.Button(controls, text="Export Projection", command=self.export).pack(side='left', padx=5)

        self.text = tk.Text(main, height=20, width=90, font=('Courier New', 9))
        self.text.grid(row=1, column=0, sticky='nsew', pady=10)

    def generate(self):
        try:
            months = int(self.months_entry.get())
            if months <= 0:
                messagebox.showerror("Error", "Number of months must be positive.")
                return
        except ValueError:
            messagebox.showerror("Error", "Invalid number of months.")
            return
        report = projection_text(self.state, months)
        self.text.delete("1.0", tk.END)
        self.text.insert("1.0", report)

    def export(self):
        content = self.text.get("1.0", tk.END).strip()
        if not content:
            messagebox.showwarning("Warning", "Please generate a projection before exporting.")
            return
        today = datetime.now().strftime("%Y-%m-%d")
        default_filename = f"bank_projection_{today}.txt"
        path = filedialog.asksaveasfilename(
            initialfile=default_filename,
            defaultextension=".txt",
            filetypes=[("Text Documents", "*.txt"), ("All Files", "*.*")]
        )
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(content)
            messagebox.showinfo("Success", f"Projection successfully exported to:\n{path}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export projection.\nError: {e}")"""
finance_tracker/ui/tabs/goals_tab.py

Tab for creating and managing savings goals.
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from datetime import datetime, date
from ...services.goals_service import (
    calculate_goal_progress, 
    estimate_completion_date,
    calculate_monthly_savings,
    generate_goals_report,
    calculate_all_goals_summary,
    get_total_savings_available,
    get_total_allocated,
    get_unallocated_savings,
    validate_allocation,
    auto_distribute_savings
)

class GoalsTab:
    def __init__(self, notebook, state):
        self.state = state
        
        main = ttk.Frame(notebook, padding="10")
        notebook.add(main, text="Savings Goals")
        main.rowconfigure(2, weight=1)
        main.columnconfigure(0, weight=1)
        
        # Savings overview section
        savings_frame = ttk.LabelFrame(main, text="Savings Overview", padding="10")
        savings_frame.grid(row=0, column=0, sticky='ew', pady=(0, 5))
        
        self.savings_overview_label = ttk.Label(savings_frame, text="", font=('Arial', 11, 'bold'))
        self.savings_overview_label.pack()
        
        info_label = ttk.Label(savings_frame, 
                              text="Note: Savings balance is managed in the Budget Report tab. Here you allocate existing savings to goals.",
                              font=('Arial', 8, 'italic'), foreground='gray')
        info_label.pack(pady=(5, 0))
        
        # Summary section
        summary_frame = ttk.LabelFrame(main, text="Goals Summary", padding="10")
        summary_frame.grid(row=1, column=0, sticky='ew', pady=(0, 10))
        
        self.summary_label = ttk.Label(summary_frame, text="", font=('Arial', 10))
        self.summary_label.pack()
        
        # Main content area
        content = ttk.Frame(main)
        content.grid(row=2, column=0, sticky='nsew')
        content.rowconfigure(0, weight=1)
        content.columnconfigure(0, weight=2)
        content.columnconfigure(1, weight=1)
        
        # Left side - Goals list with progress bars
        left_frame = ttk.LabelFrame(content, text="Your Goals", padding="10")
        left_frame.grid(row=0, column=0, sticky='nsew', padx=(0, 5))
        left_frame.rowconfigure(0, weight=1)
        left_frame.columnconfigure(0, weight=1)
        
        # Goals canvas with scrollbar
        goals_canvas_frame = ttk.Frame(left_frame)
        goals_canvas_frame.grid(row=0, column=0, sticky='nsew')
        goals_canvas_frame.rowconfigure(0, weight=1)
        goals_canvas_frame.columnconfigure(0, weight=1)
        
        self.goals_canvas = tk.Canvas(goals_canvas_frame, highlightthickness=0)
        goals_scrollbar = ttk.Scrollbar(goals_canvas_frame, orient='vertical', command=self.goals_canvas.yview)
        self.goals_canvas.configure(yscrollcommand=goals_scrollbar.set)
        
        self.goals_canvas.grid(row=0, column=0, sticky='nsew')
        goals_scrollbar.grid(row=0, column=1, sticky='ns')
        
        self.goals_container = ttk.Frame(self.goals_canvas)
        self.goals_canvas_window = self.goals_canvas.create_window((0, 0), window=self.goals_container, anchor='nw')
        
        self.goals_container.bind('<Configure>', self._on_goals_frame_configure)
        self.goals_canvas.bind('<Configure>', self._on_canvas_configure)

        # Mouse wheel scrolling
        self.goals_canvas.bind_all("<MouseWheel>", self._on_mouse_wheel)
        self.goals_canvas.bind_all("<Button-4>", self._on_mouse_wheel)
        self.goals_canvas.bind_all("<Button-5>", self._on_mouse_wheel)
        
        # Buttons below goals list
        goals_buttons = ttk.Frame(left_frame)
        goals_buttons.grid(row=1, column=0, sticky='ew', pady=(10, 0))
        ttk.Button(goals_buttons, text="Refresh", command=self.refresh_goals).pack(side='left', padx=5)
        ttk.Button(goals_buttons, text="Auto-Distribute", command=self.auto_distribute).pack(side='left', padx=5)
        ttk.Button(goals_buttons, text="Generate Report", command=self.show_report).pack(side='left', padx=5)
        ttk.Button(goals_buttons, text="Export Report", command=self.export_report).pack(side='left', padx=5)
        
        # Right side - Add/Edit goal form
        right_frame = ttk.LabelFrame(content, text="Add/Edit Goal", padding="10")
        right_frame.grid(row=0, column=1, sticky='nsew', padx=(5, 0))
        
        form = ttk.Frame(right_frame)
        form.pack(fill='both', expand=True)
        
        row = 0
        ttk.Label(form, text="Goal Name:").grid(row=row, column=0, sticky='w', pady=5)
        self.goal_name_entry = ttk.Entry(form, width=25)
        self.goal_name_entry.grid(row=row, column=1, pady=5, sticky='ew')
        
        row += 1
        ttk.Label(form, text="Description:").grid(row=row, column=0, sticky='w', pady=5)
        self.goal_desc_entry = ttk.Entry(form, width=25)
        self.goal_desc_entry.grid(row=row, column=1, pady=5, sticky='ew')
        
        row += 1
        ttk.Label(form, text="Target Amount (€):").grid(row=row, column=0, sticky='w', pady=5)
        self.goal_target_entry = ttk.Entry(form, width=25)
        self.goal_target_entry.grid(row=row, column=1, pady=5, sticky='ew')
        
        row += 1
        ttk.Label(form, text="Priority:").grid(row=row, column=0, sticky='w', pady=5)
        self.goal_priority_var = tk.StringVar(value="Medium")
        priority_frame = ttk.Frame(form)
        priority_frame.grid(row=row, column=1, sticky='w', pady=5)
        for priority in ["High", "Medium", "Low"]:
            ttk.Radiobutton(priority_frame, text=priority, variable=self.goal_priority_var, 
                           value=priority).pack(side='left', padx=2)
        
        row += 1
        ttk.Label(form, text="Target Date (YYYY-MM-DD):").grid(row=row, column=0, sticky='w', pady=5)
        self.goal_target_date_entry = ttk.Entry(form, width=25)
        self.goal_target_date_entry.grid(row=row, column=1, pady=5, sticky='ew')
        
        row += 1
        ttk.Separator(form, orient='horizontal').grid(row=row, column=0, columnspan=2, sticky='ew', pady=10)
        
        row += 1
        buttons_frame = ttk.Frame(form)
        buttons_frame.grid(row=row, column=0, columnspan=2, pady=10)
        ttk.Button(buttons_frame, text="Add Goal", command=self.add_goal).pack(side='left', padx=5)
        ttk.Button(buttons_frame, text="Update Selected", command=self.update_goal).pack(side='left', padx=5)
        ttk.Button(buttons_frame, text="Clear Form", command=self.clear_form).pack(side='left', padx=5)
        
        # Selected goal tracking
        self.selected_goal_index = None
        
        # Initialize
        self.refresh_goals()
    
    def _on_mouse_wheel(self, event):
        """Handle mouse wheel scrolling"""
        # For Windows and MacOS
        if event.num == 5 or event.delta == -120:
            self.goals_canvas.yview_scroll(1, "units")
        if event.num == 4 or event.delta == 120:
            self.goals_canvas.yview_scroll(-1, "units")

    def _on_goals_frame_configure(self, event=None):
        """Update scrollregion when goals container changes"""
        self.goals_canvas.configure(scrollregion=self.goals_canvas.bbox('all'))
    
    def _on_canvas_configure(self, event):
        """Update the width of the canvas window to match the canvas"""
        self.goals_canvas.itemconfig(self.goals_canvas_window, width=event.width)
    
    def _bind_mouse_wheel(self, widget):
        """Recursively bind mouse wheel event to all children"""
        widget.bind("<MouseWheel>", self._on_mouse_wheel)
        widget.bind("<Button-4>", self._on_mouse_wheel)
        widget.bind("<Button-5>", self._on_mouse_wheel)
        for child in widget.winfo_children():
            self._bind_mouse_wheel(child)

    def refresh_goals(self):
        """Refresh the goals display"""
        # Clear existing widgets
        for widget in self.goals_container.winfo_children():
            widget.destroy()
        
        # Ensure goals list exists
        if 'savings_goals' not in self.state.budget_settings:
            self.state.budget_settings['savings_goals'] = []
        
        # Migrate old goals to new format if needed
        goals = self.state.budget_settings['savings_goals']
        for goal in goals:
            if 'allocated_amount' not in goal:
                # Migrate from old 'current_amount' to new 'allocated_amount'
                goal['allocated_amount'] = goal.get('current_amount', 0)
                if 'current_amount' in goal:
                    del goal['current_amount']
        
        if not goals:
            ttk.Label(self.goals_container, text="No goals yet. Create your first goal!", 
                     font=('Arial', 10, 'italic')).pack(pady=20)
        else:
            # Sort goals: active first (by priority), then completed
            active_goals = [g for g in goals if g.get('allocated_amount', 0) < g['target_amount']]
            completed_goals = [g for g in goals if g.get('allocated_amount', 0) >= g['target_amount']]
            
            priority_order = {'High': 0, 'Medium': 1, 'Low': 2}
            active_goals.sort(key=lambda g: priority_order.get(g.get('priority', 'Medium'), 1))
            
            sorted_goals = active_goals + completed_goals
            
            for goal in sorted_goals:
                original_index = goals.index(goal)
                self._create_goal_widget(original_index, goal)
        
        # Update summaries
        self._update_savings_overview()
        self._update_summary()
        
        # Update canvas
        self.goals_canvas.update_idletasks()
        self._on_goals_frame_configure()
    
    def _update_savings_overview(self):
        """Update the savings overview display"""
        total_savings = get_total_savings_available(self.state)
        total_allocated = get_total_allocated(self.state)
        unallocated = get_unallocated_savings(self.state)
        
        text = f"Total Savings: €{total_savings:,.2f}  |  Allocated: €{total_allocated:,.2f}  |  Unallocated: €{unallocated:,.2f}"
        
        self.savings_overview_label.config(text=text)
        
        if unallocated > 0:
            self.savings_overview_label.config(foreground='green')
        elif unallocated < 0:
            self.savings_overview_label.config(foreground='orange')
        else:
            self.savings_overview_label.config(foreground='red')
    
    def _create_goal_widget(self, index, goal):
        """Create a widget for a single goal"""
        progress = calculate_goal_progress(goal, goal.get('allocated_amount', 0))
        
        # Main goal frame
        goal_frame = ttk.Frame(self.goals_container, relief='solid', borderwidth=1)
        goal_frame.pack(fill='x', padx=5, pady=5)
        
        # Bind mouse wheel for scrolling
        self._bind_mouse_wheel(goal_frame)
        
        # Highlight if completed
        if progress['is_complete']:
            goal_frame.configure(style='Complete.TFrame')
        
        # Header
        header = ttk.Frame(goal_frame)
        header.pack(fill='x', padx=10, pady=(10, 5))
        
        # Goal name and category
        name_frame = ttk.Frame(header)
        name_frame.pack(side='left', fill='x', expand=True)
        
        name_label = ttk.Label(name_frame, text=goal['name'], font=('Arial', 11, 'bold'))
        name_label.pack(side='left')
        
        if goal.get('priority'):
            priority_colors = {'High': 'red', 'Medium': 'orange', 'Low': 'green'}
            priority_label = ttk.Label(header, text=goal['priority'], 
                                      foreground=priority_colors.get(goal['priority'], 'black'),
                                      font=('Arial', 9, 'bold'))
            priority_label.pack(side='right', padx=5)
        
        # Description
        if goal.get('description'):
            desc_label = ttk.Label(goal_frame, text=goal['description'], 
                                  font=('Arial', 9), foreground='gray')
            desc_label.pack(anchor='w', padx=10, pady=(0, 5))
        
        # Amounts
        amounts_frame = ttk.Frame(goal_frame)
        amounts_frame.pack(fill='x', padx=10, pady=5)
        
        allocated = goal.get('allocated_amount', 0)
        ttk.Label(amounts_frame, text=f"€{allocated:,.2f} / €{goal['target_amount']:,.2f}",
                 font=('Arial', 10, 'bold')).pack(side='left')
        ttk.Label(amounts_frame, text=f"  (€{progress['remaining']:,.2f} remaining)",
                 font=('Arial', 9), foreground='gray').pack(side='left')
        
        # Progress bar
        progress_frame = ttk.Frame(goal_frame)
        progress_frame.pack(fill='x', padx=10, pady=5)
        
        progress_bar = ttk.Progressbar(progress_frame, length=300, mode='determinate', 
                                      value=progress['progress_pct'])
        progress_bar.pack(side='left', fill='x', expand=True)
        
        progress_label = ttk.Label(progress_frame, text=f"{progress['progress_pct']:.1f}%", 
                                  font=('Arial', 9, 'bold'))
        progress_label.pack(side='left', padx=5)
        
        # Completion estimate
        if progress['is_complete']:
            complete_label = ttk.Label(goal_frame, text="✓ Goal Achieved!", 
                                      font=('Arial', 10, 'bold'), foreground='green')
            complete_label.pack(anchor='w', padx=10, pady=(0, 5))
            
            if goal.get('completion_date'):
                comp_date_label = ttk.Label(goal_frame, 
                                           text=f"Completed: {goal['completion_date']}",
                                           font=('Arial', 8), foreground='gray')
                comp_date_label.pack(anchor='w', padx=10, pady=(0, 5))
        else:
            # Target date only (no required amount in view)
            if goal.get('target_date'):
                target_date_frame = ttk.Frame(goal_frame)
                target_date_frame.pack(fill='x', padx=10, pady=(0, 5))
                
                ttk.Label(target_date_frame, text=f"Target Date: {goal['target_date']}", 
                          font=('Arial', 9, 'italic')).pack(side='left')

        # Buttons
        button_frame = ttk.Frame(goal_frame)
        button_frame.pack(fill='x', padx=10, pady=(5, 10))
        
        ttk.Button(button_frame, text="Edit", 
                  command=lambda i=index: self.select_goal(i)).pack(side='left', padx=2)
        ttk.Button(button_frame, text="Allocate Savings", 
                  command=lambda i=index: self.allocate_to_goal(i)).pack(side='left', padx=2)
        ttk.Button(button_frame, text="Delete", 
                  command=lambda i=index: self.delete_goal(i)).pack(side='left', padx=2)
        
        if progress['is_complete']:
            ttk.Button(button_frame, text="Archive", 
                      command=lambda i=index: self.archive_goal(i)).pack(side='left', padx=2)
    
    def _update_summary(self):
        """Update the summary label"""
        summary = calculate_all_goals_summary(self.state)
        
        text = (f"Total Goals: {summary['total_goals']} | "
                f"Active: {summary['active_goals']} | "
                f"Completed: {summary['completed_goals']} | "
                f"Total Target: €{summary['total_target']:,.2f} | "
                f"Overall Progress: {summary['overall_progress']:.1f}%")
        
        self.summary_label.config(text=text)
    
    def add_goal(self):
        """Add a new goal"""
        try:
            name = self.goal_name_entry.get().strip()
            if not name:
                messagebox.showerror("Error", "Please enter a goal name.")
                return
            
            target = float(self.goal_target_entry.get())
            if target <= 0:
                messagebox.showerror("Error", "Target amount must be positive.")
                return
            
            target_date_str = self.goal_target_date_entry.get().strip()
            if target_date_str:
                try:
                    datetime.strptime(target_date_str, '%Y-%m-%d')
                except ValueError:
                    messagebox.showerror("Error", "Invalid date format. Please use YYYY-MM-DD.")
                    return
            
            goal = {
                'name': name,
                'description': self.goal_desc_entry.get().strip(),
                'target_amount': target,
                'allocated_amount': 0.0,  # Start with 0 allocation
                'priority': self.goal_priority_var.get(),
                'target_date': target_date_str if target_date_str else None,
                'created_date': date.today().strftime('%Y-%m-%d'),
                'completion_date': None
            }
            
            if 'savings_goals' not in self.state.budget_settings:
                self.state.budget_settings['savings_goals'] = []
            
            self.state.budget_settings['savings_goals'].append(goal)
            self.state.save()
            
            self.clear_form()
            self.refresh_goals()
            messagebox.showinfo("Success", f"Goal '{name}' added successfully!\nNow allocate savings to this goal.")
            
        except ValueError:
            messagebox.showerror("Error", "Invalid number format in amount fields.")
    
    def select_goal(self, index):
        """Load a goal into the form for editing"""
        goals = self.state.budget_settings.get('savings_goals', [])
        if index >= len(goals):
            return
        
        goal = goals[index]
        self.selected_goal_index = index
        
        self.goal_name_entry.delete(0, tk.END)
        self.goal_name_entry.insert(0, goal['name'])
        
        self.goal_desc_entry.delete(0, tk.END)
        self.goal_desc_entry.insert(0, goal.get('description', ''))
        
        self.goal_target_entry.delete(0, tk.END)
        self.goal_target_entry.insert(0, str(goal['target_amount']))
        
        self.goal_priority_var.set(goal.get('priority', 'Medium'))

        self.goal_target_date_entry.delete(0, tk.END)
        self.goal_target_date_entry.insert(0, goal.get('target_date', ''))
    
    def update_goal(self):
        """Update the selected goal"""
        if self.selected_goal_index is None:
            messagebox.showwarning("Warning", "Please select a goal to update.")
            return
        
        try:
            name = self.goal_name_entry.get().strip()
            if not name:
                messagebox.showerror("Error", "Please enter a goal name.")
                return
            
            target = float(self.goal_target_entry.get())
            if target <= 0:
                messagebox.showerror("Error", "Target amount must be positive.")
                return
            
            
            target_date_str = self.goal_target_date_entry.get().strip()
            if target_date_str:
                try:
                    datetime.strptime(target_date_str, '%Y-%m-%d')
                except ValueError:
                    messagebox.showerror("Error", "Invalid date format. Please use YYYY-MM-DD.")
                    return

            goals = self.state.budget_settings['savings_goals']
            goal = goals[self.selected_goal_index]
            
            # Check if goal was just completed
            was_complete = goal.get('allocated_amount', 0) >= goal['target_amount']
            is_complete = goal.get('allocated_amount', 0) >= target
            
            goal['name'] = name
            goal['description'] = self.goal_desc_entry.get().strip()
            goal['target_amount'] = target
            goal['priority'] = self.goal_priority_var.get()
            goal['target_date'] = target_date_str if target_date_str else None
            
            if is_complete and not was_complete:
                goal['completion_date'] = date.today().strftime('%Y-%m-%d')
            elif not is_complete:
                goal['completion_date'] = None
            
            self.state.save()
            self.clear_form()
            self.refresh_goals()
            messagebox.showinfo("Success", "Goal updated successfully!")
            
        except ValueError:
            messagebox.showerror("Error", "Invalid number format in amount fields.")
    
    def delete_goal(self, index):
        """Delete a goal"""
        goals = self.state.budget_settings.get('savings_goals', [])
        if index >= len(goals):
            return
        
        goal = goals[index]
        allocated = goal.get('allocated_amount', 0)
        
        msg = f"Are you sure you want to delete the goal '{goal['name']}'?"
        if allocated > 0:
            msg += f"\n\n€{allocated:.2f} is currently allocated to this goal."
            msg += "\nThis amount will be returned to your unallocated savings."
        
        if not messagebox.askyesno("Confirm Delete", msg):
            return
        
        del goals[index]
        self.state.save()
        self.clear_form()
        self.refresh_goals()
    
    def archive_goal(self, index):
        """Archive a completed goal"""
        goals = self.state.budget_settings.get('savings_goals', [])
        if index >= len(goals):
            return
        
        goal = goals[index]
        
        msg = f"Archive '{goal['name']}'?\n\n"
        msg += f"This will remove it from the active list.\n"
        msg += f"The €{goal.get('allocated_amount', 0):.2f} allocated to this goal will remain in your savings."
        
        if not messagebox.askyesno("Archive Goal", msg):
            return
        
        # Could implement an archived goals list here
        del goals[index]
        self.state.save()
        self.refresh_goals()
        messagebox.showinfo("Archived", f"Goal '{goal['name']}' has been archived.")
    
    def allocate_to_goal(self, index):
        """Allocate savings to a specific goal"""
        goals = self.state.budget_settings.get('savings_goals', [])
        if index >= len(goals):
            return
        
        goal = goals[index]
        current_allocation = goal.get('allocated_amount', 0)
    
        # Create dialog
        dialog = tk.Toplevel(self.goals_container)
        dialog.title(f"Allocate Savings to {goal['name']}")
        dialog.geometry("450x450")
        dialog.transient(self.goals_container)
        dialog.grab_set()
    
        # Bind ESC to close dialog
        dialog.bind('<Escape>', lambda e: dialog.destroy())
    
        ttk.Label(dialog, text=f"Allocate savings to: {goal['name']}", 
                 font=('Arial', 11, 'bold')).pack(pady=10)
        
        # Current status
        info_frame = ttk.LabelFrame(dialog, text="Current Status", padding=10)
        info_frame.pack(fill='x', padx=20, pady=10)
        
        ttk.Label(info_frame, text=f"Target Amount: €{goal['target_amount']:,.2f}").pack(anchor='w')
        ttk.Label(info_frame, text=f"Currently Allocated: €{current_allocation:,.2f}").pack(anchor='w')
        ttk.Label(info_frame, text=f"Still Needed: €{goal['target_amount'] - current_allocation:,.2f}").pack(anchor='w')
        
        ttk.Separator(info_frame, orient='horizontal').pack(fill='x', pady=5)
        
        total_savings = get_total_savings_available(self.state)
        unallocated = get_unallocated_savings(self.state)
        
        ttk.Label(info_frame, text=f"Total Savings Balance: €{total_savings:,.2f}").pack(anchor='w')
        ttk.Label(info_frame, text=f"Unallocated Savings: €{unallocated:,.2f}", 
                 foreground='blue' if unallocated > 0 else 'red').pack(anchor='w')
        
        # Allocation input
        allocation_frame = ttk.Frame(dialog)
        allocation_frame.pack(pady=20)
        
        ttk.Label(allocation_frame, text="New Total Allocation (€):").grid(row=0, column=0, padx=5, pady=5)
        allocation_entry = ttk.Entry(allocation_frame, width=15)
        allocation_entry.insert(0, str(current_allocation))
        allocation_entry.grid(row=0, column=1, padx=5, pady=5)
        allocation_entry.focus()
        allocation_entry.select_range(0, tk.END)
        
        # Quick allocation buttons
        quick_frame = ttk.LabelFrame(dialog, text="Quick Allocate", padding=5)
        quick_frame.pack(fill='x', padx=20, pady=5)
        
        def set_allocation(amount):
            allocation_entry.delete(0, tk.END)
            allocation_entry.insert(0, f"{amount:.2f}")
        
        button_row = ttk.Frame(quick_frame)
        button_row.pack()
        
        ttk.Button(button_row, text="Max Available", 
                  command=lambda: set_allocation(current_allocation + unallocated)).pack(side='left', padx=2)
        ttk.Button(button_row, text="Complete Goal", 
                  command=lambda: set_allocation(goal['target_amount'])).pack(side='left', padx=2)
        ttk.Button(button_row, text="Clear (€0)", 
                  command=lambda: set_allocation(0)).pack(side='left', padx=2)
        
        status_label = ttk.Label(dialog, text="", foreground='red')
        status_label.pack(pady=5)
        
        def validate_and_save():
            try:
                new_allocation = float(allocation_entry.get())
                
                is_valid, error_msg, available = validate_allocation(self.state, index, new_allocation)
                
                if not is_valid:
                    status_label.config(text=error_msg)
                    return
                
                old_allocation = goal.get('allocated_amount', 0)
                goal['allocated_amount'] = new_allocation
                
                # Check if goal just completed
                was_complete = old_allocation >= goal['target_amount']
                is_complete = new_allocation >= goal['target_amount']
                
                if is_complete and not was_complete:
                    goal['completion_date'] = date.today().strftime('%Y-%m-%d')
                    messagebox.showinfo("Goal Achieved!", 
                                      f"Congratulations! You've reached your goal: {goal['name']}!",
                                      parent=dialog)
                elif not is_complete and was_complete:
                    goal['completion_date'] = None
                
                self.state.save()
                dialog.destroy()
                self.refresh_goals()
                
            except ValueError:
                status_label.config(text="Invalid amount.")
        
        button_frame = ttk.Frame(dialog)
        button_frame.pack(pady=10)
        ttk.Button(button_frame, text="Save", command=validate_and_save).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='left', padx=5)
        
        # Bind Enter key
        allocation_entry.bind('<Return>', lambda e: validate_and_save())
    
    def auto_distribute(self):
        """Automatically distribute unallocated savings across goals"""
        unallocated = get_unallocated_savings(self.state)
        
        if unallocated <= 0:
            messagebox.showinfo("Info", "No unallocated savings to distribute.")
            return
        
        if not messagebox.askyesno("Auto-Distribute", 
                                   f"Automatically distribute €{unallocated:.2f} across your goals?\n\n"
                                   "This will prioritize high-priority goals and try to complete goals in order."):
            return
        
        success, message = auto_distribute_savings(self.state)
        
        if success:
            self.state.save()
            self.refresh_goals()
            messagebox.showinfo("Success", message)
        else:
            messagebox.showwarning("Cannot Distribute", message)
    
    def clear_form(self):
        """Clear the form fields"""
        self.goal_name_entry.delete(0, tk.END)
        self.goal_desc_entry.delete(0, tk.END)
        self.goal_target_entry.delete(0, tk.END)
        self.goal_target_date_entry.delete(0, tk.END)
        self.goal_priority_var.set("Medium")
        self.selected_goal_index = None
    
    def show_report(self):
        """Show goals report in a new window"""
        report_text = generate_goals_report(self.state)
        
        report_win = tk.Toplevel(self.goals_container)
        report_win.title("Savings Goals Report")
        report_win.geometry("900x700")
        
        main_frame = ttk.Frame(report_win, padding=10)
        main_frame.pack(fill='both', expand=True)
        
        text_widget = tk.Text(main_frame, wrap='word', font=('Courier New', 9))
        scrollbar = ttk.Scrollbar(main_frame, orient='vertical', command=text_widget.yview)
        text_widget.configure(yscrollcommand=scrollbar.set)
        
        scrollbar.pack(side='right', fill='y')
        text_widget.pack(side='left', fill='both', expand=True)
        
        text_widget.insert('1.0', report_text)
        text_widget.config(state='disabled')
        
        button_frame = ttk.Frame(report_win, padding=10)
        button_frame.pack(fill='x')
        ttk.Button(button_frame, text="Export", 
                  command=lambda: self.export_report(report_text)).pack(side='right')
        ttk.Button(button_frame, text="Close", 
                  command=report_win.destroy).pack(side='right', padx=5)
    
    def export_report(self, report_text=None):
        """Export goals report to file"""
        if report_text is None:
            report_text = generate_goals_report(self.state)
        
        today = datetime.now().strftime("%Y-%m-%d")
        default_filename = f"savings_goals_report_{today}.txt"
        
        path = filedialog.asksaveasfilename(
            initialfile=default_filename,
            defaultextension=".txt",
            filetypes=[("Text Documents", "*.txt"), ("All Files", "*.*")]
        )
        
        if not path:
            return
        
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(report_text)
            messagebox.showinfo("Success", f"Report successfully exported to:\n{path}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export report.\nError: {e}")"""
finance_tracker/ui/style.py

Defines and applies custom Tkinter styles for the application.
"""

from tkinter import ttk

def apply_styles():
    style = ttk.Style()
    style.configure("Treeview.Heading", font=('Arial', 10, 'bold'))
    style.configure("TLabel", font=('Arial', 10))
    style.configure("TButton", font=('Arial', 10))
    style.configure("TRadiobutton", font=('Arial', 10))
    style.configure("Help.TButton", font=('Arial', 12, 'bold'))
    
    # Style for completed goals
    style.configure("Complete.TFrame", background='#e8f5e9')"""
finance_tracker/ui/help_window.py

Displays the help and instructions window for the application.
"""

import tkinter as tk
from tkinter import ttk

def show_help(root):
    help_win = tk.Toplevel(root)
    help_win.title("Help & Instructions")
    help_win.geometry("800x600")
    help_win.minsize(600, 400)
    
    # Bind ESC to close window
    help_win.bind('<Escape>', lambda e: help_win.destroy())

    main_frame = ttk.Frame(help_win, padding=10)
    main_frame.pack(fill='both', expand=True)

    text_frame = ttk.Frame(main_frame)
    text_frame.pack(fill='both', expand=True)

    help_text_widget = tk.Text(text_frame, wrap='word', font=('Arial', 10), spacing3=5)
    scrollbar = ttk.Scrollbar(text_frame, orient='vertical', command=help_text_widget.yview)
    help_text_widget.configure(yscrollcommand=scrollbar.set)
    scrollbar.pack(side='right', fill='y')
    help_text_widget.pack(side='left', fill='both', expand=True)

    help_text_widget.tag_configure('h1', font=('Arial', 16, 'bold'), spacing1=10)
    help_text_widget.tag_configure('h2', font=('Arial', 12, 'bold'), spacing1=10)
    help_text_widget.tag_configure('bold', font=('Arial', 10, 'bold'))
    help_text_widget.tag_configure('italic', font=('Arial', 10, 'italic'))

    content = [
        ("Core Concepts", "h1"),
        ("\nTo use this tracker effectively, it's important to understand these key ideas:", "italic"),

        ("\n• Assets (Your Accounts):", "bold"),
        ("\n The main ones are 'Bank', 'Wallet', 'Savings', 'Investments', and 'Money Lent'. Balances are in 'Budget Report'.", "none"),

        ("\n• Transactions (Income/Expense):", "bold"),
        ("\n Money entering/leaving your finances.", "none"),

        ("\n• Savings Goals:", "bold"),
        ("\n Allocate your existing savings across different objectives. The Savings Balance (set in Budget Report) is the source - you distribute it to goals.\n", "none"),

        ("\nHow To Use Each Tab", "h1"),

        ("\nAdd Transaction Tab", "h2"),
        ("\nLog income or expense with date, amount, category, description.", "none"),

        ("\nView Transactions Tab", "h2"),
        ("\nFilter by month, modify/delete, see monthly summary.", "none"),

        ("\nCharts Tab", "h2"),
        ("\nPie chart or historical bar chart. Optional fixed/base income, budget overlays. Click bar chart to toggle views.", "none"),

        ("\nBudget Report Tab", "h2"),
        ("\nBalances, fixed costs, daily budget report. UPDATE YOUR SAVINGS BALANCE HERE.", "none"),

        ("\nBudgets Limits Tab", "h2"),
        ("\nManage category budget limits as % of monthly flexible budget. Auto-Assign from expenses; Normalize.", "none"),

        ("\nSavings Goals Tab", "h2"),
        ("\nCreate savings goals and allocate your existing savings to them. The tab shows your total Savings Balance and lets you distribute it across goals (emergency fund, vacation, laptop, etc.). Use 'Allocate Savings' to assign amounts to each goal. The 'Auto-Distribute' button will intelligently distribute unallocated savings based on priorities.", "none"),

        ("\nNet Worth Tab", "h2"),
        ("\nTrack your total financial wealth over time. Record snapshots of your asset balances to visualize growth. View net worth trends, asset allocation pie charts, and asset breakdown over time. Use Ctrl+Shift+N to quickly record a snapshot. This helps you see the big picture of your financial progress.", "none"),

        ("\nProjection Tab", "h2"),
        ("\nProject future total assets based on daily savings goal.", "none"),
        
        ("\n\nKeyboard Shortcuts", "h1"),
        ("\nPress the ⌨ button or press Escape to close this window. See the keyboard shortcuts reference for all available shortcuts.", "italic"),
    ]
    for text, tag in content:
        if tag == "none":
            help_text_widget.insert(tk.END, text)
        else:
            help_text_widget.insert(tk.END, text, tag)

    help_text_widget.config(state='disabled')
    
    # Close button
    button_frame = ttk.Frame(main_frame)
    button_frame.pack(fill='x', pady=(10, 0))
    ttk.Button(button_frame, text="Close", command=help_win.destroy).pack(side='right')"""
finance_tracker/ui/charts.py

This module handles the generation of Matplotlib figures for the application.
It separates the charting logic from the UI tabs.
"""

import matplotlib
matplotlib.use('TkAgg')
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import numpy as np
from datetime import datetime
import calendar

def create_budget_depletion_figure(state, month_str: str):
    """
    Generate a budget depletion graph showing:
    - Remaining flexible budget over the month (starts high, decreases with spending)
    - Daily available budget target (recalculated each day)
    """
    from ..services.budget_calculator import (
        get_active_monthly_income, 
        get_active_fixed_costs,
        days_in_month_str
    )
    
    try:
        year, month = map(int, month_str.split("-"))
    except ValueError:
        # Return empty figure for invalid month
        fig = Figure(figsize=(8, 2.5), dpi=100)
        ax = fig.add_subplot(111)
        ax.text(0.5, 0.5, "Invalid month format", ha='center', va='center', transform=ax.transAxes)
        return fig
    
    # Calculate budget parameters
    base_income = get_active_monthly_income(state, month_str)
    daily_savings_goal = state.budget_settings.get("daily_savings_goal", 0)
    flex_income_month = sum(i['amount'] for i in state.incomes if i['date'].startswith(month_str))
    total_income = base_income + flex_income_month
    fixed_costs = sum(fc["amount"] for fc in get_active_fixed_costs(state, month_str))
    
    days_in_month = calendar.monthrange(year, month)[1]
    monthly_savings_goal = daily_savings_goal * days_in_month
    monthly_flexible_budget = total_income - fixed_costs - monthly_savings_goal
    
    # Get daily expenses
    flex_expenses_month = [e for e in state.expenses if e['date'].startswith(month_str)]
    daily_expenses = {}
    for e in flex_expenses_month:
        daily_expenses.setdefault(e['date'], 0)
        daily_expenses[e['date']] += e['amount']
    
    # Calculate daily data
    today = datetime.now().date()
    dates = []
    remaining_budget = []
    daily_target = []
    
    cumulative_balance = monthly_flexible_budget
    
    for day in range(1, days_in_month + 1):
        date_str = f"{year}-{month:02d}-{day:02d}"
        date_obj = datetime.strptime(date_str, "%Y-%m-%d").date()
        
        if date_obj > today:
            break
        
        dates.append(date_obj)
        
        # Calculate daily target for this day
        remaining_days = days_in_month - day + 1
        if cumulative_balance <= 0:
            target = 0
        else:
            target = cumulative_balance / remaining_days if remaining_days > 0 else 0
        
        daily_target.append(target)
        
        # Subtract today's spending
        day_spent = daily_expenses.get(date_str, 0)
        cumulative_balance -= day_spent
        remaining_budget.append(cumulative_balance)
    
    # Create figure
    fig = Figure(figsize=(8, 2.5), dpi=100)
    ax = fig.add_subplot(111)
    
    if not dates:
        ax.text(0.5, 0.5, "No data for this month yet", ha='center', va='center', transform=ax.transAxes)
        return fig
    
    # Plot remaining budget line
    ax.plot(dates, remaining_budget, marker='o', linewidth=2, markersize=4, 
            color='steelblue', label='Remaining Budget')
    
    # Fill area under remaining budget
    ax.fill_between(dates, remaining_budget, 0, 
                    where=[rb >= 0 for rb in remaining_budget],
                    alpha=0.2, color='green', interpolate=True)
    ax.fill_between(dates, remaining_budget, 0,
                    where=[rb < 0 for rb in remaining_budget],
                    alpha=0.2, color='red', interpolate=True)
    
    # Plot daily target line
    ax.plot(dates, daily_target, marker='s', linewidth=2, markersize=4,
            color='orange', linestyle='--', label='Daily Target')
    
    # Add horizontal line at 0
    ax.axhline(y=0, color='black', linestyle='-', linewidth=0.8, alpha=0.5)
    
    # Initial budget reference line
    ax.axhline(y=monthly_flexible_budget, color='green', linestyle=':', 
               linewidth=1, alpha=0.5, label=f'Initial Budget: €{monthly_flexible_budget:.0f}')
    
    ax.set_title(f'Budget Depletion - {calendar.month_name[month]} {year}', fontsize=12, fontweight='bold')
    ax.set_xlabel('Date')
    ax.set_ylabel('Amount (€)')
    
    # Format y-axis
    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'€{x:,.0f}'))
    
    # Format x-axis
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%d'))
    ax.xaxis.set_major_locator(mdates.DayLocator(interval=max(1, len(dates) // 10)))
    
    ax.legend(loc='upper right', fontsize=8)
    ax.grid(True, alpha=0.3)
    fig.tight_layout()
    
    return fig

def create_net_worth_figure(snapshots):
    """Generate net worth over time line chart"""
    dates = [datetime.strptime(s['date'], '%Y-%m-%d') for s in snapshots]
    net_worths = [s['net_worth'] for s in snapshots]
    
    fig = Figure(figsize=(8, 6), dpi=100)
    ax = fig.add_subplot(111)
    
    # Plot line
    ax.plot(dates, net_worths, marker='o', linewidth=2, markersize=6, color='steelblue')
    
    # Fill area - handle positive and negative separately
    ax.fill_between(dates, net_worths, 0, where=[nw >= 0 for nw in net_worths], 
                   alpha=0.3, color='green', interpolate=True)
    ax.fill_between(dates, net_worths, 0, where=[nw < 0 for nw in net_worths], 
                   alpha=0.3, color='red', interpolate=True)
    
    # Add horizontal line at 0
    ax.axhline(y=0, color='black', linestyle='-', linewidth=0.8, alpha=0.5)
    
    ax.set_title('Net Worth Over Time', fontsize=14, fontweight='bold')
    ax.set_xlabel('Date')
    ax.set_ylabel('Net Worth (€)')
    
    # Format y-axis
    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'€{x:,.0f}'))
    
    # Format x-axis
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
    fig.autofmt_xdate(rotation=45)
    
    ax.grid(True, alpha=0.3)
    fig.tight_layout()
    
    return fig

def create_allocation_figure(positive_assets, negative_assets, total_positive):
    """Generate current asset allocation pie chart"""
    labels = list(positive_assets.keys())
    sizes = list(positive_assets.values())
    
    fig = Figure(figsize=(8, 6), dpi=100)
    ax = fig.add_subplot(111)
    
    wedges, texts, autotexts = ax.pie(sizes, autopct='%1.1f%%', startangle=140,
                                      textprops=dict(color="w"))
    
    ax.axis('equal')
    
    # Build title with warning if there are negative assets
    title = f'Asset Allocation (Positive Assets Only)\nTotal Positive: €{total_positive:,.2f}'
    if negative_assets:
        total_negative = sum(negative_assets.values())
        title += f'\n⚠️ Negative Assets: €{total_negative:,.2f} (not shown in chart)'
    
    ax.set_title(title, fontsize=12, fontweight='bold')
    ax.legend(wedges, labels, title="Assets", loc="center left", 
             bbox_to_anchor=(1, 0, 0.5, 1))
    
    plt.setp(autotexts, size=9, weight="bold")
    
    # Add text box showing negative assets if any
    if negative_assets:
        negative_text = "Negative Assets:\n" + "\n".join(
            [f"{k}: €{v:,.2f}" for k, v in negative_assets.items()]
        )
        ax.text(0.02, 0.02, negative_text, transform=ax.transAxes,
               fontsize=9, verticalalignment='bottom',
               bbox=dict(boxstyle='round', facecolor='#ffcccc', alpha=0.8))
    
    fig.tight_layout()
    return fig

def create_breakdown_figure(snapshots):
    """Generate asset breakdown over time stacked area chart"""
    dates = [datetime.strptime(s['date'], '%Y-%m-%d') for s in snapshots]
    
    # Extract each asset type
    bank = [s['bank_balance'] for s in snapshots]
    wallet = [s['wallet_balance'] for s in snapshots]
    savings = [s['savings_balance'] for s in snapshots]
    investments = [s['investment_balance'] for s in snapshots]
    money_lent = [s['money_lent_balance'] for s in snapshots]
    
    fig = Figure(figsize=(8, 6), dpi=100)
    ax = fig.add_subplot(111)
    
    # For stacked area chart, we need to handle negative values differently
    # We'll plot each asset as a separate line instead when there are negatives
    has_negatives = any(
        any(val < 0 for val in asset_list) 
        for asset_list in [bank, wallet, savings, investments, money_lent]
    )
    
    if has_negatives:
        # Plot as lines instead of stacked area
        ax.plot(dates, bank, label='Bank', marker='o', markersize=4, linewidth=2)
        ax.plot(dates, wallet, label='Wallet', marker='s', markersize=4, linewidth=2)
        ax.plot(dates, savings, label='Savings', marker='^', markersize=4, linewidth=2)
        ax.plot(dates, investments, label='Investments', marker='d', markersize=4, linewidth=2)
        ax.plot(dates, money_lent, label='Money Lent', marker='*', markersize=4, linewidth=2)
        
        # Add horizontal line at 0
        ax.axhline(y=0, color='black', linestyle='-', linewidth=0.8, alpha=0.5)
        
        ax.set_title('Asset Breakdown Over Time\n(Line chart used due to negative values)', 
                    fontsize=12, fontweight='bold')
    else:
        # Original stacked area chart for all positive values
        ax.stackplot(dates, bank, wallet, savings, investments, money_lent,
                    labels=['Bank', 'Wallet', 'Savings', 'Investments', 'Money Lent'],
                    alpha=0.8)
        ax.set_title('Asset Breakdown Over Time', fontsize=14, fontweight='bold')
    
    ax.set_xlabel('Date')
    ax.set_ylabel('Amount (€)')
    
    # Format y-axis
    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'€{x:,.0f}'))
    
    # Format x-axis
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
    fig.autofmt_xdate(rotation=45)
    
    ax.legend(loc='upper left')
    ax.grid(True, alpha=0.3)
    fig.tight_layout()
    
    return fig

def create_bar_figure(labels, values, title, breakdown_mode="total", display_mode="value", category_data=None):
    """Render the bar chart based on current breakdown and display modes"""
    fig = Figure(figsize=(10, 6), dpi=100)
    ax = fig.add_subplot(111)

    if breakdown_mode == "total":
        # Show total bars
        ax.bar(labels, values, label="Monthly Totals", color='steelblue')

        if len(values) > 1:
            x = np.arange(len(labels))
            slope, intercept = np.polyfit(x, values, 1)
            trend = slope * x + intercept
            ax.plot(labels, trend, color='red', linestyle='--', label='Trend Line')

        ax.set_title(f"{title} - Total View")
        ax.set_ylabel("Total Amount (€)")
        ax.legend()

    elif breakdown_mode == "flexible":
        # Show grouped bars for flexible income vs costs
        if not category_data:
            return None
        
        x = np.arange(len(labels))
        width = 0.35
        
        income_values = category_data.get("Flexible Income", [0] * len(labels))
        cost_values = category_data.get("Flexible Costs", [0] * len(labels))
        
        if display_mode == "percentage":
            # Convert to percentages (income as 100%, costs as % of income)
            percentage_values = []
            savings_values = []
            for inc, cost in zip(income_values, cost_values):
                if inc > 0:
                    percentage_values.append((cost / inc) * 100)
                    savings_values.append(inc - cost)
                else:
                    percentage_values.append(0 if cost == 0 else 100)
                    savings_values.append(-cost if cost > 0 else 0)
            
            # Color bars based on percentage (green if under 100%, red if over)
            bar_colors = ['#2ecc71' if pct <= 100 else '#e74c3c' for pct in percentage_values]
            bars = ax.bar(labels, percentage_values, color=bar_colors)
            
            # Add descriptive annotations to each bar
            for i, (bar, pct, inc, cost, saving) in enumerate(zip(bars, percentage_values, income_values, cost_values, savings_values)):
                height = bar.get_height()
                # Position text above the bar
                y_pos = height + 2
                
                # Create descriptive text showing costs/income
                desc_text = f"€{cost:.0f}/€{inc:.0f}"
                
                ax.annotate(desc_text,
                           xy=(bar.get_x() + bar.get_width() / 2, y_pos),
                           ha='center', va='bottom',
                           fontsize=8,
                           color='#333333')
            
            # Adjust y-axis to make room for annotations
            max_pct = max(percentage_values) if percentage_values else 100
            ax.set_ylim(0, max(max_pct + 25, 125))
            
            ax.set_title(f"Flexible Costs as % of Flexible Income")
            ax.set_ylabel("Percentage (%)")
        else:
            # Grouped bars showing income and costs side by side
            bars_income = ax.bar(x - width/2, income_values, width, label='Flexible Income', color='#2ecc71')
            bars_costs = ax.bar(x + width/2, cost_values, width, label='Flexible Costs', color='#e74c3c')
            ax.set_xticks(x)
            ax.set_xticklabels(labels)
            ax.set_title(f"Flexible Income vs Flexible Costs")
            ax.set_ylabel("Amount (€)")
            ax.set_ylabel("Amount (€)")
            ax.legend()

    elif breakdown_mode == "over_under":
        # Show grouped bars for Total Income vs Total Expenses
        if not category_data:
            return None
        
        x = np.arange(len(labels))
        width = 0.35
        
        income_values = category_data.get("Total Income", [0] * len(labels))
        expense_values = category_data.get("Total Expenses", [0] * len(labels))
        
        if display_mode == "percentage":
            # Show Net Difference (Income - Expenses)
            diff_values = []
            for inc, exp in zip(income_values, expense_values):
                diff_values.append(inc - exp)
            
            # Color bars based on difference (green if positive, red if negative)
            bar_colors = ['#2ecc71' if d >= 0 else '#e74c3c' for d in diff_values]
            bars = ax.bar(labels, diff_values, color=bar_colors)
            
            # Add horizontal line at 0
            ax.axhline(0, color='black', linewidth=0.8)
            
            # Add descriptive annotations to each bar
            for bar, diff, inc, exp in zip(bars, diff_values, income_values, expense_values):
                height = bar.get_height()
                # Position text above positive bars, below negative bars
                y_pos = height + (max(diff_values) * 0.05 if diff >= 0 else -max(abs(min(diff_values)), 100) * 0.15)
                
                # Format: €{inc} - €{exp} = €{diff}
                sign = "+" if diff >= 0 else ""
                desc_text = f"€{inc:.0f} - €{exp:.0f} = {sign}€{diff:.0f}"
                
                va = 'bottom' if diff >= 0 else 'top'
                
                ax.annotate(desc_text,
                           xy=(bar.get_x() + bar.get_width() / 2, height),
                           xytext=(0, 5 if diff >= 0 else -5),
                           textcoords="offset points",
                           ha='center', va=va,
                           fontsize=8,
                           color='#333333')
            
            # Adjust y-axis to allow room for annotations
            y_max = max(max(diff_values, default=100), 100)
            y_min = min(min(diff_values, default=0), 0)
            range_val = y_max - y_min
            ax.set_ylim(y_min - range_val * 0.2, y_max + range_val * 0.2)
            
            ax.set_title("Net Result (Total Income - Total Expenses)")
            ax.set_ylabel("Net Amount (€)")
        else:
            # Grouped bars showing income and expenses side by side
            bars_income = ax.bar(x - width/2, income_values, width, label='Total Income', color='#2ecc71')
            bars_expenses = ax.bar(x + width/2, expense_values, width, label='Total Expenses', color='#e74c3c')
            ax.set_xticks(x)
            ax.set_xticklabels(labels)
            ax.set_title(f"Total Income vs Total Expenses")
            ax.set_ylabel("Amount (€)")
            ax.legend()

    else:
        # Show stacked bars by category
        if not category_data:
            return None

        categories = list(category_data.keys())
        bottom = np.zeros(len(labels))
        
        # Color palette - use tab20 for more distinct colors
        colors = plt.get_cmap('tab20').colors
        
        for idx, category in enumerate(categories):
            cat_values = category_data[category]
            
            if display_mode == "percentage":
                # Convert to percentages
                total_values = [sum(category_data[cat][i] for cat in categories) for i in range(len(labels))]
                percentages = [cat_values[i] / total_values[i] * 100 if total_values[i] > 0 else 0 
                              for i in range(len(cat_values))]
                ax.bar(labels, percentages, bottom=bottom, label=category, 
                      color=colors[idx % len(colors)])
                bottom += percentages
            else:
                # Show absolute values
                ax.bar(labels, cat_values, bottom=bottom, label=category, 
                      color=colors[idx % len(colors)])
                bottom += cat_values

        if display_mode == "percentage":
            ax.set_title(f"{title} - Category Breakdown (Percentage)")
            ax.set_ylabel("Percentage (%)")
            ax.set_ylim(0, 100)
        else:
            ax.set_title(f"{title} - Category Breakdown (Values)")
            ax.set_ylabel("Amount (€)")
        
        ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')

    fig.autofmt_xdate(rotation=45)
    fig.tight_layout()
    
    return fig

def create_pie_figure(labels, sizes, title, value_type="Total"):
    """Generate pie chart"""
    fig = Figure(figsize=(8, 6), dpi=100)
    ax = fig.add_subplot(111)

    if value_type == "Percentage":
        autopct = '%1.1f%%'
    else:
        def absolute_value(val):
            a = (val / 100.0) * sum(sizes)
            return f'€{a:.2f}'
        autopct = absolute_value

    wedges, texts, autotexts = ax.pie(sizes, autopct=autopct, startangle=140, textprops=dict(color="w"))
    ax.axis('equal')
    ax.set_title(title)
    
    # Improved legend placement
    ax.legend(wedges, labels, title="Categories", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))

    plt.setp(autotexts, size=8, weight="bold")

    fig.tight_layout()
    return fig
 
# ui package"""
finance_tracker/ui/main_view.py

Main application window and tab management.
"""

import tkinter as tk
from tkinter import ttk

from .style import apply_styles
from .help_window import show_help
from .shortcuts import ShortcutManager

from .tabs.add_transaction_tab import AddTransactionTab
from .tabs.view_transactions_tab import ViewTransactionsTab
from .tabs.reports_tab import ReportsTab
from .tabs.settings_tab import SettingsTab
from .tabs.budgets_tab import BudgetsTab
from .tabs.projection_tab import ProjectionTab
from .tabs.goals_tab import GoalsTab
from .tabs.net_worth_tab import NetWorthTab

class MainView:
    def __init__(self, root, state):
        self.root = root
        self.root.title("Personal Finance Tracker")
        
        # Set initial window size and position
        self.root.geometry("1250x750")
        
        # Ensure window is visible and on top initially
        self.root.lift()
        self.root.attributes('-topmost', True)
        self.root.after_idle(self.root.attributes, '-topmost', False)
        
        # Force window to normal state (not minimized)
        self.root.state('normal')
        
        # Make sure window is visible
        self.root.deiconify()
        
        self.root.minsize(1250, 750)
        apply_styles()

        self.state = state

        main_frame = ttk.Frame(root)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)

        # Help Buttons - pack at bottom first
        help_button_frame = ttk.Frame(main_frame)
        help_button_frame.pack(side='bottom', fill='x', pady=(5, 0))
        
        ttk.Button(help_button_frame, text="⌨", width=3,
                   command=self._show_shortcuts_reference).pack(side='right', padx=(5, 0))
        ttk.Button(help_button_frame, text="?", width=3,
                   command=lambda: show_help(self.root)).pack(side='right')

        # Notebook - pack after help buttons
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill='both', expand=True)

        # Callback to refresh UI after data changes
        def on_data_changed():
            self.view_tab.refresh()
            self.settings_tab.refresh_fixed_costs_tree()
            self.settings_tab.refresh_balance_entries()
            self.goals_tab.refresh_goals()
        self.on_data_changed = on_data_changed

        # Tabs
        self.add_tab = AddTransactionTab(self.notebook, self.state, self.on_data_changed)
        self.view_tab = ViewTransactionsTab(self.notebook, self.state, self.on_data_changed)
        self.reports_tab = ReportsTab(self.notebook, self.state)
        self.settings_tab = SettingsTab(self.notebook, self.state)
        self.budgets_tab = BudgetsTab(self.notebook, self.state)
        self.goals_tab = GoalsTab(self.notebook, self.state)
        self.net_worth_tab = NetWorthTab(self.notebook, self.state)
        self.projection_tab = ProjectionTab(self.notebook, self.state)
        
        # Setup keyboard shortcuts
        self.shortcut_manager = ShortcutManager(self)
        self.shortcut_manager.setup_shortcuts()

    def _show_shortcuts_reference(self):
        """Show keyboard shortcuts reference window"""
        shortcuts_win = tk.Toplevel(self.root)
        shortcuts_win.title("Keyboard Shortcuts Reference")
        shortcuts_win.geometry("700x650")
        shortcuts_win.minsize(600, 500)
        
        # Bind ESC to close window
        shortcuts_win.bind('<Escape>', lambda e: shortcuts_win.destroy())

        main_frame = ttk.Frame(shortcuts_win, padding=10)
        main_frame.pack(fill='both', expand=True)

        text_frame = ttk.Frame(main_frame)
        text_frame.pack(fill='both', expand=True)

        shortcuts_text = tk.Text(text_frame, wrap='word', font=('Arial', 10), spacing3=5)
        scrollbar = ttk.Scrollbar(text_frame, orient='vertical', command=shortcuts_text.yview)
        shortcuts_text.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side='right', fill='y')
        shortcuts_text.pack(side='left', fill='both', expand=True)

        # Configure tags
        shortcuts_text.tag_configure('title', font=('Arial', 14, 'bold'), spacing1=10)
        shortcuts_text.tag_configure('section', font=('Arial', 11, 'bold'), spacing1=8, foreground='#0066cc')
        shortcuts_text.tag_configure('shortcut', font=('Courier New', 9, 'bold'), background='#f0f0f0')
        shortcuts_text.tag_configure('description', font=('Arial', 9))
        
        # Content
        content = [
            ("KEYBOARD SHORTCUTS REFERENCE\n\n", "title"),
            
            ("Navigation Shortcuts\n", "section"),
            ("Ctrl+A", "shortcut"), (" - Open Add Transaction tab and focus amount field\n", "description"),
            ("Ctrl+V", "shortcut"), (" - Go to View Transactions tab\n", "description"),
            ("Ctrl+R", "shortcut"), (" - Go to Charts/Reports tab\n", "description"),
            ("Ctrl+B", "shortcut"), (" - Go to Budget Report tab\n", "description"),
            ("Ctrl+L", "shortcut"), (" - Go to Budgets Limits tab\n", "description"),
            ("Ctrl+G", "shortcut"), (" - Go to Savings Goals tab\n", "description"),
            ("Ctrl+P", "shortcut"), (" - Go to Projection tab\n", "description"),
            ("Alt+Left", "shortcut"), (" - Go to previous tab\n", "description"),
            ("Alt+Right", "shortcut"), (" - Go to next tab\n\n", "description"),
            
            ("Action Shortcuts\n", "section"),
            ("Ctrl+S", "shortcut"), (" - Save current form/settings (context-aware)\n", "description"),
            ("Ctrl+N", "shortcut"), (" - New transaction (clears Add Transaction form)\n", "description"),
            ("Ctrl+D", "shortcut"), (" - Delete selected item\n", "description"),
            ("Delete", "shortcut"), (" - Delete selected item\n", "description"),
            ("Ctrl+E", "shortcut"), (" - Edit/Modify selected transaction\n", "description"),
            ("F5", "shortcut"), (" - Refresh current view\n", "description"),
            ("Escape", "shortcut"), (" - Clear current form or close dialog windows\n", "description"),
            ("Tab", "shortcut"), (" - Navigate between fields and buttons\n", "description"),
            ("Enter", "shortcut"), (" - Activate focused button\n\n", "description"),
            
            ("Report Shortcuts\n", "section"),
            ("Ctrl+Shift+R", "shortcut"), (" - Generate report in current tab\n", "description"),
            ("Ctrl+Shift+E", "shortcut"), (" - Export current report\n", "description"),
            ("Ctrl+Shift+G", "shortcut"), (" - Generate and view budget report\n\n", "description"),
            
            ("Quick Entry Shortcuts\n", "section"),
            ("Alt+E", "shortcut"), (" - Toggle Expense/Income type (in Add Transaction)\n\n", "description"),
            
            ("View Shortcuts\n", "section"),
            ("Ctrl+F", "shortcut"), (" - Focus search/filter field\n\n", "description"),
            
            ("Help\n", "section"),
            ("Ctrl+H", "shortcut"), (" - Show Help & Instructions\n", "description"),
            ("F1", "shortcut"), (" - Show Help & Instructions\n\n", "description"),
            
            ("Notes:\n", "section"),
            ("• On macOS, use ", "description"), ("Cmd", "shortcut"), (" instead of ", "description"), 
            ("Ctrl", "shortcut"), (" for most shortcuts\n", "description"),
            ("• Context-aware shortcuts behave differently based on the active tab\n", "description"),
            ("• Some shortcuts work globally, others only in specific tabs\n", "description"),
            ("• Press ", "description"), ("Escape", "shortcut"), (" to close this window\n", "description"),
        ]
        
        for text, tag in content:
            shortcuts_text.insert(tk.END, text, tag)

        shortcuts_text.config(state='disabled')
        
        # Close button
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill='x', pady=(10, 0))
        ttk.Button(button_frame, text="Close", command=shortcuts_win.destroy).pack(side='right')"""
finance_tracker/ui/shortcuts.py

This module handles the registration and processing of keyboard shortcuts for the application.
It separates the shortcut logic from the main view to improve modularity.
"""

import tkinter as tk
from tkinter import ttk
from .help_window import show_help
from datetime import datetime

class ShortcutManager:
    def __init__(self, main_view):
        self.mv = main_view
        self.root = main_view.root
        self.notebook = main_view.notebook

    def setup_shortcuts(self):
        """Setup global keyboard shortcuts for the application"""
        
        # Navigation Shortcuts - Add Transaction
        self.root.bind('<Control-a>', self._shortcut_add_transaction)
        self.root.bind('<Control-A>', self._shortcut_add_transaction)
        
        # Navigation Shortcuts - Tabs
        self.root.bind('<Control-v>', lambda e: self._switch_to_tab(1))
        self.root.bind('<Control-V>', lambda e: self._switch_to_tab(1))
        self.root.bind('<Control-r>', lambda e: self._switch_to_tab(2))
        self.root.bind('<Control-R>', lambda e: self._switch_to_tab(2))
        self.root.bind('<Control-b>', lambda e: self._switch_to_tab(3))
        self.root.bind('<Control-B>', lambda e: self._switch_to_tab(3))
        self.root.bind('<Control-l>', lambda e: self._switch_to_tab(4))
        self.root.bind('<Control-L>', lambda e: self._switch_to_tab(4))
        self.root.bind('<Control-g>', lambda e: self._switch_to_tab(5))
        self.root.bind('<Control-G>', lambda e: self._switch_to_tab(5))
        self.root.bind('<Control-w>', lambda e: self._switch_to_tab(6))
        self.root.bind('<Control-W>', lambda e: self._switch_to_tab(6))
        self.root.bind('<Control-p>', lambda e: self._switch_to_tab(7))
        self.root.bind('<Control-P>', lambda e: self._switch_to_tab(7))
        
        # Help
        self.root.bind('<Control-h>', lambda e: show_help(self.root))
        self.root.bind('<Control-H>', lambda e: show_help(self.root))
        self.root.bind('<F1>', lambda e: show_help(self.root))
        
        # Shortcuts Reference
        self.root.bind('<Control-k>', lambda e: self.mv._show_shortcuts_reference())
        self.root.bind('<Control-K>', lambda e: self.mv._show_shortcuts_reference())
        self.root.bind('<F2>', lambda e: self.mv._show_shortcuts_reference())
        
        # Alt+Left/Right: Navigate between tabs
        self.root.bind('<Alt-Left>', self._shortcut_previous_tab)
        self.root.bind('<Alt-Right>', self._shortcut_next_tab)
        
        # Action Shortcuts
        self.root.bind('<Control-s>', self._shortcut_save)
        self.root.bind('<Control-S>', self._shortcut_save)
        self.root.bind('<Control-n>', self._shortcut_new_transaction)
        self.root.bind('<Control-N>', self._shortcut_new_transaction)
        self.root.bind('<Control-d>', self._shortcut_delete)
        self.root.bind('<Control-D>', self._shortcut_delete)
        self.root.bind('<Control-e>', self._shortcut_edit)
        self.root.bind('<Control-E>', self._shortcut_edit)
        self.root.bind('<Delete>', self._shortcut_delete)
        self.root.bind('<F5>', self._shortcut_refresh)
        
        # Report Shortcuts
        self.root.bind('<Control-Shift-R>', self._shortcut_generate_report)
        self.root.bind('<Control-Shift-E>', self._shortcut_export)
        self.root.bind('<Control-Shift-G>', self._shortcut_budget_report)
        self.root.bind('<Control-Shift-N>', self._shortcut_net_worth_snapshot)
        
        # Quick Entry - Toggle Expense/Income
        self.root.bind('<Alt-e>', self._shortcut_toggle_type)
        self.root.bind('<Alt-E>', self._shortcut_toggle_type)
        
        # View Shortcuts
        self.root.bind('<Control-f>', self._shortcut_focus_filter)
        self.root.bind('<Control-F>', self._shortcut_focus_filter)
        
        # Escape to clear forms
        self.root.bind('<Escape>', self._shortcut_escape)
        
        # For macOS compatibility (Command key)
        self.root.bind('<Command-a>', self._shortcut_add_transaction)
        self.root.bind('<Command-A>', self._shortcut_add_transaction)
        self.root.bind('<Command-s>', self._shortcut_save)
        self.root.bind('<Command-S>', self._shortcut_save)
        self.root.bind('<Command-n>', self._shortcut_new_transaction)
        self.root.bind('<Command-N>', self._shortcut_new_transaction)
        self.root.bind('<Command-h>', lambda e: show_help(self.root))
        self.root.bind('<Command-H>', lambda e: show_help(self.root))
        self.root.bind('<Command-k>', lambda e: self.mv._show_shortcuts_reference())
        self.root.bind('<Command-K>', lambda e: self.mv._show_shortcuts_reference())

        # Enable Enter key on buttons globally
        self._setup_button_enter_key()

    def _setup_button_enter_key(self):
        """Enable Enter key to activate focused buttons"""
        def on_button_enter(event):
            widget = event.widget
            if isinstance(widget, ttk.Button):
                widget.invoke()
                return 'break'
        
        self.root.bind_class('TButton', '<Return>', on_button_enter)
        self.root.bind_class('TButton', '<KP_Enter>', on_button_enter)
    
    def _switch_to_tab(self, index):
        """Switch to a specific tab by index"""
        total_tabs = self.notebook.index('end')
        if 0 <= index < total_tabs:
            self.notebook.select(index)
        return 'break'
    
    def _shortcut_add_transaction(self, event):
        """Handle Ctrl+A shortcut to open Add Transaction tab"""
        self.notebook.select(0)
        self.mv.add_tab.amount_entry.focus_set()
        self.mv.add_tab.amount_entry.select_range(0, tk.END)
        return 'break'
    
    def _shortcut_new_transaction(self, event):
        """Handle Ctrl+N shortcut to clear Add Transaction form"""
        self.notebook.select(0)
        # Clear all fields
        self.mv.add_tab.date_entry.delete(0, tk.END)
        self.mv.add_tab.date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.mv.add_tab.amount_entry.delete(0, tk.END)
        self.mv.add_tab.description_entry.delete(0, tk.END)
        self.mv.add_tab.transaction_type_var.set("Expense")
        self.mv.add_tab.update_categories()
        self.mv.add_tab.amount_entry.focus_set()
        return 'break'
    
    def _shortcut_previous_tab(self, event):
        """Handle Alt+Left shortcut to go to previous tab"""
        current_index = self.notebook.index(self.notebook.select())
        total_tabs = self.notebook.index('end')
        new_index = (current_index - 1) % total_tabs
        self.notebook.select(new_index)
        return 'break'
    
    def _shortcut_next_tab(self, event):
        """Handle Alt+Right shortcut to go to next tab"""
        current_index = self.notebook.index(self.notebook.select())
        total_tabs = self.notebook.index('end')
        new_index = (current_index + 1) % total_tabs
        self.notebook.select(new_index)
        return 'break'
    
    def _shortcut_save(self, event):
        """Handle Ctrl+S shortcut to save in current tab"""
        current_index = self.notebook.index(self.notebook.select())
        
        if current_index == 0:  # Add Transaction
            self.mv.add_tab.add_transaction()
        elif current_index == 3:  # Budget Report (Settings)
            self.mv.settings_tab.save_settings()
        elif current_index == 4:  # Budgets Limits
            self.mv.budgets_tab.save_budgets()
        elif current_index == 5:  # Goals
            if self.mv.goals_tab.selected_goal_index is not None:
                self.mv.goals_tab.update_goal()
            else:
                self.mv.goals_tab.add_goal()
        elif current_index == 6:  # Net Worth - record snapshot
            self.mv.net_worth_tab.record_snapshot()
        
        return 'break'
    
    def _shortcut_delete(self, event):
        """Handle Ctrl+D or Delete shortcut to delete selected item"""
        current_index = self.notebook.index(self.notebook.select())
        
        if current_index == 1:  # View Transactions
            self.mv.view_tab.delete_transaction()
        elif current_index == 5:  # Goals
            # Delete selected goal if any widget has focus in goals tab
            if self.mv.goals_tab.selected_goal_index is not None:
                self.mv.goals_tab.delete_goal(self.mv.goals_tab.selected_goal_index)
        elif current_index == 6:  # Net Worth
            self.mv.net_worth_tab.delete_selected_snapshot()
        
        return 'break'
    
    def _shortcut_edit(self, event):
        """Handle Ctrl+E shortcut to edit selected item"""
        current_index = self.notebook.index(self.notebook.select())
        
        if current_index == 1:  # View Transactions
            self.mv.view_tab.open_modify_window()
        
        return 'break'
    
    def _shortcut_refresh(self, event):
        """Handle F5 shortcut to refresh current view"""
        current_index = self.notebook.index(self.notebook.select())
        
        if current_index == 1:  # View Transactions
            self.mv.view_tab.refresh()
        elif current_index == 3:  # Budget Report
            self.mv.settings_tab.generate_report()
        elif current_index == 4:  # Budgets Limits
            self.mv.budgets_tab._update_monetary_labels()
        elif current_index == 5:  # Goals
            self.mv.goals_tab.refresh_goals()
        elif current_index == 6:  # Net Worth
            self.mv.net_worth_tab.refresh()
        
        return 'break'
    
    def _shortcut_generate_report(self, event):
        """Handle Ctrl+Shift+R to generate report in current tab"""
        current_index = self.notebook.index(self.notebook.select())
        
        if current_index == 2:  # Charts/Reports
            self.mv.reports_tab.generate()
        elif current_index == 3:  # Budget Report
            self.mv.settings_tab.generate_report()
        elif current_index == 5:  # Goals
            self.mv.goals_tab.show_report()
        elif current_index == 6:  # Net Worth
            self.mv.net_worth_tab.show_report()
        elif current_index == 7:  # Projection
            self.mv.projection_tab.generate()
        
        return 'break'
    
    def _shortcut_export(self, event):
        """Handle Ctrl+Shift+E to export current report"""
        current_index = self.notebook.index(self.notebook.select())
        
        if current_index == 3:  # Budget Report
            self.mv.settings_tab.export_report()
        elif current_index == 5:  # Goals
            self.mv.goals_tab.export_report()
        elif current_index == 6:  # Net Worth
            self.mv.net_worth_tab.export_report()
        elif current_index == 7:  # Projection
            self.mv.projection_tab.export()
        
        return 'break'
    
    def _shortcut_budget_report(self, event):
        """Handle Ctrl+Shift+G to generate budget report"""
        self.notebook.select(3)  # Switch to Budget Report tab
        self.mv.settings_tab.generate_report()
        return 'break'
    
    def _shortcut_net_worth_snapshot(self, event):
        """Handle Ctrl+Shift+N to record net worth snapshot"""
        self.notebook.select(6)  # Switch to Net Worth tab
        self.mv.net_worth_tab.record_snapshot()
        return 'break'
    
    def _shortcut_toggle_type(self, event):
        """Handle Alt+E to toggle Expense/Income type in Add Transaction"""
        current_index = self.notebook.index(self.notebook.select())
        
        if current_index == 0:  # Add Transaction
            current = self.mv.add_tab.transaction_type_var.get()
            self.mv.add_tab.transaction_type_var.set("Income" if current == "Expense" else "Expense")
            self.mv.add_tab.update_categories()
        
        return 'break'
    
    def _shortcut_focus_filter(self, event):
        """Handle Ctrl+F to focus filter/search field"""
        current_index = self.notebook.index(self.notebook.select())
        
        if current_index == 1:  # View Transactions
            self.mv.view_tab.month_filter.focus_set()
            self.mv.view_tab.month_filter.select_range(0, tk.END)
        elif current_index == 2:  # Charts
            self.mv.reports_tab.month_entry.focus_set()
            self.mv.reports_tab.month_entry.select_range(0, tk.END)
        elif current_index == 4:  # Budgets Limits
            self.mv.budgets_tab.month_var.get()
        
        return 'break'
    
    def _shortcut_escape(self, event):
        """Handle Escape to clear forms or close dialogs"""
        current_index = self.notebook.index(self.notebook.select())
        
        if current_index == 0:  # Add Transaction - clear description
            self.mv.add_tab.description_entry.delete(0, tk.END)
        elif current_index == 5:  # Goals - clear form
            self.mv.goals_tab.clear_form()
        
        return 'break'"""
finance_tracker/services/report_builder.py

Service for preparing data for various financial reports and charts.
"""

from datetime import date
from dateutil.relativedelta import relativedelta
from .budget_calculator import get_active_fixed_costs, get_active_monthly_income

def pie_data(state, month_str: str, chart_type: str, include_fixed: bool, include_base_income: bool):
    if chart_type == "Expense":
        data = state.expenses
        title = f"Expenses for {month_str}"
        category_totals = {}
        if include_fixed:
            total_fc = sum(fc['amount'] for fc in get_active_fixed_costs(state, month_str))
            if total_fc > 0:
                category_totals["Fixed Costs"] = total_fc
    else:
        data = state.incomes
        title = f"Incomes for {month_str}"
        category_totals = {}
        if include_base_income:
            base_income = get_active_monthly_income(state, month_str)
            if base_income > 0:
                category_totals["Base Income"] = base_income

    for item in data:
        if item['date'].startswith(month_str):
            category_totals[item['category']] = category_totals.get(item['category'], 0) + item['amount']

    return title, category_totals

def history_data(state, num_months: int, chart_type: str, include_fixed: bool, include_base_income: bool):
    today = date.today()
    monthly_totals = {}
    if chart_type == "Expense":
        fixed_value = 0
        if include_fixed:
            # For historical data, we need to get active costs for each specific month
            # We'll handle this in the loop below
            pass
        data = state.expenses
        title = f"Historical Expenses for the Last {num_months} Months"
    else:
        # fixed_value = state.budget_settings.get('monthly_income', 0) if include_base_income else 0 # REMOVED
        data = state.incomes
        title = f"Historical Incomes for the Last {num_months} Months"

    for i in range(num_months - 1, -1, -1):
        month_date = today - relativedelta(months=i)
        key = month_date.strftime("%Y-%m")
        # Get fixed costs active in this specific month
        if chart_type == "Expense" and include_fixed:
            month_fixed = sum(fc['amount'] for fc in get_active_fixed_costs(state, key))
            monthly_totals[key] = month_fixed
        elif chart_type == "Income" and include_base_income:
            monthly_totals[key] = get_active_monthly_income(state, key)
        else:
            monthly_totals[key] = 0

    for item in data:
        month = item['date'][:7]
        if month in monthly_totals:
            monthly_totals[month] += item['amount']

    labels = list(monthly_totals.keys())
    values = list(monthly_totals.values())
    return title, labels, values# service namespace"""
finance_tracker/services/budget_calculator.py

Service for calculating budget limits and available spending.
"""

from datetime import datetime
import calendar

def get_active_fixed_costs(state, month_str: str) -> list:
    """
    Returns only the fixed costs that were active during the specified month.
    A fixed cost is active if its date range overlaps with the month.
    """
    try:
        month_start = datetime.strptime(month_str + "-01", "%Y-%m-%d").date()
        _, last_day = calendar.monthrange(month_start.year, month_start.month)
        month_end = datetime(month_start.year, month_start.month, last_day).date()
    except ValueError:
        # If invalid month format, return all costs as fallback
        return state.budget_settings.get("fixed_costs", [])
    
    active_costs = []
    for fc in state.budget_settings.get("fixed_costs", []):
        # Parse start_date
        try:
            start = datetime.strptime(fc.get('start_date', '2000-01-01'), "%Y-%m-%d").date()
        except (ValueError, TypeError):
            start = datetime(2000, 1, 1).date()
        
        # Parse end_date (None means still active)
        end_date_str = fc.get('end_date')
        if end_date_str is None:
            end = None
        else:
            try:
                end = datetime.strptime(end_date_str, "%Y-%m-%d").date()
            except (ValueError, TypeError):
                end = None
        
        # Check for overlap:
        # (Start <= MonthEnd) AND (End is None OR End >= MonthStart)
        if start <= month_end and (end is None or end >= month_start):
            active_costs.append(fc)
    
    return active_costs

def get_active_monthly_income(state, month_str: str) -> float:
    """
    Returns the total base monthly income active for the specified month.
    An income source is active if its date range overlaps with the month.
    """
    try:
        month_start = datetime.strptime(month_str + "-01", "%Y-%m-%d").date()
        _, last_day = calendar.monthrange(month_start.year, month_start.month)
        month_end = datetime(month_start.year, month_start.month, last_day).date()
    except ValueError:
        return 0.0
    
    total_base_income = 0.0
    # Handle both old float format (just in case accessed via old state) and new list format
    income_data = state.budget_settings.get("monthly_income", [])
    
    # Fallback for safe transition if raw data hasn't been migrated in memory yet
    if isinstance(income_data, (int, float)):
        return float(income_data)
        
    for inc in income_data:
        try:
            start = datetime.strptime(inc.get('start_date', '2000-01-01'), "%Y-%m-%d").date()
        except (ValueError, TypeError):
            start = datetime(2000, 1, 1).date()
        
        end_date_str = inc.get('end_date')
        if end_date_str is None:
            end = None
        else:
            try:
                end = datetime.strptime(end_date_str, "%Y-%m-%d").date()
            except (ValueError, TypeError):
                end = None
        
        if start <= month_end and (end is None or end >= month_start):
            total_base_income += inc.get('amount', 0.0)
            
    return total_base_income

def days_in_month_str(month_str: str) -> int:
    try:
        year, month = map(int, month_str.split("-"))
        return calendar.monthrange(year, month)[1]
    except Exception:
        return 30

def compute_net_available_for_spending(state, month_str: str) -> float:
    try:
        datetime.strptime(month_str, "%Y-%m")
    except ValueError:
        month_str = datetime.now().strftime("%Y-%m")

    base_income = get_active_monthly_income(state, month_str)
    daily_savings_goal = state.budget_settings.get("daily_savings_goal", 0)
    flex_income_month = sum(i["amount"] for i in state.incomes if i["date"].startswith(month_str))
    total_income = base_income + flex_income_month
    fixed_costs = sum(fc["amount"] for fc in get_active_fixed_costs(state, month_str))

    dim = days_in_month_str(month_str)
    monthly_savings_goal = daily_savings_goal * dim
    flexible = total_income - fixed_costs - monthly_savings_goal
    return max(flexible, 0)

def generate_daily_budget_report(state, month_str: str) -> str:
    try:
        year, month = map(int, month_str.split("-"))
    except ValueError:
        return "Invalid month format. Use YYYY-MM."

    base_income = get_active_monthly_income(state, month_str)
    daily_savings_goal = state.budget_settings.get("daily_savings_goal", 0)
    flex_income_month = sum(i['amount'] for i in state.incomes if i['date'].startswith(month_str))
    total_income = base_income + flex_income_month
    fixed_costs = sum(fc["amount"] for fc in get_active_fixed_costs(state, month_str))

    days_in_month = calendar.monthrange(year, month)[1]
    monthly_savings_goal = daily_savings_goal * days_in_month
    monthly_flexible_spending_budget = total_income - fixed_costs - monthly_savings_goal
    initial_daily_spending_target = monthly_flexible_spending_budget / days_in_month if days_in_month else 0

    flex_expenses_month = [e for e in state.expenses if e['date'].startswith(month_str)]
    daily_expenses = {}
    for e in flex_expenses_month:
        daily_expenses.setdefault(e['date'], []).append(e)

    from datetime import datetime as dt, date as ddate
    report = f"{'='*80}\n"
    report += f"DAILY BUDGET REPORT - {calendar.month_name[month]} {year}\n"
    report += f"{'='*80}\n\n"
    report += f"Base Monthly Income:                      €{base_income:>10.2f}\n"
    report += f"Flexible Income (This Month):             €{flex_income_month:>10.2f}\n"
    report += f"TOTAL INCOME:                             €{total_income:>10.2f}\n"
    report += f"Total Fixed Costs:                       -€{fixed_costs:>10.2f}\n"
    report += f"{'-'*50}\n"
    report += f"Monthly Savings Goal:                    -€{monthly_savings_goal:>10.2f}\n"
    report += f"NET MONTHLY FLEXIBLE BUDGET:              €{monthly_flexible_spending_budget:>10.2f}\n"
    report += f"INITIAL DAILY SPENDING TARGET:            €{initial_daily_spending_target:>10.2f}\n"
    report += f"{'-'*80}\n\n"
    report += f"DAILY BREAKDOWN (Flexible daily target adjusts based on remaining budget)\n"
    report += f"{'-'*80}\n"
    report += f"{'Date':<12} {'Target':<12} {'Spent':<12} {'Daily +/-':<12} {'Cumulative':<12} {'Status'}\n"
    report += f"{'-'*80}\n"

    cumulative_flexible_balance = monthly_flexible_spending_budget
    today = dt.now().date()
    
    for day in range(1, days_in_month + 1):
        date_str = f"{year}-{month:02d}-{day:02d}"
        date_obj = dt.strptime(date_str, "%Y-%m-%d").date()
        if date_obj > today:
            break
        
        # Calculate flexible target for THIS day based on remaining days INCLUDING today
        # If budget is depleted (≤0), target becomes 0
        remaining_days_including_today = days_in_month - day + 1
        if cumulative_flexible_balance <= 0:
            daily_target_for_this_day = 0
        else:
            daily_target_for_this_day = cumulative_flexible_balance / remaining_days_including_today if remaining_days_including_today > 0 else 0
        
        day_spent = sum(e['amount'] for e in daily_expenses.get(date_str, []))
        cumulative_flexible_balance -= day_spent
        daily_plus_minus = daily_target_for_this_day - day_spent
        
        status = "✓ On Track" if daily_plus_minus >= 0 else "✗ Overspent"
        if day_spent == 0:
            status = "- No spending"
        
        report += (f"{date_str:<12} €{daily_target_for_this_day:<10.2f} "
                   f"€{day_spent:<10.2f} €{daily_plus_minus:<10.2f} "
                   f"€{cumulative_flexible_balance:<10.2f} {status}\n")

    report += f"{'-'*80}\n\n"

    if today.year == year and today.month == month and today.day < days_in_month:
        remaining_days = days_in_month - today.day
        if remaining_days > 0:
            new_daily_target = cumulative_flexible_balance / remaining_days if cumulative_flexible_balance > 0 else 0
            
            report += f"{'='*80}\n"
            report += f"YOUR PATH FORWARD\n"
            report += f"{'='*80}\n\n"
            
            if cumulative_flexible_balance <= 0:
                total_flexible_expenses_incurred = sum(e['amount'] for e in flex_expenses_month)
                overall_net_value = total_income - fixed_costs - total_flexible_expenses_incurred - monthly_savings_goal
                overspend_amount = abs(cumulative_flexible_balance)
                
                report += f"⚠️  BUDGET DEPLETED: You have overspent your flexible budget by €{overspend_amount:.2f}\n\n"
                report += f"You have {remaining_days} days remaining and need to:\n\n"
                report += f"OPTION 1: Zero Spending Challenge\n"
                report += f"  • Spend €0.00 per day for the remaining {remaining_days} days\n"
                report += f"  • This will keep your deficit at €{overspend_amount:.2f}\n\n"
                report += f"OPTION 2: Accept the Deficit\n"
                report += f"  • Continue spending normally\n"
                report += f"  • Make up the €{overspend_amount:.2f} deficit next month\n\n"
                report += f"OPTION 3: Partial Recovery\n"
                report += f"  • Reduce spending as much as possible\n"
                report += f"  • Any amount you save reduces the deficit\n\n"
            elif new_daily_target <= initial_daily_spending_target * 0.7:
                report += f"⚠️  SPENDING CAUTION NEEDED\n\n"
                report += f"You've spent more than planned in the first part of the month.\n"
                report += f"Your adjusted daily target is now: €{new_daily_target:.2f}/day (= €{cumulative_flexible_balance:.2f} / {remaining_days})\n"
                report += f"(Original target was: €{initial_daily_spending_target:.2f}/day)\n\n"
                report += f"Action Steps:\n"
                report += f"  • Try to limit spending to €{new_daily_target:.2f} per day\n"
                report += f"  • You have {remaining_days} days left to stay within budget\n"
                report += f"  • Current remaining budget: €{cumulative_flexible_balance:.2f}\n\n"
            elif new_daily_target >= initial_daily_spending_target * 1.3:
                report += f"✓ EXCELLENT PROGRESS!\n\n"
                report += f"You're doing great! You've been spending less than planned.\n"
                report += f"Your adjusted daily target is now: €{new_daily_target:.2f}/day\n"
                report += f"(Original target was: €{initial_daily_spending_target:.2f}/day)\n\n"
                report += f"Your Options:\n"
                report += f"  • Continue at your current pace and build a buffer\n"
                report += f"  • Enjoy up to €{new_daily_target:.2f}/day for the next {remaining_days} days\n"
                report += f"  • Current remaining budget: €{cumulative_flexible_balance:.2f}\n\n"
            else:
                report += f"✓ ON TRACK\n\n"
                report += f"You can spend up to €{new_daily_target:.2f} per day for the next {remaining_days} days.\n\n"
                report += f"Budget Status:\n"
                report += f"  • Days remaining: {remaining_days}\n"
                report += f"  • Remaining flexible budget: €{cumulative_flexible_balance:.2f}\n"
                report += f"  • Adjusted daily target: €{new_daily_target:.2f}\n\n"
        else:
            new_daily_target = cumulative_flexible_balance
            if new_daily_target < 0:
                report += f"Month Complete: You overspent your flexible budget by €{abs(new_daily_target):.2f}\n"
            else:
                report += f"Month Complete: You have €{new_daily_target:.2f} remaining in your flexible budget.\n"
    
    return report

def auto_assign_percentages(state, month_str: str, cat_type: str, categories: list):
    """
    Returns:
        (percentages_dict, message, is_overspent)
    """
    if cat_type != "Expense":
        return {}, "Auto-assign is only available for Expense budgets.", False

    try:
        datetime.strptime(month_str, "%Y-%m")
    except ValueError:
        return {}, "Invalid month format. Use YYYY-MM.", False

    net_available = compute_net_available_for_spending(state, month_str)
    if net_available <= 0:
        return {}, "Net available for spending is €0 for this month. Cannot auto-assign.", False

    spend_by_cat = {c: 0.0 for c in categories}
    for e in state.expenses:
        if e['date'].startswith(month_str) and e['category'] in spend_by_cat:
            spend_by_cat[e['category']] += float(e['amount'])

    total_spent = sum(spend_by_cat.values())
    if total_spent == 0:
        return {}, "No expenses recorded for the selected month. Nothing to auto-assign.", False

    if total_spent <= net_available:
        percentages = {c: (spend_by_cat[c] / net_available) * 100.0 for c in categories}
        remaining = net_available - total_spent
        remaining_pct = 100.0 - sum(percentages.values())
        msg = (f"Budgets set to match current expenses for {month_str}.\n"
               f"Remaining unallocated budget: €{remaining:.2f} (~{remaining_pct:.1f}%).\n"
               f"Please assign the remaining budget to one or more categories.")
        return percentages, msg, False
    else:
        percentages = {c: ((spend_by_cat[c] / total_spent) * 100.0 if total_spent > 0 else 0.0) for c in categories}
        over = total_spent - net_available
        msg = (f"You have spent €{total_spent:.2f} which exceeds your flexible budget of "
               f"€{net_available:.2f} by €{over:.2f}. Budgets were set proportionally to actual spend.")
        return percentages, msg, True
"""
finance_tracker/services/asset_tracking_service.py

Service for tracking asset snapshots and calculating net worth.
"""

from datetime import datetime, date
from dateutil.relativedelta import relativedelta

def record_asset_snapshot(state, snapshot_date=None, note=""):
    """Record current asset balances as a snapshot"""
    if snapshot_date is None:
        snapshot_date = date.today().strftime('%Y-%m-%d')
    
    bs = state.budget_settings
    snapshot = {
        'date': snapshot_date,
        'bank_balance': bs.get('bank_account_balance', 0),
        'wallet_balance': bs.get('wallet_balance', 0),
        'savings_balance': bs.get('savings_balance', 0),
        'investment_balance': bs.get('investment_balance', 0),
        'money_lent_balance': bs.get('money_lent_balance', 0),
        'note': note
    }

    # Calculate net worth
    snapshot['net_worth'] = (
        snapshot['bank_balance'] + 
        snapshot['wallet_balance'] + 
        snapshot['savings_balance'] + 
        snapshot['investment_balance'] + 
        snapshot['money_lent_balance']
    )

    if 'asset_snapshots' not in state.budget_settings:
        state.budget_settings['asset_snapshots'] = []

    # Check if snapshot for this date already exists
    existing = [s for s in state.budget_settings['asset_snapshots'] if s['date'] == snapshot_date]
    if existing:
        # Update existing snapshot
        idx = state.budget_settings['asset_snapshots'].index(existing[0])
        state.budget_settings['asset_snapshots'][idx] = snapshot
    else:
        # Add new snapshot
        state.budget_settings['asset_snapshots'].append(snapshot)

    # Sort by date
    state.budget_settings['asset_snapshots'].sort(key=lambda x: x['date'])

    return snapshot

def get_asset_snapshots(state, start_date=None, end_date=None):
    """Get asset snapshots within a date range"""
    snapshots = state.budget_settings.get('asset_snapshots', [])
    
    if not start_date and not end_date:
        return snapshots

    filtered = []
    for snapshot in snapshots:
        snap_date = snapshot['date']
        if start_date and snap_date < start_date:
            continue
        if end_date and snap_date > end_date:
            continue
        filtered.append(snapshot)

    return filtered

def get_current_net_worth(state):
    """Calculate current net worth from current balances"""
    bs = state.budget_settings
    return (
        bs.get('bank_account_balance', 0) +
        bs.get('wallet_balance', 0) +
        bs.get('savings_balance', 0) +
        bs.get('investment_balance', 0) +
        bs.get('money_lent_balance', 0)
    )

def get_net_worth_change(state, period_months=1):
    """Calculate net worth change over a period"""
    snapshots = state.budget_settings.get('asset_snapshots', [])
    
    if not snapshots:
        return None, "No historical data available"

    current_net_worth = get_current_net_worth(state)

    # Get snapshot from period_months ago
    target_date = (date.today() - relativedelta(months=period_months)).strftime('%Y-%m-%d')

    # Find closest snapshot to target date
    past_snapshot = None
    for snapshot in reversed(snapshots):
        if snapshot['date'] <= target_date:
            past_snapshot = snapshot
            break

    if not past_snapshot:
        return None, f"No data from {period_months} month(s) ago"

    change = current_net_worth - past_snapshot['net_worth']
    change_pct = (change / past_snapshot['net_worth'] * 100) if past_snapshot['net_worth'] != 0 else 0

    return {
        'current': current_net_worth,
        'past': past_snapshot['net_worth'],
        'change': change,
        'change_pct': change_pct,
        'past_date': past_snapshot['date']
    }, None

def delete_snapshot(state, snapshot_date):
    """Delete a snapshot by date"""
    snapshots = state.budget_settings.get('asset_snapshots', [])
    state.budget_settings['asset_snapshots'] = [s for s in snapshots if s['date'] != snapshot_date]
    return True

def generate_net_worth_report(state):
    """Generate a comprehensive net worth report"""
    snapshots = state.budget_settings.get('asset_snapshots', [])
    current_net_worth = get_current_net_worth(state)

    report = f"{'='*80}\n"
    report += f"NET WORTH REPORT\n"
    report += f"{'='*80}\n\n"
    report += f"Generated: {date.today().strftime('%B %d, %Y')}\n\n"

    # Current status
    bs = state.budget_settings
    report += f"CURRENT ASSET BREAKDOWN\n"
    report += f"{'-'*80}\n"
    report += f"Bank Account:        €{bs.get('bank_account_balance', 0):>12,.2f}\n"
    report += f"Wallet:              €{bs.get('wallet_balance', 0):>12,.2f}\n"
    report += f"Savings:             €{bs.get('savings_balance', 0):>12,.2f}\n"
    report += f"Investments:         €{bs.get('investment_balance', 0):>12,.2f}\n"
    report += f"Money Lent:          €{bs.get('money_lent_balance', 0):>12,.2f}\n"
    report += f"{'-'*80}\n"
    report += f"CURRENT NET WORTH:   €{current_net_worth:>12,.2f}\n\n"

    if not snapshots:
        report += "No historical snapshots recorded yet.\n"
        report += "Start tracking by recording your first snapshot!\n"
        return report

    # Historical changes
    report += f"{'='*80}\n"
    report += f"HISTORICAL CHANGES\n"
    report += f"{'='*80}\n\n"

    # Calculate changes for different periods
    periods = [1, 3, 6, 12]
    for months in periods:
        change_data, error = get_net_worth_change(state, months)
        if change_data:
            sign = "+" if change_data['change'] >= 0 else ""
            report += f"Change over {months} month(s) (since {change_data['past_date']}):\n"
            report += f"  {sign}€{change_data['change']:,.2f} ({sign}{change_data['change_pct']:.1f}%)\n"
            report += f"  From: €{change_data['past']:,.2f} → To: €{change_data['current']:,.2f}\n\n"

    # Snapshot history
    report += f"\n{'='*80}\n"
    report += f"SNAPSHOT HISTORY\n"
    report += f"{'='*80}\n\n"
    report += f"{'Date':<12} {'Net Worth':>15} {'Change':>15} {'Note'}\n"
    report += f"{'-'*80}\n"

    for i, snapshot in enumerate(snapshots):
        net_worth = snapshot['net_worth']
        
        # Calculate change from previous snapshot
        if i > 0:
            prev_net_worth = snapshots[i-1]['net_worth']
            change = net_worth - prev_net_worth
            sign = "+" if change >= 0 else ""
            change_str = f"{sign}€{change:,.2f}"
        else:
            change_str = "—"
        
        note = snapshot.get('note', '')[:30]
        report += f"{snapshot['date']:<12} €{net_worth:>13,.2f} {change_str:>15} {note}\n"

    # Latest snapshot info
    if snapshots:
        latest = snapshots[-1]
        report += f"\n{'-'*80}\n"
        report += f"Latest snapshot from: {latest['date']}\n"
        report += f"Latest recorded net worth: €{latest['net_worth']:,.2f}\n"
        
        if latest['date'] != date.today().strftime('%Y-%m-%d'):
            diff = current_net_worth - latest['net_worth']
            sign = "+" if diff >= 0 else ""
            report += f"Change since last snapshot: {sign}€{diff:,.2f}\n"

    return report

def get_asset_allocation_data(state):
    """Get current asset allocation percentages"""
    bs = state.budget_settings

    assets = {
        'Bank Account': bs.get('bank_account_balance', 0),
        'Wallet': bs.get('wallet_balance', 0),
        'Savings': bs.get('savings_balance', 0),
        'Investments': bs.get('investment_balance', 0),
        'Money Lent': bs.get('money_lent_balance', 0)
    }

    total = sum(assets.values())

    if total == 0:
        return {}, 0

    percentages = {k: (v / total * 100) for k, v in assets.items() if v > 0}

    return percentages, total
"""
finance_tracker/services/projection_service.py

Service for generating financial projections based on current data.
"""

from datetime import date
from dateutil.relativedelta import relativedelta

def projection_text(state, num_months: int) -> str:
    bank_balance = state.budget_settings.get('bank_account_balance', 0)
    wallet_balance = state.budget_settings.get('wallet_balance', 0)
    savings_balance = state.budget_settings.get('savings_balance', 0)
    investment_balance = state.budget_settings.get('investment_balance', 0)
    money_lent_balance = state.budget_settings.get('money_lent_balance', 0)
    daily_savings_goal = state.budget_settings.get('daily_savings_goal', 0)

    starting_total_balance = (bank_balance + wallet_balance + savings_balance +
                              investment_balance + money_lent_balance)

    report = f"{'='*80}\n"
    report += f"FINANCIAL PROJECTION\n"
    report += f"{'='*80}\n\n"
    report += f"This report projects your total financial balance (Bank + Wallet + Savings + Investments + Money Lent).\n"
    report += f"It assumes you will meet your daily savings goal every day.\n\n"
    report += f"Bank Account Balance:       €{bank_balance:>10.2f}\n"
    report += f"Wallet Balance:             €{wallet_balance:>10.2f}\n"
    report += f"Current Savings Balance:    €{savings_balance:>10.2f}\n"
    report += f"Current Investment Balance: €{investment_balance:>10.2f}\n"
    report += f"Money Lent Balance:         €{money_lent_balance:>10.2f}\n"
    report += f"-----------------------------------------\n"
    report += f"Total Starting Balance:     €{starting_total_balance:>10.2f}\n"
    report += f"Target Daily Savings Goal:  €{daily_savings_goal:>10.2f}\n"
    report += f"{'-'*80}\n\n"
    report += f"{'Month':<15} {'Projected Monthly Savings':<30} {'Projected Total Balance'}\n"
    report += f"{'-'*80}\n"

    projected_balance = starting_total_balance
    current_date = date.today()

    for _ in range(num_months):
        next_month_date = current_date + relativedelta(months=1)
        days_in_month = (next_month_date - current_date).days
        monthly_savings = daily_savings_goal * days_in_month
        projected_balance += monthly_savings
        report += f"{current_date.strftime('%Y-%m'):<15} €{monthly_savings:<28.2f} €{projected_balance:10.2f}\n"
        current_date = next_month_date

    report += f"{'-'*80}\n"
    return report"""
finance_tracker/services/goals_service.py

Service for managing savings goals, including progress calculation and reports.
"""

from datetime import date, timedelta, datetime
from dateutil.relativedelta import relativedelta

def calculate_goal_progress(goal, current_savings):
    """Calculate progress for a single goal"""
    target = goal['target_amount']
    allocated = goal['allocated_amount']
    
    progress_pct = (allocated / target * 100) if target > 0 else 0
    remaining = max(target - allocated, 0)
    
    return {
        'progress_pct': progress_pct,
        'remaining': remaining,
        'is_complete': allocated >= target
    }

def estimate_completion_date(goal):
    """Estimate when a goal will be completed based on average monthly allocation."""
    remaining = goal['target_amount'] - goal.get('allocated_amount', 0)
    if remaining <= 0:
        return None, "Goal already achieved!"

    created_date_str = goal.get('created_date')
    if not created_date_str:
        return None, "Cannot estimate without a creation date."

    created_date = datetime.strptime(created_date_str, '%Y-%m-%d').date()
    today = date.today()
    
    # Calculate months since creation, with a minimum of 1 to avoid division by zero
    delta = relativedelta(today, created_date)
    months_since_creation = delta.years * 12 + delta.months
    if months_since_creation == 0:
        months_since_creation = 1

    allocated_amount = goal.get('allocated_amount', 0)
    if allocated_amount <= 0:
        return None, "Allocate funds to estimate completion."

    # Calculate average monthly savings for this goal
    average_monthly_savings = allocated_amount / months_since_creation
    
    if average_monthly_savings <= 0:
        return None, "No average monthly savings to estimate completion."

    months_needed = remaining / average_monthly_savings
    
    completion_date = today + relativedelta(months=int(months_needed))
    
    # Add remaining days
    remaining_days = (months_needed - int(months_needed)) * 30
    completion_date += timedelta(days=int(remaining_days))
    
    return completion_date, f"Estimated: {completion_date.strftime('%B %Y')}"

def calculate_monthly_savings(goal):
    """Calculate the monthly savings required to meet a goal by its target date."""
    if not goal.get('target_date'):
        return None, "No target date set."

    try:
        target_date = datetime.strptime(goal['target_date'], '%Y-%m-%d').date()
    except (ValueError, TypeError):
        return None, "Invalid target date format."

    today = date.today()
    remaining_amount = goal['target_amount'] - goal.get('allocated_amount', 0)
    
    if remaining_amount <= 0:
        return 0, "Goal already achieved."
    
    if target_date <= today:
        # Target date is in the past - show as overdue
        return remaining_amount, f"OVERDUE - Remaining: €{remaining_amount:,.2f}"

    delta = relativedelta(target_date, today)
    months_remaining = delta.years * 12 + delta.months + delta.days / 30.0

    if months_remaining <= 0:
        return remaining_amount, "Target date is this month."

    monthly_savings = remaining_amount / months_remaining
    return monthly_savings, f"€{monthly_savings:,.2f}/month"

def get_total_savings_available(state):
    """Get total savings available for allocation"""
    return state.budget_settings.get('savings_balance', 0)
def get_total_allocated(state):
    """Get total amount already allocated to goals"""
    goals = state.budget_settings.get('savings_goals', [])
    return sum(g.get('allocated_amount', 0) for g in goals)
def get_unallocated_savings(state):
    """Get savings not yet allocated to any goal"""
    total = get_total_savings_available(state)
    allocated = get_total_allocated(state)
    return max(total - allocated, 0)
def validate_allocation(state, goal_index, new_amount):
    """
    Validate if a new allocation amount is valid
    Returns: (is_valid, error_message, available_amount)
    """
    goals = state.budget_settings.get('savings_goals', [])
    
    if goal_index < 0 or goal_index >= len(goals):
        return False, "Invalid goal index", 0
    
    goal = goals[goal_index]
    old_allocation = goal.get('allocated_amount', 0)
    
    # Calculate what would be available if we remove this goal's current allocation
    total_savings = get_total_savings_available(state)
    other_allocations = sum(g.get('allocated_amount', 0) for i, g in enumerate(goals) if i != goal_index)
    available = total_savings - other_allocations
    
    if new_amount < 0:
        return False, "Allocation cannot be negative", available
    
    if new_amount > available:
        return False, f"Insufficient savings. Available: €{available:.2f}", available
    
    return True, "", available
def auto_distribute_savings(state):
    """
    Automatically distribute available savings across goals based on priority and need
    Returns: (success, message)
    """
    goals = state.budget_settings.get('savings_goals', [])
    
    if not goals:
        return False, "No goals to distribute savings to."
    
    total_savings = get_total_savings_available(state)
    
    if total_savings <= 0:
        return False, "No savings available to distribute."
    
    # Reset all allocations first
    for goal in goals:
        goal['allocated_amount'] = 0
    
    # Sort goals by priority and then by how close they are to completion
    priority_order = {'High': 3, 'Medium': 2, 'Low': 1}
    active_goals = [g for g in goals if g.get('allocated_amount', 0) < g['target_amount']]
    
    if not active_goals:
        return False, "All goals are already complete."
    
    # Sort by priority (high first) and then by percentage complete (higher first)
    active_goals.sort(
        key=lambda g: (
            priority_order.get(g.get('priority', 'Medium'), 2),
            g.get('allocated_amount', 0) / g['target_amount'] if g['target_amount'] > 0 else 0
        ),
        reverse=True
    )
    
    remaining_savings = total_savings
    
    # First pass: try to complete goals starting with highest priority
    for goal in active_goals:
        if remaining_savings <= 0:
            break
        
        needed = goal['target_amount'] - goal.get('allocated_amount', 0)
        allocation = min(needed, remaining_savings)
        goal['allocated_amount'] = goal.get('allocated_amount', 0) + allocation
        remaining_savings -= allocation
    
    return True, f"Distributed €{total_savings:.2f} across {len(active_goals)} goal(s)."

def generate_goals_report(state) -> str:
    """Generate a comprehensive goals report"""
    goals = state.budget_settings.get('savings_goals', [])
    
    total_savings = get_total_savings_available(state)
    total_allocated = get_total_allocated(state)
    unallocated = get_unallocated_savings(state)
    
    if not goals:
        report = f"{'='*80}\n"
        report += f"SAVINGS GOALS REPORT\n"
        report += f"{'='*80}\n\n"
        report += f"Total Savings Available: €{total_savings:,.2f}\n"
        report += f"No savings goals set. Create your first goal to start tracking!\n"
        return report
    
    report = f"{'='*80}\n"
    report += f"SAVINGS GOALS REPORT\n"
    report += f"{'='*80}\n\n"
    report += f"Generated: {date.today().strftime('%B %d, %Y')}\n"
    report += f"Note: The completion estimate is based on the average monthly allocation to the goal since its creation.\n"
    report += f"      If no funds are allocated, no estimate can be provided.\n\n"
    report += f"{'-'*80}\n\n"
    
    total_target = sum(g['target_amount'] for g in goals)
    
    active_goals = [g for g in goals if g.get('allocated_amount', 0) < g['target_amount']]
    completed_goals = [g for g in goals if g.get('allocated_amount', 0) >= g['target_amount']]
    
    report += f"SAVINGS SUMMARY\n"
    report += f"{'-'*80}\n"
    report += f"Total Savings Balance:        €{total_savings:>12,.2f}\n"
    report += f"Amount Allocated to Goals:    €{total_allocated:>12,.2f}\n"
    report += f"Unallocated Savings:          €{unallocated:>12,.2f}\n"
    report += f"\n"
    report += f"Total Goals:                  {len(goals)}\n"
    report += f"Active Goals:                 {len(active_goals)}\n"
    report += f"Completed Goals:              {len(completed_goals)}\n"
    report += f"Total Target Amount:          €{total_target:>12,.2f}\n"
    report += f"Overall Progress:             {(total_allocated/total_target*100) if total_target > 0 else 0:.1f}%\n\n"
    
    if unallocated > 0:
        report += f"⚠️  You have €{unallocated:.2f} in unallocated savings.\n"
        report += f"   Consider allocating this to your goals!\n\n"
    
    if active_goals:
        report += f"{'='*80}\n"
        report += f"ACTIVE GOALS\n"
        report += f"{'='*80}\n\n"
        
        for goal in active_goals:
            progress = calculate_goal_progress(goal, goal.get('allocated_amount', 0))
            completion_date, completion_msg = estimate_completion_date(goal)
            monthly_savings, monthly_savings_str = calculate_monthly_savings(goal)
    
            report += f"Goal: {goal['name']}\n"
            if goal.get('description'):
                report += f"Description: {goal['description']}\n"
            report += f"{'-'*40}\n"
            report += f"Target Amount:         €{goal['target_amount']:,.2f}\n"
            report += f"Allocated Savings:     €{goal.get('allocated_amount', 0):,.2f}\n"
            report += f"Still Needed:          €{progress['remaining']:,.2f}\n"
            report += f"Progress:              {progress['progress_pct']:.1f}%\n"
    
            # Show target date and required monthly savings if set
            if goal.get('target_date'):
                report += f"Target Date:           {goal['target_date']}\n"
                if monthly_savings is not None:
                    report += f"Required Monthly:      {monthly_savings_str}\n"
    
            report += f"Completion Estimate:   {completion_msg}\n"
    
            # Progress bar
            bar_length = 40
            filled = int(bar_length * progress['progress_pct'] / 100)
            bar = '█' * filled + '░' * (bar_length - filled)
            report += f"[{bar}] {progress['progress_pct']:.1f}%\n"
            report += f"\n"
    
    if completed_goals:
        report += f"{'='*80}\n"
        report += f"COMPLETED GOALS\n"
        report += f"{'='*80}\n\n"
        
        for goal in completed_goals:
            report += f"✓ {goal['name']} - €{goal['target_amount']:,.2f}\n"
            if goal.get('completion_date'):
                report += f"  Completed: {goal['completion_date']}\n"
            report += f"\n"
    
    return report

def calculate_all_goals_summary(state):
    """Calculate summary statistics for all goals"""
    goals = state.budget_settings.get('savings_goals', [])
    
    total_savings = get_total_savings_available(state)
    total_allocated = get_total_allocated(state)
    unallocated = get_unallocated_savings(state)
    
    if not goals:
        return {
            'total_goals': 0,
            'active_goals': 0,
            'completed_goals': 0,
            'total_target': 0,
            'total_allocated': 0,
            'overall_progress': 0,
            'total_savings': total_savings,
            'unallocated': unallocated
        }
    
    total_target = sum(g['target_amount'] for g in goals)
    active = len([g for g in goals if g.get('allocated_amount', 0) < g['target_amount']])
    completed = len([g for g in goals if g.get('allocated_amount', 0) >= g['target_amount']])
    
    return {
        'total_goals': len(goals),
        'active_goals': active,
        'completed_goals': completed,
        'total_target': total_target,
        'total_allocated': total_allocated,
        'overall_progress': (total_allocated / total_target * 100) if total_target > 0 else 0,
        'total_savings': total_savings,
        'unallocated': unallocated
    }