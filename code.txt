from finance_tracker.app import main

if __name__ == "__main__":
    main()import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import json
from datetime import datetime, date
from pathlib import Path
import calendar
from dateutil.relativedelta import relativedelta
import random

# Charting
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np


class FinanceTracker:
    def __init__(self, root):
        self.root = root
        self.root.title("Personal Finance Tracker")
        self.root.minsize(1250, 750)

        # Data file
        self.data_file = Path("finance_data.json")
        self.load_data()

        # UI Styling
        style = ttk.Style()
        style.configure("Treeview.Heading", font=('Arial', 10, 'bold'))
        style.configure("TLabel", font=('Arial', 10))
        style.configure("TButton", font=('Arial', 10))
        style.configure("TRadiobutton", font=('Arial', 10))
        style.configure("Help.TButton", font=('Arial', 12, 'bold'))

        # Main frame to hold the notebook and the help button
        main_frame = ttk.Frame(root)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)

        # Create UI
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill='both', expand=True)

        self.create_widgets()
        self.refresh_transaction_list()
        self.refresh_fixed_costs_tree()
        self.refresh_balance_entries()

        # Help Button
        help_button_frame = ttk.Frame(main_frame)
        help_button_frame.pack(fill='x', pady=(5, 0))
        self.help_button = ttk.Button(help_button_frame, text="?", command=self.show_help_window, style="Help.TButton", width=3)
        self.help_button.pack(side='right')

    def load_data(self):
        """Load data from JSON file or create new structure"""
        if self.data_file.exists():
            with open(self.data_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.expenses = data.get('expenses', [])
                self.incomes = data.get('incomes', [])
                self.budget_settings = data.get('budget_settings', {})
                self.categories = data.get('categories', {})
        else:
            self.expenses = []
            self.incomes = []
            self.budget_settings = {}
            self.categories = {}

        if 'fixed_costs' not in self.budget_settings:
            self.budget_settings['fixed_costs'] = []
        if 'monthly_income' not in self.budget_settings:
            self.budget_settings['monthly_income'] = 0
        if 'bank_account_balance' not in self.budget_settings:
            self.budget_settings['bank_account_balance'] = 0
        if 'savings_balance' not in self.budget_settings:
            self.budget_settings['savings_balance'] = 0
        if 'investment_balance' not in self.budget_settings:
            self.budget_settings['investment_balance'] = 0
        if 'wallet_balance' not in self.budget_settings:
            self.budget_settings['wallet_balance'] = 0
        if 'daily_savings_goal' not in self.budget_settings:
            self.budget_settings['daily_savings_goal'] = 0
        if 'money_lent_balance' not in self.budget_settings:
            self.budget_settings['money_lent_balance'] = 0

        if 'Expense' not in self.categories or not self.categories['Expense']:
            self.categories['Expense'] = ["Food", "Transportation", "Entertainment", "Utilities", "Shopping",
                                          "Healthcare", "Money Lent", "Other"]
        if 'Income' not in self.categories or not self.categories['Income']:
            self.categories['Income'] = ["Salary", "Side Gig", "Bonus", "Gift", "Investment", "Other"]

        if 'category_budgets' not in self.budget_settings:
            self.budget_settings['category_budgets'] = {'Expense': {}, 'Income': {}}

    def save_data(self):
        """Save data to JSON file"""
        data = {
            'expenses': self.expenses,
            'incomes': self.incomes,
            'budget_settings': self.budget_settings,
            'categories': self.categories
        }
        with open(self.data_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4)

    # =========================
    # UI Creation
    # =========================
    def create_widgets(self):
        """Create all UI elements"""
        self.add_transaction_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.add_transaction_tab, text="Add Transaction")
        self.create_add_transaction_tab()

        self.view_transactions_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.view_transactions_tab, text="View Transactions")
        self.create_view_transactions_tab()

        self.transfers_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.transfers_tab, text="Transfers")
        self.create_transfers_tab()

        self.reports_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.reports_tab, text="Reports")
        self.create_reports_tab()

        self.budget_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.budget_tab, text="Budget & Settings")
        self.create_budget_tab()

        # NEW: Separate Budgets tab for category budget sliders
        self.budgets_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.budgets_tab, text="Budgets")
        self.create_budgets_tab()

        self.projection_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.projection_tab, text="Projection")
        self.create_projection_tab()

    def show_help_window(self):
        """Creates and displays the help pop-up window."""
        help_win = tk.Toplevel(self.root)
        help_win.title("Help & Instructions")
        help_win.geometry("800x600")
        help_win.minsize(600, 400)

        main_frame = ttk.Frame(help_win, padding=10)
        main_frame.pack(fill='both', expand=True)

        text_frame = ttk.Frame(main_frame)
        text_frame.pack(fill='both', expand=True)

        help_text_widget = tk.Text(text_frame, wrap='word', font=('Arial', 10), spacing3=5)
        scrollbar = ttk.Scrollbar(text_frame, orient='vertical', command=help_text_widget.yview)
        help_text_widget.configure(yscrollcommand=scrollbar.set)

        scrollbar.pack(side='right', fill='y')
        help_text_widget.pack(side='left', fill='both', expand=True)

        # --- Define text styles ---
        help_text_widget.tag_configure('h1', font=('Arial', 16, 'bold'), spacing1=10)
        help_text_widget.tag_configure('h2', font=('Arial', 12, 'bold'), spacing1=10)
        help_text_widget.tag_configure('bold', font=('Arial', 10, 'bold'))
        help_text_widget.tag_configure('italic', font=('Arial', 10, 'italic'))

        # --- Help Content ---
        help_content = [
            ("Core Concepts", "h1"),
            ("To use this tracker effectively, it's important to understand these key ideas:", "italic"),

            ("\n•  Assets (Your Accounts):", "bold"),
            (" These are the containers that hold your money. The main ones are 'Bank', 'Wallet', 'Savings', 'Investments', and 'Money Lent'. You can see their balances in the 'Budget & Settings' tab.", "none"),

            ("\n•  Transactions (Income/Expense):", "bold"),
            (" A transaction is any money that ENTERS or LEAVES your financial world. A salary is income; buying groceries is an expense. These change your total net worth.", "none"),

            ("\n•  Transfers:", "bold"),
            (" A transfer is moving money BETWEEN your own accounts. Withdrawing cash from an ATM is a transfer from 'Bank' to 'Wallet'. A transfer does NOT change your total net worth; it just moves it around.", "none"),

            ("\nHow To Use Each Tab", "h1"),

            ("\nAdd Transaction Tab", "h2"),
            ("Use this tab when you receive money from an external source or spend money on a good or service.", "none"),
            ("\n1.  ", "none"), ("Choose 'Expense' or 'Income'.", "bold"),
            ("\n2.  Fill in the date, amount, category, and a brief description.", "none"),
            ("\n3.  Click 'Add Transaction'. This will be logged and used in all reports.", "none"),

            ("\nView Transactions Tab", "h2"),
            ("This is your history book. It shows all the transactions you've logged for a specific month.", "none"),
            ("\n•  ", "none"), ("Filter by Month:", "bold"), (" Enter a month in YYYY-MM format to see only transactions from that period.", "none"),
            ("\n•  ", "none"), ("Summary:", "bold"), (" At the bottom, you can see your total income, total expenses, and the net result for the filtered month.", "none"),
            ("\n•  ", "none"), ("Modify/Delete:", "bold"), (" Select a transaction in the list and click the appropriate button to edit its details or remove it permanently.", "none"),

            ("\nTransfers Tab", "h2"),
            ("Use this tab ONLY when moving money between your own accounts. This is NOT for recording spending.", "none"),
            ("\n•  ", "none"), ("Example: Lending Money to a Friend:", "bold"),
            ("\n    - From Account: Bank", "none"),
            ("\n    - To Account: Money Lent", "none"),
            ("\n    - Amount: 50", "none"),
            ("\n•  ", "none"), ("Result:", "bold"), (" Your Bank Balance will decrease, and your Money Lent Balance will increase. No income or expense is recorded because it's still your asset.", "none"),
            ("\n   This action will automatically update the balances in the 'Budget & Settings' tab.", "italic"),
            ("\n   ", "none"), ("Important:", "bold"), (" Only perform this transfer when the money has actually left one of your accounts (e.g., your bank account was charged). If you lend cash from your wallet, the transfer should be from 'Wallet' to 'Money Lent'.", "none"),

            ("\nReports Tab", "h2"),
            ("Visualize your finances with a pie chart to see where your money is going or coming from.", "none"),
            ("\n•  ", "none"), ("Generate Chart:", "bold"), (" Select the month, type (Expenses/Incomes), and other options, then click the button. The chart shows the proportion of each category.", "none"),

            ("\nBudget & Settings Tab", "h2"),
            ("This is your control center.", "none"),
            ("\n•  ", "none"), ("Balances (Bank, Wallet, etc.):", "bold"), (" These are snapshots of your assets. You must update them manually after you spend money or after a transfer. For the tracker to be accurate, these numbers should reflect reality.", "none"),
            ("\n•  ", "none"), ("Fixed Monthly Costs:", "bold"), (" Add recurring expenses that are the same each month, like rent or subscriptions. These are automatically included in your monthly expense totals.", "none"),
            ("\n•  ", "none"), ("Manage Categories:", "bold"), (" Customize the dropdown lists for income and expense categories.", "none"),
            ("\n•  ", "none"), ("Daily Budget Report:", "bold"), (" This tool calculates a 'Daily Spending Target' based on your income minus your fixed costs and savings goals. The 'Cumulative' column shows if you are on track or overspending over time.", "none"),

            ("\nBudgets Tab", "h2"),
            ("Set category budget limits as percentages of your monthly flexible budget.", "none"),
            ("\n•  ", "none"), ("Auto-Assign From Expenses:", "bold"), (" For a selected month, set budgets to match actual spending so far. If there's budget left, you'll be notified to assign it manually.", "none"),

            ("\nProjection Tab", "h2"),
            ("Forecast your financial future.", "none"),
            ("\n•  ", "none"), ("Logic:", "bold"), (" The projection takes your TOTAL current assets (Bank + Wallet + Savings + Investments + Money Lent) and calculates their future value by adding your 'Daily Savings Goal' for each day of the projection period.", "none"),

            ("\nCommon Scenarios", "h1"),

            ("\nHow do I handle a cash purchase?", "h2"),
            ("This is a two-step process:", "none"),
            ("\n1.  ", "none"), ("Record the Expense:", "bold"), (" Go to the 'Add Transaction' tab and log the expense just like you would with a card purchase (e.g., Amount: 5, Category: Food). This is for your budget.", "none"),
            ("\n2.  ", "none"), ("Update the Asset:", "bold"), (" Go to the 'Budget & Settings' tab and manually decrease your 'Wallet Balance' by the amount you spent. (e.g., if it was 50, change it to 45).", "none"),

            ("\nWhat's the difference between 'Net' and 'Cumulative Deficit'?", "h2"),
            ("\n•  ", "none"), ("'Net' (on View Transactions tab):", "bold"), (" This is your simple, final result for the month: Total Income - Total Expenses. It tells you if you saved money or not overall.", "none"),
            ("\n•  ", "none"), ("'Cumulative Deficit' (in Daily Budget Report):", "bold"), (" This is a BUDGETING metric. It tracks how well you are sticking to your daily flexible spending target.", "none"),
        ]

        for text, style in help_content:
            if style == "none":
                help_text_widget.insert(tk.END, text)
            else:
                help_text_widget.insert(tk.END, text, style)

        help_text_widget.config(state='disabled')  # Make it read-only

    # =========================
    # Reports
    # =========================
    def create_reports_tab(self):
        """Create the UI for the reports tab with multiple chart options."""
        main_frame = ttk.Frame(self.reports_tab, padding="10")
        main_frame.pack(fill='both', expand=True)
        main_frame.rowconfigure(1, weight=1)
        main_frame.columnconfigure(0, weight=1)

        controls_frame = ttk.LabelFrame(main_frame, text="Chart Options", padding="10")
        controls_frame.grid(row=0, column=0, sticky='ew', pady=5)

        # --- Top Row of Controls ---
        top_controls_row = ttk.Frame(controls_frame)
        top_controls_row.pack(fill='x', expand=True, pady=(0, 10))

        # Chart Style Selection (Pie, Bar, etc.)
        style_frame = ttk.Frame(top_controls_row)
        style_frame.pack(side='left', padx=(0, 20))
        ttk.Label(style_frame, text="Chart Style:").pack(side='left', anchor='n')
        self.report_style_var = tk.StringVar(value="Pie Chart")
        ttk.Radiobutton(style_frame, text="Pie Chart", variable=self.report_style_var, value="Pie Chart",
                        command=self._update_report_controls_visibility).pack(anchor='w')
        ttk.Radiobutton(style_frame, text="Historical Bar Chart", variable=self.report_style_var, value="Bar Chart",
                        command=self._update_report_controls_visibility).pack(anchor='w')

        # Transaction Type Selection (Income/Expense)
        type_frame = ttk.Frame(top_controls_row)
        type_frame.pack(side='left', padx=(0, 20))
        ttk.Label(type_frame, text="Data Type:").pack(side='left')
        self.chart_type_var = tk.StringVar(value="Expense")
        ttk.Radiobutton(type_frame, text="Expenses", variable=self.chart_type_var, value="Expense",
                        command=self._update_report_options_ui).pack(side='left')
        ttk.Radiobutton(type_frame, text="Incomes", variable=self.chart_type_var, value="Income",
                        command=self._update_report_options_ui).pack(side='left', padx=5)

        # Dynamic controls
        self.pie_chart_controls = ttk.Frame(top_controls_row)
        self.pie_chart_controls.pack(side='left', padx=(0, 15))
        ttk.Label(self.pie_chart_controls, text="Select Month:").pack(side='left')
        self.chart_month_entry = ttk.Entry(self.pie_chart_controls, width=15)
        self.chart_month_entry.insert(0, datetime.now().strftime("%Y-%m"))
        self.chart_month_entry.pack(side='left', padx=5)
        ttk.Label(self.pie_chart_controls, text="Display As:").pack(side='left', padx=(10, 0))
        self.chart_value_type_var = tk.StringVar(value="Percentage")
        ttk.Radiobutton(self.pie_chart_controls, text="%", variable=self.chart_value_type_var,
                        value="Percentage").pack(side='left')
        ttk.Radiobutton(self.pie_chart_controls, text="€", variable=self.chart_value_type_var,
                        value="Total").pack(side='left', padx=5)

        self.bar_chart_controls = ttk.Frame(top_controls_row)
        ttk.Label(self.bar_chart_controls, text="Number of Months:").pack(side='left')
        self.history_months_entry = ttk.Entry(self.bar_chart_controls, width=10)
        self.history_months_entry.insert(0, "6")
        self.history_months_entry.pack(side='left', padx=5)

        # --- Bottom Row ---
        bottom_controls_row = ttk.Frame(controls_frame)
        bottom_controls_row.pack(fill='x', expand=True)

        self.fixed_item_frame = ttk.Frame(bottom_controls_row)
        self.fixed_item_frame.pack(side='left', padx=(0, 15))
        self.include_fixed_costs_var = tk.BooleanVar(value=False)
        self.fixed_costs_checkbutton = ttk.Checkbutton(self.fixed_item_frame, text="Include Fixed Costs",
                                                       variable=self.include_fixed_costs_var)
        self.include_base_income_var = tk.BooleanVar(value=False)
        self.base_income_checkbutton = ttk.Checkbutton(self.fixed_item_frame, text="Include Base Income",
                                                       variable=self.include_base_income_var)
        self._update_report_options_ui()

        self.show_budget_lines_var = tk.BooleanVar(value=False)
        self.budget_lines_checkbutton = ttk.Checkbutton(bottom_controls_row, text="Show Budget Limits",
                                                        variable=self.show_budget_lines_var)
        self.budget_lines_checkbutton.pack(side='left', padx=(0, 15))

        spacer = ttk.Frame(bottom_controls_row)
        spacer.pack(side='left', fill='x', expand=True)

        ttk.Button(bottom_controls_row, text="Generate Chart", command=self.generate_report).pack(side='right')

        self.chart_frame = ttk.Frame(main_frame)
        self.chart_frame.grid(row=1, column=0, sticky='nsew', pady=10)
        self.canvas = None

        self._update_report_controls_visibility()

    def _update_report_controls_visibility(self):
        """Shows or hides UI elements based on the selected chart style."""
        style = self.report_style_var.get()
        # Forget all dynamic controls first
        self.pie_chart_controls.pack_forget()
        self.bar_chart_controls.pack_forget()
        self.budget_lines_checkbutton.pack_forget()

        if style == "Pie Chart":
            self.pie_chart_controls.pack(side='left', padx=(0, 15))
            self.budget_lines_checkbutton.pack(side='left', padx=(0, 15))
        elif style == "Bar Chart":
            self.bar_chart_controls.pack(side='left', padx=(0, 15))

    def generate_report(self):
        """Dispatcher function that calls the correct chart generation method."""
        style = self.report_style_var.get()
        if self.canvas:
            self.canvas.get_tk_widget().destroy()
            self.canvas = None

        if style == "Pie Chart":
            self.generate_pie_chart()
        elif style == "Bar Chart":
            self.generate_history_chart()

    def _update_report_options_ui(self):
        chart_type = self.chart_type_var.get()
        self.fixed_costs_checkbutton.pack_forget()
        self.base_income_checkbutton.pack_forget()
        if chart_type == "Expense":
            self.fixed_costs_checkbutton.pack()
        else:
            self.base_income_checkbutton.pack()

    def generate_history_chart(self):
        """Generates and displays a bar chart of historical data with a trend line."""
        try:
            num_months = int(self.history_months_entry.get())
            if num_months <= 1:
                messagebox.showerror("Error", "Number of months must be greater than 1 for a historical chart.")
                return
        except ValueError:
            messagebox.showerror("Error", "Invalid number of months. Please enter an integer.")
            return

        chart_type = self.chart_type_var.get()

        if chart_type == "Expense":
            data = self.expenses
            title = f"Historical Expenses for the Last {num_months} Months"
            fixed_value = sum(fc['amount'] for fc in self.budget_settings.get('fixed_costs', [])) if self.include_fixed_costs_var.get() else 0
        else:  # Income
            data = self.incomes
            title = f"Historical Incomes for the Last {num_months} Months"
            fixed_value = self.budget_settings.get('monthly_income', 0) if self.include_base_income_var.get() else 0

        # Aggregate data by month
        today = date.today()
        monthly_totals = {}
        for i in range(num_months - 1, -1, -1):
            month_date = today - relativedelta(months=i)
            month_key = month_date.strftime("%Y-%m")
            monthly_totals[month_key] = fixed_value

        for item in data:
            item_month = item['date'][:7]
            if item_month in monthly_totals:
                monthly_totals[item_month] += item['amount']

        if not any(monthly_totals.values()):
            messagebox.showinfo("No Data", f"No data to display for the selected period.")
            return

        labels = list(monthly_totals.keys())
        values = list(monthly_totals.values())

        # Create the plot
        fig = Figure(figsize=(10, 6), dpi=100)
        ax = fig.add_subplot(111)

        ax.bar(labels, values, label='Monthly Totals')

        # Calculate and plot the trend line
        if len(values) > 1:
            x_axis = np.arange(len(labels))
            slope, intercept = np.polyfit(x_axis, values, 1)
            trend_line = slope * x_axis + intercept
            ax.plot(labels, trend_line, color='red', linestyle='--', label='Trend Line')

        ax.set_title(title)
        ax.set_ylabel("Total Amount (€)")
        ax.legend()
        plt.setp(ax.get_xticklabels(), rotation=45, ha='right')
        fig.tight_layout()

        # Embed the plot in Tkinter
        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill='both', expand=True)

    def generate_pie_chart(self):
        month_str = self.chart_month_entry.get()
        chart_type = self.chart_type_var.get()
        value_type = self.chart_value_type_var.get()
        try:
            datetime.strptime(month_str, "%Y-%m")
        except ValueError:
            messagebox.showerror("Error", "Invalid month format. Please use YYYY-MM.")
            return

        category_totals = {}
        if chart_type == "Expense":
            data = self.expenses
            title = f"Expenses for {month_str}"
            if self.include_fixed_costs_var.get():
                total_fixed_costs = sum(fc['amount'] for fc in self.budget_settings.get('fixed_costs', []))
                if total_fixed_costs > 0:
                    category_totals['Fixed Costs'] = total_fixed_costs
        else:
            data = self.incomes
            title = f"Incomes for {month_str}"
            if self.include_base_income_var.get():
                base_income = self.budget_settings.get('monthly_income', 0)
                if base_income > 0:
                    category_totals['Base Income'] = base_income

        month_data = [item for item in data if item['date'].startswith(month_str)]
        for item in month_data:
            category = item['category']
            amount = item['amount']
            category_totals[category] = category_totals.get(category, 0) + amount

        if not category_totals:
            messagebox.showinfo("No Data", f"No data to display for {month_str}.")
            return

        labels = list(category_totals.keys())
        sizes = list(category_totals.values())

        fig = Figure(figsize=(8, 6), dpi=100)
        ax = fig.add_subplot(111)

        if value_type == "Percentage":
            autopct = '%1.1f%%'
        else:
            def absolute_value(val):
                a = (val / 100.0) * sum(sizes)
                return f'€{a:.2f}'
            autopct = absolute_value

        wedges, texts, autotexts = ax.pie(sizes, autopct=autopct, startangle=140, textprops=dict(color="w"))
        ax.axis('equal')
        ax.set_title(title)
        ax.legend(wedges, labels, title="Categories", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))
        plt.setp(autotexts, size=8, weight="bold")

        if self.show_budget_lines_var.get() and chart_type == "Expense":
            expense_budgets = self.budget_settings.get('category_budgets', {}).get('Expense', {})
            budget_info = []
            net_available = self._compute_net_available_for_spending(month_str)

            for category in labels:
                percent_limit = expense_budgets.get(category, 0)
                if percent_limit > 0 and net_available > 0 and category in category_totals:
                    actual = category_totals[category]
                    budget_amount = (percent_limit / 100.0) * net_available
                    used_pct = (actual / budget_amount) * 100 if budget_amount > 0 else 0
                    remaining = max(budget_amount - actual, 0)
                    budget_info.append(f"{category}: {used_pct:.0f}% of budget, left: €{remaining:.2f}")

            if budget_info:
                budget_text = "\n".join(budget_info)
                ax.text(1.5, 0.5, "Budget Status:\n" + budget_text,
                        transform=ax.transAxes, fontsize=9, verticalalignment='center',
                        bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

        fig.tight_layout()
        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill='both', expand=True)

    # =========================
    # Add Transaction
    # =========================
    def create_add_transaction_tab(self):
        main_frame = ttk.Frame(self.add_transaction_tab, padding="20")
        main_frame.pack(fill='both', expand=True)

        form_frame = ttk.Frame(main_frame)
        form_frame.pack(anchor='center')

        ttk.Label(form_frame, text="Transaction Type:").grid(row=0, column=0, sticky='w', pady=10)
        self.transaction_type_var = tk.StringVar(value="Expense")
        type_frame = ttk.Frame(form_frame)
        type_frame.grid(row=0, column=1, sticky='w', pady=5)
        ttk.Radiobutton(type_frame, text="Expense", variable=self.transaction_type_var,
                        value="Expense", command=self.update_categories).pack(side='left', padx=5)
        ttk.Radiobutton(type_frame, text="Income", variable=self.transaction_type_var,
                        value="Income", command=self.update_categories).pack(side='left', padx=5)

        ttk.Label(form_frame, text="Date:").grid(row=1, column=0, sticky='w', pady=5)
        self.date_entry = ttk.Entry(form_frame, width=30)
        self.date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.date_entry.grid(row=1, column=1, pady=5, sticky='w')
        ttk.Label(form_frame, text="(YYYY-MM-DD)", foreground="gray").grid(row=1, column=2, sticky='w', padx=5)

        ttk.Label(form_frame, text="Amount:").grid(row=2, column=0, sticky='w', pady=5)
        self.amount_entry = ttk.Entry(form_frame, width=30)
        self.amount_entry.grid(row=2, column=1, pady=5, sticky='w')

        ttk.Label(form_frame, text="Category:").grid(row=3, column=0, sticky='w', pady=5)
        self.category_var = tk.StringVar()
        self.category_combo = ttk.Combobox(form_frame, textvariable=self.category_var, width=28, state='readonly')
        self.category_combo.grid(row=3, column=1, pady=5, sticky='w')
        self.update_categories()

        ttk.Label(form_frame, text="Description:").grid(row=4, column=0, sticky='w', pady=5)
        self.description_entry = ttk.Entry(form_frame, width=30)
        self.description_entry.grid(row=4, column=1, pady=5, sticky='w')

        ttk.Button(form_frame, text="Add Transaction", command=self.add_transaction).grid(
            row=5, column=1, pady=20, sticky='w')

    def update_categories(self):
        transaction_type = self.transaction_type_var.get()
        categories = self.categories.get(transaction_type, [])
        self.category_combo.config(values=categories)
        if categories:
            self.category_combo.set(categories[0])
        else:
            self.category_combo.set("")

    def add_transaction(self):
        try:
            date_str = self.date_entry.get()
            datetime.strptime(date_str, "%Y-%m-%d")
            amount = float(self.amount_entry.get())
            category = self.category_var.get()
            description = self.description_entry.get()
            trans_type = self.transaction_type_var.get()
            if not category:
                messagebox.showerror("Error", "Please select a category.")
                return

            # Add a unique ID to each transaction
            trans_id = f"{datetime.now().timestamp()}-{random.randint(1000, 9999)}"
            transaction = {'id': trans_id, 'date': date_str, 'amount': amount, 'category': category, 'description': description}

            if trans_type == "Expense":
                self.expenses.append(transaction)
            else:
                self.incomes.append(transaction)

            self.save_data()
            self.amount_entry.delete(0, tk.END)
            self.description_entry.delete(0, tk.END)
            messagebox.showinfo("Success", f"{trans_type} added successfully!")
            self.refresh_transaction_list()
        except ValueError:
            messagebox.showerror("Error", "Invalid amount or date format (YYYY-MM-DD).")

    # =========================
    # View Transactions
    # =========================
    def create_view_transactions_tab(self):
        frame = ttk.Frame(self.view_transactions_tab, padding="20")
        frame.pack(fill='both', expand=True)

        filter_frame = ttk.Frame(frame)
        filter_frame.pack(fill='x', pady=10)

        ttk.Label(filter_frame, text="Filter by month:").pack(side='left', padx=5)
        self.month_filter = ttk.Entry(filter_frame, width=15)
        self.month_filter.insert(0, datetime.now().strftime("%Y-%m"))
        self.month_filter.pack(side='left', padx=5)
        ttk.Button(filter_frame, text="Refresh", command=self.refresh_transaction_list).pack(side='left', padx=10)

        tree_frame = ttk.Frame(frame)
        tree_frame.pack(fill='both', expand=True, pady=10)

        columns = ('ID', 'Date', 'Type', 'Amount', 'Category', 'Description')
        self.transaction_tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=15)
        for col in columns:
            self.transaction_tree.heading(col, text=col)
            width = 120
            if col == 'Amount': width = 100
            if col == 'Description': width = 250
            if col == 'Type': width = 80
            self.transaction_tree.column(col, width=width, anchor='w')

        # Hide the ID column
        self.transaction_tree.column('ID', width=0, stretch=tk.NO)

        self.transaction_tree.tag_configure('expense', foreground='red')
        self.transaction_tree.tag_configure('income', foreground='green')
        self.transaction_tree.pack(side='left', fill='both', expand=True)
        scrollbar = ttk.Scrollbar(tree_frame, orient='vertical', command=self.transaction_tree.yview)
        scrollbar.pack(side='right', fill='y')
        self.transaction_tree.configure(yscrollcommand=scrollbar.set)

        button_frame = ttk.Frame(frame)
        button_frame.pack(fill='x', pady=5)
        spacer = ttk.Frame(button_frame)
        spacer.pack(side='left', expand=True, fill='x')
        ttk.Button(button_frame, text="Modify Selected", command=self.open_modify_window).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Delete Selected", command=self.delete_transaction).pack(side='left')

        self.summary_label = ttk.Label(frame, text="", font=('Arial', 10, 'bold'))
        self.summary_label.pack(pady=10, fill='x')

    def refresh_transaction_list(self):
        for item in self.transaction_tree.get_children():
            self.transaction_tree.delete(item)
        filter_month = self.month_filter.get()
        all_transactions = []
        for e in self.expenses:
            if e['date'].startswith(filter_month):
                all_transactions.append({**e, 'type': 'Expense'})
        for i in self.incomes:
            if i['date'].startswith(filter_month):
                all_transactions.append({**i, 'type': 'Income'})
        all_transactions.sort(key=lambda x: x['date'])

        for trans in all_transactions:
            tag = 'expense' if trans['type'] == 'Expense' else 'income'
            trans_id = trans.get('id', '')
            self.transaction_tree.insert('', 'end', values=(
                trans_id, trans['date'], trans['type'], f"€{trans['amount']:.2f}",
                trans['category'], trans['description']), tags=(tag,))
        self.update_summary()

    def update_summary(self):
        filter_month = self.month_filter.get()
        base_income = self.budget_settings.get('monthly_income', 0)

        monthly_flexible_incomes = [i['amount'] for i in self.incomes if i['date'].startswith(filter_month)]
        total_flexible_income = sum(monthly_flexible_incomes)
        total_income = base_income + total_flexible_income

        monthly_expenses = [e['amount'] for e in self.expenses if e['date'].startswith(filter_month)]
        total_flexible_expenses = sum(monthly_expenses)

        total_fixed_costs = sum(fc['amount'] for fc in self.budget_settings.get('fixed_costs', []))
        total_expenses = total_flexible_expenses + total_fixed_costs

        net = total_income - total_expenses

        summary_text = (f"Total Income: €{total_income:.2f}  |  "
                        f"Total Expenses: €{total_expenses:.2f}  |  "
                        f"Flexible Costs Incurred: €{total_flexible_expenses:.2f}  |  "
                        f"Net: €{net:.2f}")

        self.summary_label.config(text=summary_text)

    def delete_transaction(self):
        selected_item = self.transaction_tree.selection()
        if not selected_item:
            messagebox.showwarning("Warning", "Please select a transaction to delete.")
            return

        if messagebox.askyesno("Confirm", "Are you sure you want to delete the selected transaction?"):
            item_values = self.transaction_tree.item(selected_item[0])['values']
            trans_id = item_values[0]
            trans_type = item_values[2]

            target_list = self.expenses if trans_type == 'Expense' else self.incomes
            transaction_found = False

            for i, trans in enumerate(target_list):
                if trans.get('id') == trans_id:
                    del target_list[i]
                    transaction_found = True
                    break

            # Fallback for old data without IDs
            if not transaction_found:
                date_str, _, amount_str, category, desc = item_values[1:]
                target_transaction = {
                    'date': date_str,
                    'amount': float(amount_str.replace('€', '')),
                    'category': category,
                    'description': desc
                }
                try:
                    target_list.remove(target_transaction)
                except ValueError:
                    messagebox.showerror("Error", "Could not delete the transaction (fallback failed). It might have been modified externally.")
                    return

            self.save_data()
            self.refresh_transaction_list()

    def open_modify_window(self):
        """Opens a new window to modify the selected transaction."""
        selected_item = self.transaction_tree.selection()
        if not selected_item:
            messagebox.showwarning("Warning", "Please select a transaction to modify.")
            return

        item_values = self.transaction_tree.item(selected_item[0])['values']
        trans_id = item_values[0]

        original_transaction = None
        original_list_name = None

        for t in self.expenses:
            if t.get('id') == trans_id:
                original_transaction = t
                original_list_name = 'Expense'
                break
        if not original_transaction:
            for t in self.incomes:
                if t.get('id') == trans_id:
                    original_transaction = t
                    original_list_name = 'Income'
                    break

        if not original_transaction:
            messagebox.showerror("Error", "Could not find the selected transaction in the data. It may be legacy data without an ID.")
            return

        modify_win = tk.Toplevel(self.root)
        modify_win.title("Modify Transaction")
        modify_win.transient(self.root)
        modify_win.grab_set()

        form_frame = ttk.Frame(modify_win, padding="20")
        form_frame.pack(fill='both', expand=True)

        ttk.Label(form_frame, text="Transaction Type:").grid(row=0, column=0, sticky='w', pady=10)
        mod_transaction_type_var = tk.StringVar(value=original_list_name)
        type_frame = ttk.Frame(form_frame)
        type_frame.grid(row=0, column=1, sticky='w', pady=5)

        mod_category_var = tk.StringVar(value=original_transaction.get('category', ''))
        mod_category_combo = ttk.Combobox(form_frame, textvariable=mod_category_var, width=28, state='readonly')

        def update_mod_categories():
            trans_type = mod_transaction_type_var.get()
            categories = self.categories.get(trans_type, [])
            mod_category_combo.config(values=categories)
            if categories:
                if mod_category_var.get() in categories:
                    mod_category_combo.set(mod_category_var.get())
                else:
                    mod_category_combo.set(categories[0])
            else:
                mod_category_combo.set("")

        ttk.Radiobutton(type_frame, text="Expense", variable=mod_transaction_type_var,
                        value="Expense", command=update_mod_categories).pack(side='left', padx=5)
        ttk.Radiobutton(type_frame, text="Income", variable=mod_transaction_type_var,
                        value="Income", command=update_mod_categories).pack(side='left', padx=5)

        ttk.Label(form_frame, text="Date:").grid(row=1, column=0, sticky='w', pady=5)
        mod_date_entry = ttk.Entry(form_frame, width=30)
        mod_date_entry.insert(0, original_transaction.get('date', ''))
        mod_date_entry.grid(row=1, column=1, pady=5, sticky='w')

        ttk.Label(form_frame, text="Amount:").grid(row=2, column=0, sticky='w', pady=5)
        mod_amount_entry = ttk.Entry(form_frame, width=30)
        mod_amount_entry.insert(0, original_transaction.get('amount', ''))
        mod_amount_entry.grid(row=2, column=1, pady=5, sticky='w')

        ttk.Label(form_frame, text="Category:").grid(row=3, column=0, sticky='w', pady=5)
        mod_category_combo.grid(row=3, column=1, pady=5, sticky='w')
        update_mod_categories()  # Initial

        ttk.Label(form_frame, text="Description:").grid(row=4, column=0, sticky='w', pady=5)
        mod_description_entry = ttk.Entry(form_frame, width=30)
        mod_description_entry.insert(0, original_transaction.get('description', ''))
        mod_description_entry.grid(row=4, column=1, pady=5, sticky='w')

        def save_changes():
            try:
                new_date = mod_date_entry.get()
                datetime.strptime(new_date, "%Y-%m-%d")
                new_amount = float(mod_amount_entry.get())
                new_category = mod_category_var.get()
                new_description = mod_description_entry.get()
                new_type = mod_transaction_type_var.get()

                if not new_category:
                    messagebox.showerror("Error", "Please select a category.", parent=modify_win)
                    return

                # Find the transaction again to modify it
                transaction_to_update = None
                current_list = self.expenses if original_list_name == 'Expense' else self.incomes

                for t in current_list:
                    if t.get('id') == trans_id:
                        transaction_to_update = t
                        break

                if transaction_to_update is None:
                    messagebox.showerror("Error", "Could not find the transaction to update.", parent=modify_win)
                    return

                transaction_to_update['date'] = new_date
                transaction_to_update['amount'] = new_amount
                transaction_to_update['category'] = new_category
                transaction_to_update['description'] = new_description

                if new_type != original_list_name:
                    current_list.remove(transaction_to_update)
                    if new_type == 'Expense':
                        self.expenses.append(transaction_to_update)
                    else:
                        self.incomes.append(transaction_to_update)

                self.save_data()
                self.refresh_transaction_list()
                modify_win.destroy()

            except ValueError:
                messagebox.showerror("Error", "Invalid amount or date format (YYYY-MM-DD).", parent=modify_win)

        ttk.Button(form_frame, text="Save Changes", command=save_changes).grid(row=5, column=1, pady=20, sticky='w')

    # =========================
    # Transfers
    # =========================
    def create_transfers_tab(self):
        """Create the UI for the Transfers tab."""
        main_frame = ttk.Frame(self.transfers_tab, padding="20")
        main_frame.pack(fill='both', expand=True)

        form_frame = ttk.Frame(main_frame)
        form_frame.pack(anchor='center')

        ttk.Label(form_frame, text="This section allows you to record the movement of funds between your accounts.").grid(
            row=0, column=0, columnspan=3, sticky='w', pady=(0, 20))

        account_options = ["Bank", "Wallet", "Savings", "Investments", "Money Lent"]

        ttk.Label(form_frame, text="From Account:").grid(row=1, column=0, sticky='w', pady=10)
        self.transfer_from_var = tk.StringVar()
        self.transfer_from_combo = ttk.Combobox(form_frame, textvariable=self.transfer_from_var,
                                                values=account_options,
                                                width=28, state='readonly')
        self.transfer_from_combo.grid(row=1, column=1, pady=5, sticky='w')

        ttk.Label(form_frame, text="To Account:").grid(row=2, column=0, sticky='w', pady=10)
        self.transfer_to_var = tk.StringVar()
        self.transfer_to_combo = ttk.Combobox(form_frame, textvariable=self.transfer_to_var,
                                              values=account_options,
                                              width=28, state='readonly')
        self.transfer_to_combo.grid(row=2, column=1, pady=5, sticky='w')

        ttk.Label(form_frame, text="Amount:").grid(row=3, column=0, sticky='w', pady=5)
        self.transfer_amount_entry = ttk.Entry(form_frame, width=30)
        self.transfer_amount_entry.grid(row=3, column=1, pady=5, sticky='w')

        ttk.Button(form_frame, text="Execute Transfer", command=self.execute_transfer).grid(
            row=4, column=1, pady=20, sticky='w')

    def execute_transfer(self):
        """Logic to handle the transfer of funds between accounts."""
        from_acc = self.transfer_from_var.get()
        to_acc = self.transfer_to_var.get()
        amount_str = self.transfer_amount_entry.get()

        if not from_acc or not to_acc:
            messagebox.showerror("Error", "Please select both a 'From' and 'To' account.")
            return

        if from_acc == to_acc:
            messagebox.showerror("Error", "The 'From' and 'To' accounts cannot be the same.")
            return

        try:
            amount = float(amount_str)
            if amount <= 0:
                messagebox.showerror("Error", "Transfer amount must be positive.")
                return
        except ValueError:
            messagebox.showerror("Error", "Invalid amount entered.")
            return

        account_keys = {
            "Bank": "bank_account_balance",
            "Wallet": "wallet_balance",
            "Savings": "savings_balance",
            "Investments": "investment_balance",
            "Money Lent": "money_lent_balance"
        }

        from_key = account_keys[from_acc]
        to_key = account_keys[to_acc]

        self.budget_settings[from_key] -= amount
        self.budget_settings[to_key] += amount

        self.save_data()
        self.refresh_balance_entries()

        messagebox.showinfo("Success", f"Successfully transferred €{amount:.2f} from {from_acc} to {to_acc}.")
        self.transfer_amount_entry.delete(0, tk.END)
        self.transfer_from_var.set('')
        self.transfer_to_var.set('')

    # =========================
    # Budget & Settings (Balances + Fixed Costs + Daily Report)
    # =========================
    def create_budget_tab(self):
        main_frame = ttk.Frame(self.budget_tab, padding="10")
        main_frame.pack(fill='both', expand=True)
        main_frame.rowconfigure(1, weight=1)
        main_frame.columnconfigure(0, weight=1)

        top_frame = ttk.Frame(main_frame)
        top_frame.grid(row=0, column=0, sticky='ew', pady=(0, 10))
        top_frame.columnconfigure(1, weight=1)

        settings_frame = ttk.LabelFrame(top_frame, text="Monthly Settings & Balances", padding="10")
        settings_frame.grid(row=0, column=0, sticky='ns', padx=(0, 10))

        ttk.Label(settings_frame, text="Base Monthly Income:").grid(row=0, column=0, sticky='w', pady=5)
        self.income_entry = ttk.Entry(settings_frame, width=15)
        self.income_entry.grid(row=0, column=1, pady=5)

        ttk.Label(settings_frame, text="Bank Account Balance:").grid(row=1, column=0, sticky='w', pady=5)
        self.bank_account_entry = ttk.Entry(settings_frame, width=15)
        self.bank_account_entry.grid(row=1, column=1, pady=5)

        ttk.Label(settings_frame, text="Wallet Balance:").grid(row=2, column=0, sticky='w', pady=5)
        self.wallet_entry = ttk.Entry(settings_frame, width=15)
        self.wallet_entry.grid(row=2, column=1, pady=5)

        ttk.Label(settings_frame, text="Current Savings:").grid(row=3, column=0, sticky='w', pady=5)
        self.savings_entry = ttk.Entry(settings_frame, width=15)
        self.savings_entry.grid(row=3, column=1, pady=5)

        ttk.Label(settings_frame, text="Current Investments:").grid(row=4, column=0, sticky='w', pady=5)
        self.investment_entry = ttk.Entry(settings_frame, width=15)
        self.investment_entry.grid(row=4, column=1, pady=5)

        ttk.Label(settings_frame, text="Money Lent Balance:").grid(row=5, column=0, sticky='w', pady=5)
        self.money_lent_entry = ttk.Entry(settings_frame, width=15)
        self.money_lent_entry.grid(row=5, column=1, pady=5)

        ttk.Label(settings_frame, text="Daily Savings Goal:").grid(row=6, column=0, sticky='w', pady=5)
        self.daily_savings_entry = ttk.Entry(settings_frame, width=15)
        self.daily_savings_entry.grid(row=6, column=1, pady=5)

        ttk.Button(settings_frame, text="Save Settings", command=self.save_settings).grid(
            row=7, column=1, pady=10, sticky='e')

        management_frame = ttk.Frame(top_frame)
        management_frame.grid(row=0, column=1, sticky='nsew')
        management_frame.columnconfigure(0, weight=1)
        management_frame.rowconfigure(0, weight=1)

        fixed_costs_frame = ttk.LabelFrame(management_frame, text="Manage Fixed Monthly Costs", padding="10")
        fixed_costs_frame.grid(row=0, column=0, sticky='nsew')
        fixed_costs_frame.rowconfigure(0, weight=1)
        fixed_costs_frame.columnconfigure(0, weight=1)

        fc_tree_frame = ttk.Frame(fixed_costs_frame)
        fc_tree_frame.grid(row=0, column=0, columnspan=2, sticky='nsew')
        fc_tree_frame.columnconfigure(0, weight=1)
        fc_tree_frame.rowconfigure(0, weight=1)
        self.fixed_costs_tree = ttk.Treeview(fc_tree_frame, columns=('Description', 'Amount'), show='headings', height=5)
        self.fixed_costs_tree.heading('Description', text='Description')
        self.fixed_costs_tree.heading('Amount', text='Amount (€)')
        self.fixed_costs_tree.column('Description', width=200)
        self.fixed_costs_tree.column('Amount', width=100, anchor='e')
        self.fixed_costs_tree.grid(row=0, column=0, sticky='nsew')
        fc_scrollbar = ttk.Scrollbar(fc_tree_frame, orient='vertical', command=self.fixed_costs_tree.yview)
        fc_scrollbar.grid(row=0, column=1, sticky='ns')
        self.fixed_costs_tree.configure(yscrollcommand=fc_scrollbar.set)
        fc_form_frame = ttk.Frame(fixed_costs_frame)
        fc_form_frame.grid(row=1, column=0, columnspan=2, sticky='ew', pady=10)
        ttk.Label(fc_form_frame, text="Desc:").pack(side='left', padx=(0, 5))
        self.fc_desc_entry = ttk.Entry(fc_form_frame, width=20)
        self.fc_desc_entry.pack(side='left', expand=True, fill='x')
        ttk.Label(fc_form_frame, text="Amount:").pack(side='left', padx=(10, 5))
        self.fc_amount_entry = ttk.Entry(fc_form_frame, width=10)
        self.fc_amount_entry.pack(side='left')
        fc_btn_frame = ttk.Frame(fixed_costs_frame)
        fc_btn_frame.grid(row=2, column=0, columnspan=2, sticky='ew')
        ttk.Button(fc_btn_frame, text="Add", command=self.add_fixed_cost).pack(side='left', padx=5)
        ttk.Button(fc_btn_frame, text="Update", command=self.update_fixed_cost).pack(side='left', padx=5)
        ttk.Button(fc_btn_frame, text="Delete", command=self.delete_fixed_cost).pack(side='left', padx=5)

        report_frame = ttk.LabelFrame(main_frame, text="Daily Budget Report", padding="10")
        report_frame.grid(row=1, column=0, sticky='nsew', pady=(10, 0))
        report_frame.rowconfigure(1, weight=1)
        report_frame.columnconfigure(0, weight=1)

        month_frame = ttk.Frame(report_frame)
        month_frame.grid(row=0, column=0, sticky='ew', pady=5)
        ttk.Label(month_frame, text="Select Month:").pack(side='left', padx=5)
        self.budget_month = ttk.Entry(month_frame, width=15)
        self.budget_month.insert(0, datetime.now().strftime("%Y-%m"))
        self.budget_month.pack(side='left', padx=5)
        ttk.Button(month_frame, text="Generate Report", command=self.generate_daily_budget).pack(side='left', padx=10)
        ttk.Button(month_frame, text="Export Report", command=self.export_daily_budget_report).pack(side='left', padx=5)

        budget_text_frame = ttk.Frame(report_frame)
        budget_text_frame.grid(row=1, column=0, sticky='nsew', pady=(10, 0))
        budget_text_frame.rowconfigure(0, weight=1)
        budget_text_frame.columnconfigure(0, weight=1)
        self.budget_text = tk.Text(budget_text_frame, height=20, width=90, font=('Courier New', 9))
        self.budget_text.grid(row=0, column=0, sticky='nsew')
        budget_text_scrollbar = ttk.Scrollbar(budget_text_frame, orient='vertical', command=self.budget_text.yview)
        budget_text_scrollbar.grid(row=0, column=1, sticky='ns')
        self.budget_text.configure(yscrollcommand=budget_text_scrollbar.set)

    # =========================
    # Budgets Tab (Category Budget Sliders)
    # =========================
    def create_budgets_tab(self):
        main_frame = ttk.Frame(self.budgets_tab, padding="10")
        main_frame.pack(fill='both', expand=True)
        main_frame.rowconfigure(1, weight=1)
        main_frame.columnconfigure(0, weight=1)

        # Month picker affects amounts and auto-assign logic
        toolbar = ttk.Frame(main_frame)
        toolbar.grid(row=0, column=0, sticky='ew', pady=(0, 5))
        ttk.Label(toolbar, text="Budget Month (YYYY-MM):").pack(side='left', padx=(0, 5))
        self.budget_month_for_sliders_var = tk.StringVar(value=datetime.now().strftime("%Y-%m"))
        self.slider_month_entry = ttk.Entry(toolbar, textvariable=self.budget_month_for_sliders_var, width=10)
        self.slider_month_entry.pack(side='left')
        ttk.Button(toolbar, text="Refresh Amounts", command=self._update_monetary_labels).pack(side='left', padx=10)

        budget_limits_frame = ttk.LabelFrame(main_frame, text="Category Budget Limits", padding="10")
        budget_limits_frame.grid(row=1, column=0, sticky='nsew')

        self.create_category_budget_widgets(budget_limits_frame)

    def create_category_budget_widgets(self, parent_frame):
        """Create UI for managing category budget limits using sliders."""
        parent_frame.rowconfigure(3, weight=1)
        parent_frame.columnconfigure(0, weight=1)

        self.budget_cat_type_var = tk.StringVar(value="Expense")

        type_frame = ttk.Frame(parent_frame)
        type_frame.grid(row=0, column=0, sticky='ew', pady=2)
        ttk.Label(type_frame, text="Type:").pack(side='left')
        ttk.Radiobutton(type_frame, text="Expense", variable=self.budget_cat_type_var,
                        value="Expense", command=self._create_budget_sliders).pack(side='left', padx=5)
        ttk.Radiobutton(type_frame, text="Income", variable=self.budget_cat_type_var,
                        value="Income", command=self._create_budget_sliders).pack(side='left', padx=5)

        # Frame for adding/removing categories
        management_frame = ttk.Frame(parent_frame)
        management_frame.grid(row=1, column=0, sticky='ew', pady=5)

        ttk.Label(management_frame, text="New Category:").pack(side='left', padx=(0, 5))
        self.new_cat_entry = ttk.Entry(management_frame, width=20)
        self.new_cat_entry.pack(side='left')
        ttk.Button(management_frame, text="Add", command=self.add_category_from_budget).pack(side='left', padx=5)

        ttk.Label(management_frame, text="Remove Category:").pack(side='left', padx=(10, 5))
        self.remove_cat_combo = ttk.Combobox(management_frame, width=20, state='readonly')
        self.remove_cat_combo.pack(side='left')
        ttk.Button(management_frame, text="Remove", command=self.remove_category_from_budget).pack(side='left', padx=5)

        self.sliders_frame = ttk.Frame(parent_frame)
        self.sliders_frame.grid(row=2, column=0, sticky='nsew', pady=5)

        btn_frame = ttk.Frame(parent_frame)
        btn_frame.grid(row=3, column=0, sticky='ew', pady=5)

        ttk.Button(btn_frame, text="Auto-Assign From Expenses", command=self.auto_assign_budgets).pack(side='left', padx=(0, 5))
        ttk.Button(btn_frame, text="Normalize to 100%", command=lambda: (self._normalize_sliders(), self._update_total_percentage_label())).pack(side='left', padx=(0, 10))

        spacer = ttk.Frame(btn_frame)
        spacer.pack(side='left', expand=True, fill='x')

        self.total_pct_label = ttk.Label(btn_frame, text="Total: 0.0%")
        self.total_pct_label.pack(side='left', padx=(0, 10))

        ttk.Button(btn_frame, text="Save Budgets", command=self.save_category_budgets).pack(side='left', padx=5)

        self.budget_sliders = {}
        self._create_budget_sliders()

    def _create_budget_sliders(self):
        """Create and arrange the budget sliders for each category without auto-normalizing."""
        for widget in self.sliders_frame.winfo_children():
            widget.destroy()

        self.budget_sliders = {}
        cat_type = self.budget_cat_type_var.get()
        categories = self.categories.get(cat_type, [])
        category_budgets = self.budget_settings.get('category_budgets', {}).get(cat_type, {}).copy()

        # If no budgets exist yet, evenly distribute; otherwise, preserve what was saved.
        if not category_budgets:
            if categories:
                even_share = 100.0 / len(categories)
                for c in categories:
                    category_budgets[c] = even_share
        else:
            # Newly added categories get 0% by default (do not change total)
            for c in categories:
                if c not in category_budgets:
                    category_budgets[c] = 0.0

        self.remove_cat_combo['values'] = categories

        # Determine month for monetary labels
        month_str = getattr(self, 'budget_month_for_sliders_var', None)
        month_str = month_str.get() if month_str else datetime.now().strftime("%Y-%m")
        net_available = self._compute_net_available_for_spending(month_str)

        for category in categories:
            frame = ttk.Frame(self.sliders_frame)
            frame.pack(fill='x', pady=2)

            ttk.Label(frame, text=category, width=15).pack(side='left')

            var = tk.DoubleVar(value=float(category_budgets.get(category, 0)))

            slider = ttk.Scale(frame, from_=0, to=100, orient='horizontal', variable=var,
                               command=lambda v, cat=category: self._on_slider_change(cat, float(v)))
            slider.pack(side='left', fill='x', expand=True, padx=5)

            label = ttk.Label(frame, text=f"{var.get():.1f}%", width=7)
            label.pack(side='left')

            amount_label = ttk.Label(frame, text=f"€{(var.get() / 100) * net_available:.2f}", width=12)
            amount_label.pack(side='left')

            self.budget_sliders[category] = {'var': var, 'slider': slider, 'label': label, 'amount_label': amount_label}

        self._update_monetary_labels()
        self._update_total_percentage_label()

    def _on_slider_change(self, changed_category, new_value):
        """Callback for when a slider's value changes."""
        if hasattr(self, '_slider_lock') and self._slider_lock:
            return

        self._slider_lock = True

        old_value = self.budget_sliders[changed_category]['var'].get()
        self.budget_sliders[changed_category]['var'].set(new_value)
        self.budget_sliders[changed_category]['label'].config(text=f"{new_value:.1f}%")

        # Keep totals roughly consistent by adjusting others proportionally
        self._adjust_other_sliders(changed_category, new_value, old_value)

        self._slider_lock = False

        self._update_monetary_labels()
        self._update_total_percentage_label()

    def _adjust_other_sliders(self, changed_category, new_value, old_value):
        """Adjust other sliders to maintain a total of ~100%."""
        delta = new_value - old_value
        other_sliders = {cat: self.budget_sliders[cat] for cat in self.budget_sliders if cat != changed_category}

        other_total = sum(s['var'].get() for s in other_sliders.values())

        if other_total > 0:
            for category, slider_info in other_sliders.items():
                current_val = slider_info['var'].get()
                adjustment = delta * (current_val / other_total)
                new_slider_val = max(0, min(100, current_val - adjustment))
                slider_info['var'].set(new_slider_val)
                slider_info['label'].config(text=f"{new_slider_val:.1f}%")
        else:
            if len(other_sliders) > 0:
                per_slider_adjustment = delta / len(other_sliders)
                for category, slider_info in other_sliders.items():
                    new_slider_val = max(0, min(100, slider_info['var'].get() - per_slider_adjustment))
                    slider_info['var'].set(new_slider_val)
                    slider_info['label'].config(text=f"{new_slider_val:.1f}%")

    def _normalize_sliders(self):
        """Ensure the total of all sliders is exactly 100%."""
        total = sum(s['var'].get() for s in self.budget_sliders.values())
        if total == 0:
            return

        if abs(total - 100.0) > 0.01:
            for slider_info in self.budget_sliders.values():
                current_val = slider_info['var'].get()
                normalized_val = (current_val / total) * 100
                slider_info['var'].set(normalized_val)
                slider_info['label'].config(text=f"{normalized_val:.1f}%")
        self._update_monetary_labels()

    def _update_monetary_labels(self):
        """Update the monetary value labels for each category slider using the selected month."""
        month_str = getattr(self, 'budget_month_for_sliders_var', None)
        month_str = month_str.get() if month_str else datetime.now().strftime("%Y-%m")
        net_available = self._compute_net_available_for_spending(month_str)
        for category, slider_info in self.budget_sliders.items():
            percentage = slider_info['var'].get()
            amount = (percentage / 100.0) * net_available
            slider_info['amount_label'].config(text=f"€{amount:.2f}")
        self._update_total_percentage_label()

    def _update_total_percentage_label(self):
        """Show the sum of all sliders to help the user see un/over-allocated %."""
        if not hasattr(self, 'total_pct_label'):
            return
        total = sum(s['var'].get() for s in self.budget_sliders.values())
        self.total_pct_label.config(text=f"Total: {total:.1f}%")

    def save_category_budgets(self):
        """Save the current slider values to the budget settings (no normalization on save)."""
        cat_type = self.budget_cat_type_var.get()
        if cat_type not in self.budget_settings['category_budgets']:
            self.budget_settings['category_budgets'][cat_type] = {}

        for category, slider_info in self.budget_sliders.items():
            self.budget_settings['category_budgets'][cat_type][category] = float(slider_info['var'].get())

        self.save_data()
        self._create_budget_sliders()
        self._update_total_percentage_label()
        messagebox.showinfo("Success", "Category budgets have been saved.")

    def add_category_from_budget(self):
        cat_type = self.budget_cat_type_var.get()
        new_cat = self.new_cat_entry.get().strip()
        if not new_cat:
            messagebox.showerror("Error", "Category name cannot be empty.")
            return
        if new_cat.lower() in [c.lower() for c in self.categories[cat_type]]:
            messagebox.showwarning("Warning", "This category already exists.")
            return
        self.categories[cat_type].append(new_cat)
        self.categories[cat_type].sort()
        self.save_data()
        self._create_budget_sliders()
        self.update_categories()
        self.new_cat_entry.delete(0, tk.END)

    def remove_category_from_budget(self):
        cat_type = self.budget_cat_type_var.get()
        category_to_delete = self.remove_cat_combo.get()
        if not category_to_delete:
            messagebox.showwarning("Warning", "Please select a category to delete.")
            return
        if category_to_delete.lower() == "other":
            messagebox.showerror("Error", "Cannot delete the 'Other' category.")
            return
        if messagebox.askyesno("Confirm",
                               f"Are you sure you want to delete the '{category_to_delete}' category? \nExisting transactions with this category will not be changed."):
            self.categories[cat_type].remove(category_to_delete)
            # Also remove from budget settings
            if cat_type in self.budget_settings['category_budgets'] and category_to_delete in self.budget_settings['category_budgets'][cat_type]:
                del self.budget_settings['category_budgets'][cat_type][category_to_delete]
            self.save_data()
            self._create_budget_sliders()
            self.update_categories()

    def auto_assign_budgets(self):
        """Auto-assign budget % based on current expenses for the selected month."""
        cat_type = self.budget_cat_type_var.get()
        if cat_type != "Expense":
            messagebox.showinfo("Info", "Auto-assign is only available for Expense budgets.")
            return

        month_str = getattr(self, 'budget_month_for_sliders_var', None)
        month_str = month_str.get() if month_str else datetime.now().strftime("%Y-%m")

        try:
            datetime.strptime(month_str, "%Y-%m")
        except ValueError:
            messagebox.showerror("Error", "Invalid month format. Use YYYY-MM.")
            return

        net_available = self._compute_net_available_for_spending(month_str)
        if net_available <= 0:
            messagebox.showwarning("Warning", "Net available for spending is €0 for this month. Cannot auto-assign.")
            return

        # Sum spending per category for that month
        spend_by_cat = {cat: 0.0 for cat in self.budget_sliders.keys()}
        for e in self.expenses:
            if e['date'].startswith(month_str):
                if e['category'] in spend_by_cat:
                    spend_by_cat[e['category']] += float(e['amount'])

        total_spent = sum(spend_by_cat.values())

        if total_spent == 0:
            messagebox.showinfo("Info", "No expenses recorded for the selected month. Nothing to auto-assign.")
            return

        if total_spent <= net_available:
            # Assign % as spent/net_available; leave remainder unallocated for user to place.
            for cat, slider in self.budget_sliders.items():
                pct = (spend_by_cat[cat] / net_available) * 100.0 if net_available > 0 else 0.0
                slider['var'].set(pct)
                slider['label'].config(text=f"{pct:.1f}%")
            self._update_monetary_labels()
            self._update_total_percentage_label()

            remaining = net_available - total_spent
            remaining_pct = 100.0 - sum(s['var'].get() for s in self.budget_sliders.values())
            messagebox.showinfo(
                "Remaining Budget",
                f"Budgets set to match current expenses for {month_str}.\n"
                f"Remaining unallocated budget: €{remaining:.2f} (~{remaining_pct:.1f}%).\n\n"
                f"Please assign the remaining budget to one or more categories."
            )
        else:
            # Overspent: allocate 100% proportionally to what has been spent
            for cat, slider in self.budget_sliders.items():
                share = (spend_by_cat[cat] / total_spent) * 100.0 if total_spent > 0 else 0.0
                slider['var'].set(share)
                slider['label'].config(text=f"{share:.1f}%")
            self._update_monetary_labels()
            self._update_total_percentage_label()
            messagebox.showwarning(
                "Overspent",
                f"You have already spent €{total_spent:.2f} which exceeds your available monthly "
                f"flexible budget of €{net_available:.2f} by €{(total_spent - net_available):.2f}.\n\n"
                f"Budgets were set proportionally to actual spend."
            )

    # =========================
    # Export helpers
    # =========================
    def export_daily_budget_report(self):
        report_content = self.budget_text.get("1.0", tk.END).strip()
        if not report_content:
            messagebox.showwarning("Warning", "Please generate a report before exporting.")
            return
        month_str = self.budget_month.get()
        today_str = datetime.now().strftime("%Y-%m-%d")
        default_filename = f"day_report_{month_str}_{today_str}.txt"
        filepath = filedialog.asksaveasfilename(
            initialfile=default_filename,
            defaultextension=".txt",
            filetypes=[("Text Documents", "*.txt"), ("All Files", "*.*")]
        )
        if not filepath:
            return
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(report_content)
            messagebox.showinfo("Success", f"Report successfully exported to:\n{filepath}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export report.\nError: {e}")

    def export_projection_report(self):
        report_content = self.projection_text.get("1.0", tk.END).strip()
        if not report_content:
            messagebox.showwarning("Warning", "Please generate a projection before exporting.")
            return
        today_str = datetime.now().strftime("%Y-%m-%d")
        default_filename = f"bank_projection_{today_str}.txt"
        filepath = filedialog.asksaveasfilename(
            initialfile=default_filename,
            defaultextension=".txt",
            filetypes=[("Text Documents", "*.txt"), ("All Files", "*.*")]
        )
        if not filepath:
            return
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(report_content)
            messagebox.showinfo("Success", f"Projection successfully exported to:\n{filepath}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export projection.\nError: {e}")

    # =========================
    # Projection
    # =========================
    def create_projection_tab(self):
        main_frame = ttk.Frame(self.projection_tab, padding="10")
        main_frame.pack(fill='both', expand=True)
        main_frame.rowconfigure(1, weight=1)
        main_frame.columnconfigure(0, weight=1)

        controls_frame = ttk.LabelFrame(main_frame, text="Projection Options", padding="10")
        controls_frame.grid(row=0, column=0, sticky='ew', pady=5)

        ttk.Label(controls_frame, text="Number of months to project:").pack(side='left', padx=5)
        self.projection_months_entry = ttk.Entry(controls_frame, width=10)
        self.projection_months_entry.insert(0, "12")
        self.projection_months_entry.pack(side='left', padx=5)

        ttk.Button(controls_frame, text="Generate Projection", command=self.generate_projection).pack(side='left', padx=20)
        ttk.Button(controls_frame, text="Export Projection", command=self.export_projection_report).pack(side='left', padx=5)

        self.projection_text = tk.Text(main_frame, height=20, width=90, font=('Courier New', 9))
        self.projection_text.grid(row=1, column=0, sticky='nsew', pady=10)

    def generate_projection(self):
        try:
            num_months = int(self.projection_months_entry.get())
            if num_months <= 0:
                messagebox.showerror("Error", "Number of months must be positive.")
                return
        except ValueError:
            messagebox.showerror("Error", "Invalid number of months.")
            return

        bank_balance = self.budget_settings.get('bank_account_balance', 0)
        wallet_balance = self.budget_settings.get('wallet_balance', 0)
        savings_balance = self.budget_settings.get('savings_balance', 0)
        investment_balance = self.budget_settings.get('investment_balance', 0)
        money_lent_balance = self.budget_settings.get('money_lent_balance', 0)
        daily_savings_goal = self.budget_settings.get('daily_savings_goal', 0)

        starting_total_balance = (bank_balance + wallet_balance + savings_balance +
                                  investment_balance + money_lent_balance)

        report = f"{'='*80}\n"
        report += f"FINANCIAL PROJECTION\n"
        report += f"{'='*80}\n\n"
        report += f"This report projects your total financial balance (Bank + Wallet + Savings + Investments + Money Lent).\n"
        report += f"It assumes you will meet your daily savings goal every day.\n\n"
        report += f"Bank Account Balance:       €{bank_balance:>10.2f}\n"
        report += f"Wallet Balance:             €{wallet_balance:>10.2f}\n"
        report += f"Current Savings Balance:    €{savings_balance:>10.2f}\n"
        report += f"Current Investment Balance: €{investment_balance:>10.2f}\n"
        report += f"Money Lent Balance:         €{money_lent_balance:>10.2f}\n"
        report += f"-----------------------------------------\n"
        report += f"Total Starting Balance:     €{starting_total_balance:>10.2f}\n"
        report += f"Target Daily Savings Goal:  €{daily_savings_goal:>10.2f}\n"
        report += f"{'-'*80}\n\n"
        report += f"{'Month':<15} {'Projected Monthly Savings':<30} {'Projected Total Balance'}\n"
        report += f"{'-'*80}\n"

        projected_balance = starting_total_balance
        current_date = date.today()

        for i in range(num_months):
            next_month_date = current_date + relativedelta(months=1)
            days_in_month = (next_month_date - current_date).days
            monthly_savings = daily_savings_goal * days_in_month
            projected_balance += monthly_savings

            report += f"{current_date.strftime('%Y-%m'):<15} €{monthly_savings:<28.2f} €{projected_balance:10.2f}\n"
            current_date = next_month_date

        report += f"{'-'*80}\n"

        self.projection_text.delete(1.0, tk.END)
        self.projection_text.insert(1.0, report)

    # =========================
    # Settings & Fixed Costs
    # =========================
    def refresh_balance_entries(self):
        """Updates the balance Entry widgets on the Budget tab with current values."""
        self.income_entry.delete(0, tk.END)
        self.bank_account_entry.delete(0, tk.END)
        self.wallet_entry.delete(0, tk.END)
        self.savings_entry.delete(0, tk.END)
        self.investment_entry.delete(0, tk.END)
        self.money_lent_entry.delete(0, tk.END)
        self.daily_savings_entry.delete(0, tk.END)

        self.income_entry.insert(0, str(self.budget_settings.get('monthly_income', 0)))
        self.bank_account_entry.insert(0, str(self.budget_settings.get('bank_account_balance', 0)))
        self.wallet_entry.insert(0, str(self.budget_settings.get('wallet_balance', 0)))
        self.savings_entry.insert(0, str(self.budget_settings.get('savings_balance', 0)))
        self.investment_entry.insert(0, str(self.budget_settings.get('investment_balance', 0)))
        self.money_lent_entry.insert(0, str(self.budget_settings.get('money_lent_balance', 0)))
        self.daily_savings_entry.insert(0, str(self.budget_settings.get('daily_savings_goal', 0)))

    def save_settings(self):
        try:
            income = float(self.income_entry.get()) if self.income_entry.get() else 0
            bank_balance = float(self.bank_account_entry.get()) if self.bank_account_entry.get() else 0
            wallet = float(self.wallet_entry.get()) if self.wallet_entry.get() else 0
            savings = float(self.savings_entry.get()) if self.savings_entry.get() else 0
            investment = float(self.investment_entry.get()) if self.investment_entry.get() else 0
            money_lent = float(self.money_lent_entry.get()) if self.money_lent_entry.get() else 0
            savings_goal = float(self.daily_savings_entry.get()) if self.daily_savings_entry.get() else 0

            self.budget_settings['monthly_income'] = income
            self.budget_settings['bank_account_balance'] = bank_balance
            self.budget_settings['wallet_balance'] = wallet
            self.budget_settings['savings_balance'] = savings
            self.budget_settings['investment_balance'] = investment
            self.budget_settings['money_lent_balance'] = money_lent
            self.budget_settings['daily_savings_goal'] = savings_goal

            self.save_data()
            messagebox.showinfo("Success", "Settings saved!")
        except ValueError:
            messagebox.showerror("Error", "Invalid amount in one of the fields.")

    def refresh_fixed_costs_tree(self):
        for item in self.fixed_costs_tree.get_children():
            self.fixed_costs_tree.delete(item)
        for cost in self.budget_settings.get('fixed_costs', []):
            self.fixed_costs_tree.insert('', 'end', values=(cost['desc'], f"{cost['amount']:.2f}"))

    def add_fixed_cost(self):
        try:
            desc = self.fc_desc_entry.get()
            amount = float(self.fc_amount_entry.get())
            if not desc:
                messagebox.showerror("Error", "Description cannot be empty.")
                return
            self.budget_settings['fixed_costs'].append({'desc': desc, 'amount': amount})
            self.save_data()
            self.refresh_fixed_costs_tree()
            self.fc_desc_entry.delete(0, tk.END)
            self.fc_amount_entry.delete(0, tk.END)
        except ValueError:
            messagebox.showerror("Error", "Invalid amount for fixed cost.")

    def update_fixed_cost(self):
        selected = self.fixed_costs_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a fixed cost to update.")
            return
        try:
            desc = self.fc_desc_entry.get()
            amount = float(self.fc_amount_entry.get())
            if not desc:
                messagebox.showerror("Error", "Description cannot be empty.")
                return
            original_values = self.fixed_costs_tree.item(selected[0])['values']
            for i, cost in enumerate(self.budget_settings['fixed_costs']):
                if cost['desc'] == original_values[0] and cost['amount'] == float(original_values[1]):
                    self.budget_settings['fixed_costs'][i] = {'desc': desc, 'amount': amount}
                    break
            self.save_data()
            self.refresh_fixed_costs_tree()
        except ValueError:
            messagebox.showerror("Error", "Invalid amount for fixed cost.")

    def delete_fixed_cost(self):
        selected = self.fixed_costs_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a fixed cost to delete.")
            return
        values = self.fixed_costs_tree.item(selected[0])['values']
        target_cost = {'desc': values[0], 'amount': float(values[1])}
        try:
            self.budget_settings['fixed_costs'].remove(target_cost)
            self.save_data()
            self.refresh_fixed_costs_tree()
        except ValueError:
            messagebox.showerror("Error", "Could not delete the selected fixed cost item.")

    # =========================
    # Budget computation helpers
    # =========================
    def _compute_net_available_for_spending(self, month_str: str) -> float:
        """Compute Net Available for Spending for a given month (YYYY-MM)."""
        try:
            datetime.strptime(month_str, "%Y-%m")
        except ValueError:
            month_str = datetime.now().strftime("%Y-%m")

        base_income = self.budget_settings.get('monthly_income', 0)
        daily_savings_goal = self.budget_settings.get('daily_savings_goal', 0)
        flex_income_month = sum(i['amount'] for i in self.incomes if i['date'].startswith(month_str))
        total_income = base_income + flex_income_month
        fixed_costs = sum(fc['amount'] for fc in self.budget_settings.get('fixed_costs', []))

        try:
            year, month = map(int, month_str.split('-'))
            days_in_month = calendar.monthrange(year, month)[1]
        except Exception:
            days_in_month = 30

        monthly_savings_goal = daily_savings_goal * days_in_month
        spending_flexible_budget = total_income - fixed_costs - monthly_savings_goal
        return max(spending_flexible_budget, 0)

    def generate_daily_budget(self):
        month_str = self.budget_month.get()
        try:
            year, month = map(int, month_str.split('-'))
        except ValueError:
            messagebox.showerror("Error", "Invalid month format. Use YYYY-MM.")
            return

        base_income = self.budget_settings.get('monthly_income', 0)
        daily_savings_goal = self.budget_settings.get('daily_savings_goal', 0)
        flex_income_month = sum(i['amount'] for i in self.incomes if i['date'].startswith(month_str))
        total_income = base_income + flex_income_month
        fixed_costs = sum(fc['amount'] for fc in self.budget_settings.get('fixed_costs', []))

        try:
            days_in_month = calendar.monthrange(year, month)[1]
        except calendar.IllegalMonthError:
            messagebox.showerror("Error", "Invalid month number in date.")
            return

        monthly_savings_goal = daily_savings_goal * days_in_month
        monthly_flexible_spending_budget = total_income - fixed_costs - monthly_savings_goal

        if days_in_month == 0:
            messagebox.showerror("Error", "Cannot divide by zero days in month.")
            return

        initial_daily_spending_target = monthly_flexible_spending_budget / days_in_month

        flex_expenses_month = [e for e in self.expenses if e['date'].startswith(month_str)]
        daily_expenses = {}
        for expense in flex_expenses_month:
            expense_date = expense['date']
            daily_expenses.setdefault(expense_date, []).append(expense)

        report = f"{'='*80}\n"
        report += f"DAILY BUDGET REPORT - {calendar.month_name[month]} {year}\n"
        report += f"{'='*80}\n\n"
        report += f"Base Monthly Income:                      €{base_income:>10.2f}\n"
        report += f"Flexible Income (This Month):             €{flex_income_month:>10.2f}\n"
        report += f"TOTAL INCOME:                             €{total_income:>10.2f}\n"
        report += f"Total Fixed Costs:                       -€{fixed_costs:>10.2f}\n"
        report += f"{'-'*50}\n"
        report += f"Monthly Savings Goal:                    -€{monthly_savings_goal:>10.2f}\n"
        report += f"NET MONTHLY FLEXIBLE BUDGET:              €{monthly_flexible_spending_budget:>10.2f}\n"
        report += f"INITIAL DAILY SPENDING TARGET:            €{initial_daily_spending_target:>10.2f}\n"
        report += f"{'-'*80}\n\n"
        report += f"DAILY BREAKDOWN (Performance against your initial daily target)\n"
        report += f"{'-'*80}\n"
        report += f"{'Date':<12} {'Target':<12} {'Spent':<12} {'Daily +/-':<12} {'Cumulative':<12} {'Status'}\n"
        report += f"{'-'*80}\n"

        cumulative_flexible_balance = monthly_flexible_spending_budget
        today = datetime.now().date()
        current_month_start_date = date(year, month, 1)

        for day in range(1, days_in_month + 1):
            date_str = f"{year}-{month:02d}-{day:02d}"
            date_obj = datetime.strptime(date_str, "%Y-%m-%d").date()

            if date_obj > today:
                break

            day_total_spent = sum(e['amount'] for e in daily_expenses.get(date_str, []))
            cumulative_flexible_balance -= day_total_spent

            daily_plus_minus_from_target = initial_daily_spending_target - day_total_spent

            status = "✓ On Track" if daily_plus_minus_from_target >= 0 else "✗ Overspent"
            if day_total_spent == 0:
                status = "- No spending"

            report += (f"{date_str:<12} €{initial_daily_spending_target:<10.2f} €{day_total_spent:<10.2f} "
                       f"€{daily_plus_minus_from_target:<10.2f} €{cumulative_flexible_balance:<10.2f} {status}\n")

        report += f"{'-'*80}\n\n"

        if today.year == year and today.month == month and today.day < days_in_month:
            days_passed_this_month = today.day - current_month_start_date.day + 1
            remaining_days_forecast = days_in_month - days_passed_this_month

            report += f"FORECAST FOR REMAINING {remaining_days_forecast} DAYS\n"
            report += f"{'-'*80}\n"

            if remaining_days_forecast > 0:
                new_daily_spending_target = cumulative_flexible_balance / remaining_days_forecast
            else:
                new_daily_spending_target = cumulative_flexible_balance

            if new_daily_spending_target < 0:
                report += f"Your current flexible budget balance is €{cumulative_flexible_balance:.2f}.\n\n"
                total_flexible_expenses_incurred = sum(e['amount'] for e in flex_expenses_month)
                overall_net_value_including_savings = total_income - fixed_costs - total_flexible_expenses_incurred - monthly_savings_goal

                report += f"--- Understanding the Key Numbers ---\n\n"
                report += f" * Overall Net Value (Including Savings Goal): €{overall_net_value_including_savings:.2f}\n"
                report += f" * Your Current Flexible Budget Balance:      €{cumulative_flexible_balance:.2f}\n"
                report += f"   This is the remaining portion of your FLEXIBLE BUDGET after your spending.\n\n"
            else:
                report += f"Your current flexible budget balance is €{cumulative_flexible_balance:.2f}.\n"
                if remaining_days_forecast > 0:
                    report += f"You can now spend up to €{new_daily_spending_target:.2f} each day for the remaining {remaining_days_forecast} days.\n\n"
                    report += f"New Daily Target = Remaining Flexible Budget / Remaining Days\n"
                    report += f"                   €{new_daily_spending_target:>10.2f} = €{cumulative_flexible_balance:>10.2f} / {remaining_days_forecast}\n"
                else:
                    report += f"Today is the last day of the month. You have €{new_daily_spending_target:.2f} left to spend.\n"
                report += f"{'-'*80}\n"

        self.budget_text.delete(1.0, tk.END)
        self.budget_text.insert(1.0, report)


def main():
    root = tk.Tk()
    app = FinanceTracker(root)
    root.mainloop()


if __name__ == "__main__":
    main()
from pathlib import Path
from datetime import datetime
import json

DEFAULT_EXPENSE_CATEGORIES = [
    "Food", "Transportation", "Entertainment", "Utilities",
    "Shopping", "Healthcare", "Money Lent", "Other"
]
DEFAULT_INCOME_CATEGORIES = ["Salary", "Side Gig", "Bonus", "Gift", "Investment", "Other"]

class AppState:
    def __init__(self, data_file: Path = Path("finance_data.json")):
        self.data_file = data_file
        self.expenses = []
        self.incomes = []
        self.budget_settings = {}
        self.categories = {}
        self.load()

    def load(self):
        if self.data_file.exists():
            with open(self.data_file, "r", encoding="utf-8") as f:
                data = json.load(f)
        else:
            data = {}

        self.expenses = data.get("expenses", [])
        self.incomes = data.get("incomes", [])
        self.budget_settings = data.get("budget_settings", {})
        self.categories = data.get("categories", {})

        # Ensure defaults
        bs = self.budget_settings
        bs.setdefault("fixed_costs", [])
        bs.setdefault("monthly_income", 0)
        bs.setdefault("bank_account_balance", 0)
        bs.setdefault("savings_balance", 0)
        bs.setdefault("investment_balance", 0)
        bs.setdefault("wallet_balance", 0)
        bs.setdefault("daily_savings_goal", 0)
        bs.setdefault("money_lent_balance", 0)
        bs.setdefault("category_budgets", {"Expense": {}, "Income": {}})

        if "Expense" not in self.categories or not self.categories["Expense"]:
            self.categories["Expense"] = DEFAULT_EXPENSE_CATEGORIES.copy()
        if "Income" not in self.categories or not self.categories["Income"]:
            self.categories["Income"] = DEFAULT_INCOME_CATEGORIES.copy()

    def save(self):
        data = {
            "expenses": self.expenses,
            "incomes": self.incomes,
            "budget_settings": self.budget_settings,
            "categories": self.categories,
        }
        with open(self.data_file, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4)

    def add_transaction(self, trans_type: str, date_str: str, amount: float, category: str, description: str):
        trans_id = f"{datetime.now().timestamp()}"
        record = {"id": trans_id, "date": date_str, "amount": amount, "category": category, "description": description}
        if trans_type == "Expense":
            self.expenses.append(record)
        else:
            self.incomes.append(record)
        self.save()

    def delete_transaction_by_id(self, trans_type: str, trans_id: str) -> bool:
        target = self.expenses if trans_type == "Expense" else self.incomes
        for i, t in enumerate(target):
            if t.get("id") == trans_id:
                del target[i]
                self.save()
                return True
        return Falseimport tkinter as tk
from .state import AppState
from .ui.main_view import MainView

def main():
    root = tk.Tk()
    state = AppState()
    MainView(root, state)
    root.mainloop()# Finance Tracker packageimport tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime

class AddTransactionTab:
    def __init__(self, notebook, state, on_data_changed):
        self.state = state
        self.on_data_changed = on_data_changed

        self.frame = ttk.Frame(notebook, padding="20")
        notebook.add(self.frame, text="Add Transaction")

        form = ttk.Frame(self.frame)
        form.pack(anchor='center')

        ttk.Label(form, text="Transaction Type:").grid(row=0, column=0, sticky='w', pady=10)
        self.transaction_type_var = tk.StringVar(value="Expense")
        type_frame = ttk.Frame(form)
        type_frame.grid(row=0, column=1, sticky='w', pady=5)
        ttk.Radiobutton(type_frame, text="Expense", variable=self.transaction_type_var,
                        value="Expense", command=self.update_categories).pack(side='left', padx=5)
        ttk.Radiobutton(type_frame, text="Income", variable=self.transaction_type_var,
                        value="Income", command=self.update_categories).pack(side='left', padx=5)

        ttk.Label(form, text="Date:").grid(row=1, column=0, sticky='w', pady=5)
        self.date_entry = ttk.Entry(form, width=30)
        self.date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.date_entry.grid(row=1, column=1, pady=5, sticky='w')
        ttk.Label(form, text="(YYYY-MM-DD)", foreground="gray").grid(row=1, column=2, sticky='w', padx=5)

        ttk.Label(form, text="Amount:").grid(row=2, column=0, sticky='w', pady=5)
        self.amount_entry = ttk.Entry(form, width=30)
        self.amount_entry.grid(row=2, column=1, pady=5, sticky='w')

        ttk.Label(form, text="Category:").grid(row=3, column=0, sticky='w', pady=5)
        self.category_var = tk.StringVar()
        self.category_combo = ttk.Combobox(form, textvariable=self.category_var, width=28, state='readonly')
        self.category_combo.grid(row=3, column=1, pady=5, sticky='w')

        ttk.Label(form, text="Description:").grid(row=4, column=0, sticky='w', pady=5)
        self.description_entry = ttk.Entry(form, width=30)
        self.description_entry.grid(row=4, column=1, pady=5, sticky='w')

        ttk.Button(form, text="Add Transaction", command=self.add_transaction).grid(row=5, column=1, pady=20, sticky='w')

        self.update_categories()

    def update_categories(self):
        t = self.transaction_type_var.get()
        categories = self.state.categories.get(t, [])
        self.category_combo.config(values=categories)
        self.category_combo.set(categories[0] if categories else "")

    def add_transaction(self):
        try:
            date_str = self.date_entry.get()
            datetime.strptime(date_str, "%Y-%m-%d")
            amount = float(self.amount_entry.get())
            category = self.category_var.get()
            description = self.description_entry.get()
            trans_type = self.transaction_type_var.get()

            if not category:
                messagebox.showerror("Error", "Please select a category.")
                return

            self.state.add_transaction(trans_type, date_str, amount, category, description)
            self.amount_entry.delete(0, tk.END)
            self.description_entry.delete(0, tk.END)
            messagebox.showinfo("Success", f"{trans_type} added successfully!")
            self.on_data_changed()
        except ValueError:
            messagebox.showerror("Error", "Invalid amount or date format (YYYY-MM-DD).")import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from datetime import datetime
from ...services.budget_calculator import generate_daily_budget_report

class SettingsTab:
    def __init__(self, notebook, state):
        self.state = state

        main = ttk.Frame(notebook, padding="10")
        notebook.add(main, text="Budget Report")
        main.rowconfigure(1, weight=1)
        main.columnconfigure(0, weight=1)

        top = ttk.Frame(main)
        top.grid(row=0, column=0, sticky='ew', pady=(0, 10))
        top.columnconfigure(1, weight=1)

        settings = ttk.LabelFrame(top, text="Monthly Settings & Balances", padding="10")
        settings.grid(row=0, column=0, sticky='ns', padx=(0, 10))

        ttk.Label(settings, text="Base Monthly Income:").grid(row=0, column=0, sticky='w', pady=5)
        self.income_entry = ttk.Entry(settings, width=15)
        self.income_entry.grid(row=0, column=1, pady=5)

        ttk.Label(settings, text="Bank Account Balance:").grid(row=1, column=0, sticky='w', pady=5)
        self.bank_entry = ttk.Entry(settings, width=15)
        self.bank_entry.grid(row=1, column=1, pady=5)

        ttk.Label(settings, text="Wallet Balance:").grid(row=2, column=0, sticky='w', pady=5)
        self.wallet_entry = ttk.Entry(settings, width=15)
        self.wallet_entry.grid(row=2, column=1, pady=5)

        ttk.Label(settings, text="Current Savings:").grid(row=3, column=0, sticky='w', pady=5)
        self.savings_entry = ttk.Entry(settings, width=15)
        self.savings_entry.grid(row=3, column=1, pady=5)

        ttk.Label(settings, text="Current Investments:").grid(row=4, column=0, sticky='w', pady=5)
        self.investment_entry = ttk.Entry(settings, width=15)
        self.investment_entry.grid(row=4, column=1, pady=5)

        ttk.Label(settings, text="Money Lent Balance:").grid(row=5, column=0, sticky='w', pady=5)
        self.money_lent_entry = ttk.Entry(settings, width=15)
        self.money_lent_entry.grid(row=5, column=1, pady=5)

        ttk.Label(settings, text="Daily Savings Goal:").grid(row=6, column=0, sticky='w', pady=5)
        self.daily_savings_entry = ttk.Entry(settings, width=15)
        self.daily_savings_entry.grid(row=6, column=1, pady=5)

        ttk.Button(settings, text="Save Settings", command=self.save_settings).grid(row=7, column=1, pady=10, sticky='e')

        manage = ttk.Frame(top)
        manage.grid(row=0, column=1, sticky='nsew')
        manage.columnconfigure(0, weight=1)
        manage.rowconfigure(0, weight=1)

        fc_group = ttk.LabelFrame(manage, text="Manage Fixed Monthly Costs", padding="10")
        fc_group.grid(row=0, column=0, sticky='nsew')
        fc_group.rowconfigure(0, weight=1)
        fc_group.columnconfigure(0, weight=1)

        fc_tree_frame = ttk.Frame(fc_group)
        fc_tree_frame.grid(row=0, column=0, columnspan=2, sticky='nsew')
        fc_tree_frame.columnconfigure(0, weight=1)
        fc_tree_frame.rowconfigure(0, weight=1)

        self.fixed_costs_tree = ttk.Treeview(fc_tree_frame, columns=('Description', 'Amount'), show='headings', height=5)
        self.fixed_costs_tree.heading('Description', text='Description')
        self.fixed_costs_tree.heading('Amount', text='Amount (€)')
        self.fixed_costs_tree.column('Description', width=200)
        self.fixed_costs_tree.column('Amount', width=100, anchor='e')
        self.fixed_costs_tree.grid(row=0, column=0, sticky='nsew')
        fc_scroll = ttk.Scrollbar(fc_tree_frame, orient='vertical', command=self.fixed_costs_tree.yview)
        fc_scroll.grid(row=0, column=1, sticky='ns')
        self.fixed_costs_tree.configure(yscrollcommand=fc_scroll.set)

        fc_form = ttk.Frame(fc_group)
        fc_form.grid(row=1, column=0, columnspan=2, sticky='ew', pady=10)
        ttk.Label(fc_form, text="Desc:").pack(side='left', padx=(0, 5))
        self.fc_desc_entry = ttk.Entry(fc_form, width=20)
        self.fc_desc_entry.pack(side='left', expand=True, fill='x')
        ttk.Label(fc_form, text="Amount:").pack(side='left', padx=(10, 5))
        self.fc_amount_entry = ttk.Entry(fc_form, width=10)
        self.fc_amount_entry.pack(side='left')

        fc_btns = ttk.Frame(fc_group)
        fc_btns.grid(row=2, column=0, columnspan=2, sticky='ew')
        ttk.Button(fc_btns, text="Add", command=self.add_fixed_cost).pack(side='left', padx=5)
        ttk.Button(fc_btns, text="Update", command=self.update_fixed_cost).pack(side='left', padx=5)
        ttk.Button(fc_btns, text="Delete", command=self.delete_fixed_cost).pack(side='left', padx=5)

        report = ttk.LabelFrame(main, text="Daily Budget Report", padding="10")
        report.grid(row=1, column=0, sticky='nsew', pady=(10, 0))
        report.rowconfigure(1, weight=1)
        report.columnconfigure(0, weight=1)

        month_frame = ttk.Frame(report)
        month_frame.grid(row=0, column=0, sticky='ew', pady=5)
        ttk.Label(month_frame, text="Select Month:").pack(side='left', padx=5)
        self.budget_month_entry = ttk.Entry(month_frame, width=15)
        self.budget_month_entry.insert(0, datetime.now().strftime("%Y-%m"))
        self.budget_month_entry.pack(side='left', padx=5)
        ttk.Button(month_frame, text="Generate Report", command=self.generate_report).pack(side='left', padx=10)
        ttk.Button(month_frame, text="Export Report", command=self.export_report).pack(side='left', padx=5)

        text_frame = ttk.Frame(report)
        text_frame.grid(row=1, column=0, sticky='nsew', pady=(10, 0))
        text_frame.rowconfigure(0, weight=1)
        text_frame.columnconfigure(0, weight=1)
        self.report_text = tk.Text(text_frame, height=20, width=90, font=('Courier New', 9))
        self.report_text.grid(row=0, column=0, sticky='nsew')
        scroll = ttk.Scrollbar(text_frame, orient='vertical', command=self.report_text.yview)
        scroll.grid(row=0, column=1, sticky='ns')
        self.report_text.configure(yscrollcommand=scroll.set)

        self.refresh_balance_entries()
        self.refresh_fixed_costs_tree()

    def refresh_balance_entries(self):
        s = self.state.budget_settings
        def set_entry(entry, key):
            entry.delete(0, tk.END)
            entry.insert(0, str(s.get(key, 0)))
        set_entry(self.income_entry, 'monthly_income')
        set_entry(self.bank_entry, 'bank_account_balance')
        set_entry(self.wallet_entry, 'wallet_balance')
        set_entry(self.savings_entry, 'savings_balance')
        set_entry(self.investment_entry, 'investment_balance')
        set_entry(self.money_lent_entry, 'money_lent_balance')
        set_entry(self.daily_savings_entry, 'daily_savings_goal')

    def save_settings(self):
        try:
            s = self.state.budget_settings
            s['monthly_income'] = float(self.income_entry.get() or 0)
            s['bank_account_balance'] = float(self.bank_entry.get() or 0)
            s['wallet_balance'] = float(self.wallet_entry.get() or 0)
            s['savings_balance'] = float(self.savings_entry.get() or 0)
            s['investment_balance'] = float(self.investment_entry.get() or 0)
            s['money_lent_balance'] = float(self.money_lent_entry.get() or 0)
            s['daily_savings_goal'] = float(self.daily_savings_entry.get() or 0)
            self.state.save()
            messagebox.showinfo("Success", "Settings saved!")
        except ValueError:
            messagebox.showerror("Error", "Invalid amount in one of the fields.")

    def refresh_fixed_costs_tree(self):
        for i in self.fixed_costs_tree.get_children():
            self.fixed_costs_tree.delete(i)
        for cost in self.state.budget_settings.get('fixed_costs', []):
            self.fixed_costs_tree.insert('', 'end', values=(cost['desc'], f"{cost['amount']:.2f}"))

    def add_fixed_cost(self):
        try:
            desc = self.fc_desc_entry.get().strip()
            amount = float(self.fc_amount_entry.get())
            if not desc:
                messagebox.showerror("Error", "Description cannot be empty.")
                return
            self.state.budget_settings['fixed_costs'].append({'desc': desc, 'amount': amount})
            self.state.save()
            self.refresh_fixed_costs_tree()
            self.fc_desc_entry.delete(0, tk.END)
            self.fc_amount_entry.delete(0, tk.END)
        except ValueError:
            messagebox.showerror("Error", "Invalid amount for fixed cost.")

    def update_fixed_cost(self):
        selected = self.fixed_costs_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a fixed cost to update.")
            return
        try:
            desc = self.fc_desc_entry.get().strip()
            amount = float(self.fc_amount_entry.get())
            if not desc:
                messagebox.showerror("Error", "Description cannot be empty.")
                return
            original_values = self.fixed_costs_tree.item(selected[0])['values']
            for i, cost in enumerate(self.state.budget_settings['fixed_costs']):
                if cost['desc'] == original_values[0] and f"{cost['amount']:.2f}" == original_values[1]:
                    self.state.budget_settings['fixed_costs'][i] = {'desc': desc, 'amount': amount}
                    break
            self.state.save()
            self.refresh_fixed_costs_tree()
        except ValueError:
            messagebox.showerror("Error", "Invalid amount for fixed cost.")

    def delete_fixed_cost(self):
        selected = self.fixed_costs_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a fixed cost to delete.")
            return
        values = self.fixed_costs_tree.item(selected[0])['values']
        target_cost = {'desc': values[0], 'amount': float(values[1])}
        try:
            self.state.budget_settings['fixed_costs'].remove(target_cost)
            self.state.save()
            self.refresh_fixed_costs_tree()
        except ValueError:
            messagebox.showerror("Error", "Could not delete the selected fixed cost item.")

    def generate_report(self):
        month = self.budget_month_entry.get()
        text = generate_daily_budget_report(self.state, month)
        self.report_text.delete("1.0", tk.END)
        self.report_text.insert("1.0", text)

    def export_report(self):
        content = self.report_text.get("1.0", tk.END).strip()
        if not content:
            messagebox.showwarning("Warning", "Please generate a report before exporting.")
            return
        today = datetime.now().strftime("%Y-%m-%d")
        month_str = self.budget_month_entry.get()
        default_filename = f"day_report_{month_str}_{today}.txt"
        path = filedialog.asksaveasfilename(
            initialfile=default_filename,
            defaultextension=".txt",
            filetypes=[("Text Documents", "*.txt"), ("All Files", "*.*")]
        )
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(content)
            messagebox.showinfo("Success", f"Report successfully exported to:\n{path}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export report.\nError: {e}")import tkinter as tk
from tkinter import ttk, messagebox
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

from ...services.report_builder import pie_data, history_data
from ...services.budget_calculator import compute_net_available_for_spending

class ReportsTab:
    def __init__(self, notebook, state):
        self.state = state
        self.canvas = None

        main = ttk.Frame(notebook, padding="10")
        notebook.add(main, text="Charts")
        main.rowconfigure(1, weight=1)
        main.columnconfigure(0, weight=1)

        controls = ttk.LabelFrame(main, text="Chart Options", padding="10")
        controls.grid(row=0, column=0, sticky='ew', pady=5)

        top = ttk.Frame(controls)
        top.pack(fill='x', expand=True, pady=(0, 10))

        # Chart style
        style_frame = ttk.Frame(top)
        style_frame.pack(side='left', padx=(0, 20))
        ttk.Label(style_frame, text="Chart Style:").pack(side='left')
        self.style_var = tk.StringVar(value="Pie Chart")
        ttk.Radiobutton(style_frame, text="Pie Chart", variable=self.style_var, value="Pie Chart",
                        command=self._toggle_controls).pack(anchor='w')
        ttk.Radiobutton(style_frame, text="Historical Bar Chart", variable=self.style_var, value="Bar Chart",
                        command=self._toggle_controls).pack(anchor='w')

        # Data type
        type_frame = ttk.Frame(top)
        type_frame.pack(side='left', padx=(0, 20))
        ttk.Label(type_frame, text="Data Type:").pack(side='left')
        self.chart_type_var = tk.StringVar(value="Expense")
        ttk.Radiobutton(type_frame, text="Expenses", variable=self.chart_type_var, value="Expense",
                        command=self._toggle_fixed_controls).pack(side='left')
        ttk.Radiobutton(type_frame, text="Incomes", variable=self.chart_type_var, value="Income",
                        command=self._toggle_fixed_controls).pack(side='left', padx=5)

        # Pie controls
        self.pie_controls = ttk.Frame(top)
        self.pie_controls.pack(side='left', padx=(0, 15))
        ttk.Label(self.pie_controls, text="Select Month:").pack(side='left')
        self.month_entry = ttk.Entry(self.pie_controls, width=15)
        from datetime import datetime
        self.month_entry.insert(0, datetime.now().strftime("%Y-%m"))
        self.month_entry.pack(side='left', padx=5)
        ttk.Label(self.pie_controls, text="Display As:").pack(side='left', padx=(10, 0))
        self.value_type_var = tk.StringVar(value="Percentage")
        ttk.Radiobutton(self.pie_controls, text="%", variable=self.value_type_var, value="Percentage").pack(side='left')
        ttk.Radiobutton(self.pie_controls, text="€", variable=self.value_type_var, value="Total").pack(side='left', padx=5)

        # Bar controls
        self.bar_controls = ttk.Frame(top)
        ttk.Label(self.bar_controls, text="Number of Months:").pack(side='left')
        self.months_entry = ttk.Entry(self.bar_controls, width=10)
        self.months_entry.insert(0, "6")
        self.months_entry.pack(side='left', padx=5)

        bottom = ttk.Frame(controls)
        bottom.pack(fill='x', expand=True)

        self.fixed_frame = ttk.Frame(bottom)
        self.fixed_frame.pack(side='left', padx=(0, 15))
        self.include_fixed_var = tk.BooleanVar(value=False)
        self.fixed_check = ttk.Checkbutton(self.fixed_frame, text="Include Fixed Costs", variable=self.include_fixed_var)
        self.include_base_var = tk.BooleanVar(value=False)
        self.base_check = ttk.Checkbutton(self.fixed_frame, text="Include Base Income", variable=self.include_base_var)
        self._toggle_fixed_controls()

        self.show_budget_lines_var = tk.BooleanVar(value=False)
        self.budget_lines_check = ttk.Checkbutton(bottom, text="Show Budget Limits", variable=self.show_budget_lines_var)
        self.budget_lines_check.pack(side='left', padx=(0, 15))

        ttk.Button(bottom, text="Generate Chart", command=self.generate).pack(side='right')

        self.chart_frame = ttk.Frame(main)
        self.chart_frame.grid(row=1, column=0, sticky='nsew', pady=10)

        self._toggle_controls()

    def _toggle_controls(self):
        s = self.style_var.get()
        self.pie_controls.pack_forget()
        self.bar_controls.pack_forget()
        self.budget_lines_check.pack_forget()
        if s == "Pie Chart":
            self.pie_controls.pack(side='left', padx=(0, 15))
            self.budget_lines_check.pack(side='left', padx=(0, 15))
        else:
            self.bar_controls.pack(side='left', padx=(0, 15))

    def _toggle_fixed_controls(self):
        self.fixed_check.pack_forget()
        self.base_check.pack_forget()
        if self.chart_type_var.get() == "Expense":
            self.fixed_check.pack()
        else:
            self.base_check.pack()

    def generate(self):
        if self.canvas:
            self.canvas.get_tk_widget().destroy()
            self.canvas = None
        style = self.style_var.get()
        if style == "Pie Chart":
            self._make_pie()
        else:
            self._make_bar()

    def _make_bar(self):
        try:
            n = int(self.months_entry.get())
            if n <= 1:
                messagebox.showerror("Error", "Number of months must be greater than 1.")
                return
        except ValueError:
            messagebox.showerror("Error", "Invalid number of months.")
            return

        title, labels, values = history_data(
            self.state, n, self.chart_type_var.get(),
            include_fixed=self.include_fixed_var.get(),
            include_base_income=self.include_base_var.get()
        )
        if not any(values):
            messagebox.showinfo("No Data", "No data to display for the selected period.")
            return

        fig = Figure(figsize=(10, 6), dpi=100)
        ax = fig.add_subplot(111)
        ax.bar(labels, values, label="Monthly Totals")

        if len(values) > 1:
            x = np.arange(len(labels))
            slope, intercept = np.polyfit(x, values, 1)
            trend = slope * x + intercept
            ax.plot(labels, trend, color='red', linestyle='--', label='Trend Line')

        ax.set_title(title)
        ax.set_ylabel("Total Amount (€)")
        ax.legend()
        fig.autofmt_xdate(rotation=45)
        fig.tight_layout()

        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill='both', expand=True)

    def _make_pie(self):
        month = self.month_entry.get()
        title, totals = pie_data(
            self.state, month, self.chart_type_var.get(),
            include_fixed=self.include_fixed_var.get(),
            include_base_income=self.include_base_var.get()
        )
        if not totals:
            from tkinter import messagebox
            messagebox.showinfo("No Data", f"No data to display for {month}.")
            return
        labels = list(totals.keys())
        sizes = list(totals.values())

        fig = Figure(figsize=(8, 6), dpi=100)
        ax = fig.add_subplot(111)

        if self.value_type_var.get() == "Percentage":
            autopct = '%1.1f%%'
        else:
            def absolute_value(val):
                a = (val / 100.0) * sum(sizes)
                return f'€{a:.2f}'
            autopct = absolute_value

        wedges, texts, autotexts = ax.pie(sizes, autopct=autopct, startangle=140, textprops=dict(color="w"))
        ax.axis('equal')
        ax.set_title(title)
        ax.legend(wedges, labels, title="Categories", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))

        from matplotlib import pyplot as plt
        plt.setp(autotexts, size=8, weight="bold")

        if self.show_budget_lines_var.get() and self.chart_type_var.get() == "Expense":
            expense_budgets = self.state.budget_settings.get('category_budgets', {}).get('Expense', {})
            budget_info = []
            nav = compute_net_available_for_spending(self.state, month)
            for cat in labels:
                pct_limit = expense_budgets.get(cat, 0)
                if pct_limit > 0 and nav > 0:
                    actual = totals.get(cat, 0)
                    budget_amount = (pct_limit / 100.0) * nav
                    used_pct = (actual / budget_amount) * 100 if budget_amount > 0 else 0
                    remaining = max(budget_amount - actual, 0)
                    budget_info.append(f"{cat}: {used_pct:.0f}% of budget, left: €{remaining:.2f}")

            if budget_info:
                ax.text(1.5, 0.5, "Budget Status:\n" + "\n".join(budget_info),
                        transform=ax.transAxes, fontsize=9, va='center',
                        bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

        fig.tight_layout()
        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill='both', expand=True)# tabs packageimport tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime
from ...services.budget_calculator import compute_net_available_for_spending, auto_assign_percentages

class BudgetsTab:
    def __init__(self, notebook, state):
        self.state = state
        self.budget_sliders = {}
        self._slider_lock = False

        main = ttk.Frame(notebook, padding="10")
        notebook.add(main, text="Budgets Limits")
        main.rowconfigure(1, weight=1)
        main.columnconfigure(0, weight=1)

        toolbar = ttk.Frame(main)
        toolbar.grid(row=0, column=0, sticky='ew', pady=(0, 5))
        ttk.Label(toolbar, text="Budget Month (YYYY-MM):").pack(side='left', padx=(0, 5))
        self.month_var = tk.StringVar(value=datetime.now().strftime("%Y-%m"))
        ttk.Entry(toolbar, textvariable=self.month_var, width=10).pack(side='left')
        ttk.Button(toolbar, text="Refresh Amounts", command=self._update_monetary_labels).pack(side='left', padx=10)

        group = ttk.LabelFrame(main, text="Category Budget Limits", padding="10")
        group.grid(row=1, column=0, sticky='nsew')

        self._create_widgets(group)

    def _create_widgets(self, parent):
        parent.rowconfigure(3, weight=1)
        parent.columnconfigure(0, weight=1)

        self.cat_type_var = tk.StringVar(value="Expense")
        type_frame = ttk.Frame(parent)
        type_frame.grid(row=0, column=0, sticky='ew', pady=2)
        ttk.Label(type_frame, text="Type:").pack(side='left')
        ttk.Radiobutton(type_frame, text="Expense", variable=self.cat_type_var, value="Expense",
                        command=self._create_budget_sliders).pack(side='left', padx=5)
        ttk.Radiobutton(type_frame, text="Income", variable=self.cat_type_var, value="Income",
                        command=self._create_budget_sliders).pack(side='left', padx=5)

        manage = ttk.Frame(parent)
        manage.grid(row=1, column=0, sticky='ew', pady=5)
        ttk.Label(manage, text="New Category:").pack(side='left', padx=(0, 5))
        self.new_cat_entry = ttk.Entry(manage, width=20)
        self.new_cat_entry.pack(side='left')
        ttk.Button(manage, text="Add", command=self.add_category).pack(side='left', padx=5)

        ttk.Label(manage, text="Remove Category:").pack(side='left', padx=(10, 5))
        self.remove_cat_combo = ttk.Combobox(manage, width=20, state='readonly')
        self.remove_cat_combo.pack(side='left')
        ttk.Button(manage, text="Remove", command=self.remove_category).pack(side='left', padx=5)

        self.sliders_frame = ttk.Frame(parent)
        self.sliders_frame.grid(row=2, column=0, sticky='nsew', pady=5)

        btns = ttk.Frame(parent)
        btns.grid(row=3, column=0, sticky='ew', pady=5)
        ttk.Button(btns, text="Auto-Assign From Expenses", command=self.auto_assign).pack(side='left', padx=(0, 5))
        ttk.Button(btns, text="Normalize to 100%", command=lambda: (self._normalize_sliders(), self._update_total_percentage_label())).pack(side='left', padx=(0, 10))
        spacer = ttk.Frame(btns)
        spacer.pack(side='left', expand=True, fill='x')
        self.total_pct_label = ttk.Label(btns, text="Total: 0.0%")
        self.total_pct_label.pack(side='left', padx=(0, 10))
        ttk.Button(btns, text="Save Budgets", command=self.save_budgets).pack(side='left', padx=5)

        self._create_budget_sliders()

    def _create_budget_sliders(self):
        for w in self.sliders_frame.winfo_children():
            w.destroy()
        self.budget_sliders = {}

        cat_type = self.cat_type_var.get()
        categories = self.state.categories.get(cat_type, [])
        saved = self.state.budget_settings.get('category_budgets', {}).get(cat_type, {}).copy()

        if not saved:
            if categories:
                even = 100.0 / len(categories)
                for c in categories:
                    saved[c] = even
        else:
            for c in categories:
                if c not in saved:
                    saved[c] = 0.0

        self.remove_cat_combo['values'] = categories

        for c in categories:
            frame = ttk.Frame(self.sliders_frame)
            frame.pack(fill='x', pady=2)

            ttk.Label(frame, text=c, width=15).pack(side='left')
            var = tk.DoubleVar(value=float(saved.get(c, 0)))
            slider = ttk.Scale(frame, from_=0, to=100, orient='horizontal', variable=var,
                               command=lambda v, cat=c: self._on_slider_change(cat, float(v)))
            slider.pack(side='left', fill='x', expand=True, padx=5)
            label = ttk.Label(frame, text=f"{var.get():.1f}%", width=7)
            label.pack(side='left')
            amount_label = ttk.Label(frame, text="€0.00", width=12)
            amount_label.pack(side='left')

            self.budget_sliders[c] = {'var': var, 'slider': slider, 'label': label, 'amount_label': amount_label}

        self._update_monetary_labels()
        self._update_total_percentage_label()

    def _on_slider_change(self, changed_category, new_value):
        if self._slider_lock:
            return
        self._slider_lock = True
        old_value = self.budget_sliders[changed_category]['var'].get()
        self.budget_sliders[changed_category]['var'].set(new_value)
        self.budget_sliders[changed_category]['label'].config(text=f"{new_value:.1f}%")
        self._adjust_other_sliders(changed_category, new_value, old_value)
        self._slider_lock = False
        self._update_monetary_labels()
        self._update_total_percentage_label()

    def _adjust_other_sliders(self, changed_category, new_value, old_value):
        delta = new_value - old_value
        others = {k: v for k, v in self.budget_sliders.items() if k != changed_category}
        other_total = sum(s['var'].get() for s in others.values())
        if other_total > 0:
            for cat, info in others.items():
                cur = info['var'].get()
                adj = delta * (cur / other_total)
                val = max(0, min(100, cur - adj))
                info['var'].set(val)
                info['label'].config(text=f"{val:.1f}%")
        else:
            if len(others) > 0:
                per = delta / len(others)
                for info in others.values():
                    val = max(0, min(100, info['var'].get() - per))
                    info['var'].set(val)
                    info['label'].config(text=f"{val:.1f}%")

    def _normalize_sliders(self):
        total = sum(s['var'].get() for s in self.budget_sliders.values())
        if total == 0:
            return
        if abs(total - 100.0) > 0.01:
            for info in self.budget_sliders.values():
                cur = info['var'].get()
                norm = (cur / total) * 100.0
                info['var'].set(norm)
                info['label'].config(text=f"{norm:.1f}%")
        self._update_monetary_labels()

    def _update_monetary_labels(self):
        month = self.month_var.get()
        nav = compute_net_available_for_spending(self.state, month)
        for _, info in self.budget_sliders.items():
            pct = info['var'].get()
            amount = (pct / 100.0) * nav
            info['amount_label'].config(text=f"€{amount:.2f}")

    def _update_total_percentage_label(self):
        total = sum(s['var'].get() for s in self.budget_sliders.values())
        self.total_pct_label.config(text=f"Total: {total:.1f}%")

    def add_category(self):
        cat_type = self.cat_type_var.get()
        new_cat = self.new_cat_entry.get().strip()
        if not new_cat:
            messagebox.showerror("Error", "Category name cannot be empty.")
            return
        if new_cat.lower() in [c.lower() for c in self.state.categories[cat_type]]:
            messagebox.showwarning("Warning", "This category already exists.")
            return
        self.state.categories[cat_type].append(new_cat)
        self.state.categories[cat_type].sort()
        self.state.save()
        self._create_budget_sliders()
        self.new_cat_entry.delete(0, tk.END)

    def remove_category(self):
        cat_type = self.cat_type_var.get()
        cat = self.remove_cat_combo.get()
        if not cat:
            messagebox.showwarning("Warning", "Please select a category to delete.")
            return
        if cat.lower() == "other":
            messagebox.showerror("Error", "Cannot delete the 'Other' category.")
            return
        if not messagebox.askyesno("Confirm", f"Delete '{cat}'? Existing transactions won't be changed."):
            return
        self.state.categories[cat_type].remove(cat)
        budgets = self.state.budget_settings['category_budgets'].get(cat_type, {})
        if cat in budgets:
            del budgets[cat]
        self.state.save()
        self._create_budget_sliders()

    def save_budgets(self):
        cat_type = self.cat_type_var.get()
        if cat_type not in self.state.budget_settings['category_budgets']:
            self.state.budget_settings['category_budgets'][cat_type] = {}
        for cat, info in self.budget_sliders.items():
            self.state.budget_settings['category_budgets'][cat_type][cat] = float(info['var'].get())
        self.state.save()
        self._create_budget_sliders()
        messagebox.showinfo("Success", "Category budgets have been saved.")

    def auto_assign(self):
        cat_type = self.cat_type_var.get()
        categories = list(self.budget_sliders.keys())
        month = self.month_var.get()
        percentages, msg, overspent = auto_assign_percentages(self.state, month, cat_type, categories)
        if not percentages:
            if msg:
                messagebox.showinfo("Info", msg)
            return
        for cat, pct in percentages.items():
            if cat in self.budget_sliders:
                self.budget_sliders[cat]['var'].set(pct)
                self.budget_sliders[cat]['label'].config(text=f"{pct:.1f}%")
        self._update_monetary_labels()
        self._update_total_percentage_label()
        if overspent:
            messagebox.showwarning("Overspent", msg)
        else:
            messagebox.showinfo("Remaining Budget", msg)import tkinter as tk
from tkinter import ttk, messagebox

class TransfersTab:
    def __init__(self, notebook, state, on_data_changed):
        self.state = state
        self.on_data_changed = on_data_changed

        frame = ttk.Frame(notebook, padding="20")
        notebook.add(frame, text="Transfers")

        form = ttk.Frame(frame)
        form.pack(anchor='center')

        ttk.Label(form, text="This section allows you to record movement of funds between your accounts.").grid(
            row=0, column=0, columnspan=3, sticky='w', pady=(0, 20))

        account_options = ["Bank", "Wallet", "Savings", "Investments", "Money Lent"]

        ttk.Label(form, text="From Account:").grid(row=1, column=0, sticky='w', pady=10)
        self.from_var = tk.StringVar()
        self.from_combo = ttk.Combobox(form, textvariable=self.from_var, values=account_options, width=28, state='readonly')
        self.from_combo.grid(row=1, column=1, pady=5, sticky='w')

        ttk.Label(form, text="To Account:").grid(row=2, column=0, sticky='w', pady=10)
        self.to_var = tk.StringVar()
        self.to_combo = ttk.Combobox(form, textvariable=self.to_var, values=account_options, width=28, state='readonly')
        self.to_combo.grid(row=2, column=1, pady=5, sticky='w')

        ttk.Label(form, text="Amount:").grid(row=3, column=0, sticky='w', pady=5)
        self.amount_entry = ttk.Entry(form, width=30)
        self.amount_entry.grid(row=3, column=1, pady=5, sticky='w')

        ttk.Button(form, text="Execute Transfer", command=self.execute).grid(row=4, column=1, pady=20, sticky='w')

    def execute(self):
        from_acc = self.from_var.get()
        to_acc = self.to_var.get()
        amount_str = self.amount_entry.get()

        if not from_acc or not to_acc:
            messagebox.showerror("Error", "Please select both a 'From' and 'To' account.")
            return
        if from_acc == to_acc:
            messagebox.showerror("Error", "The 'From' and 'To' accounts cannot be the same.")
            return
        try:
            amount = float(amount_str)
            if amount <= 0:
                messagebox.showerror("Error", "Transfer amount must be positive.")
                return
        except ValueError:
            messagebox.showerror("Error", "Invalid amount entered.")
            return

        keys = {
            "Bank": "bank_account_balance",
            "Wallet": "wallet_balance",
            "Savings": "savings_balance",
            "Investments": "investment_balance",
            "Money Lent": "money_lent_balance"
        }
        from_key = keys[from_acc]
        to_key = keys[to_acc]
        self.state.budget_settings[from_key] -= amount
        self.state.budget_settings[to_key] += amount
        self.state.save()
        self.on_data_changed()
        messagebox.showinfo("Success", f"Successfully transferred €{amount:.2f} from {from_acc} to {to_acc}.")
        self.amount_entry.delete(0, tk.END)
        self.from_var.set('')
        self.to_var.set('')import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime

class ViewTransactionsTab:
    def __init__(self, notebook, state, on_data_changed):
        self.state = state
        self.on_data_changed = on_data_changed

        frame = ttk.Frame(notebook, padding="20")
        notebook.add(frame, text="View Transactions")
        self.frame = frame

        filter_frame = ttk.Frame(frame)
        filter_frame.pack(fill='x', pady=10)

        ttk.Label(filter_frame, text="Filter by month:").pack(side='left', padx=5)
        self.month_filter = ttk.Entry(filter_frame, width=15)
        self.month_filter.insert(0, datetime.now().strftime("%Y-%m"))
        self.month_filter.pack(side='left', padx=5)
        ttk.Button(filter_frame, text="Refresh", command=self.refresh).pack(side='left', padx=10)

        tree_frame = ttk.Frame(frame)
        tree_frame.pack(fill='both', expand=True, pady=10)

        columns = ('ID', 'Date', 'Type', 'Amount', 'Category', 'Description')
        self.transaction_tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=15)
        for col in columns:
            self.transaction_tree.heading(col, text=col)
            width = 120
            if col == 'Amount': width = 100
            if col == 'Description': width = 250
            if col == 'Type': width = 80
            self.transaction_tree.column(col, width=width, anchor='w')

        self.transaction_tree.column('ID', width=0, stretch=tk.NO)
        self.transaction_tree.tag_configure('expense', foreground='red')
        self.transaction_tree.tag_configure('income', foreground='green')
        self.transaction_tree.pack(side='left', fill='both', expand=True)

        scrollbar = ttk.Scrollbar(tree_frame, orient='vertical', command=self.transaction_tree.yview)
        scrollbar.pack(side='right', fill='y')
        self.transaction_tree.configure(yscrollcommand=scrollbar.set)

        button_frame = ttk.Frame(frame)
        button_frame.pack(fill='x', pady=5)
        spacer = ttk.Frame(button_frame)
        spacer.pack(side='left', expand=True, fill='x')
        ttk.Button(button_frame, text="Modify Selected", command=self.open_modify_window).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Delete Selected", command=self.delete_transaction).pack(side='left')

        self.summary_label = ttk.Label(frame, text="", font=('Arial', 10, 'bold'))
        self.summary_label.pack(pady=10, fill='x')

        self.refresh()

    def refresh(self):
        for item in self.transaction_tree.get_children():
            self.transaction_tree.delete(item)
        filter_month = self.month_filter.get()
        all_transactions = []
        for e in self.state.expenses:
            if e['date'].startswith(filter_month):
                all_transactions.append({**e, 'type': 'Expense'})
        for i in self.state.incomes:
            if i['date'].startswith(filter_month):
                all_transactions.append({**i, 'type': 'Income'})
        all_transactions.sort(key=lambda x: x['date'])

        for trans in all_transactions:
            tag = 'expense' if trans['type'] == 'Expense' else 'income'
            trans_id = trans.get('id', '')
            self.transaction_tree.insert('', 'end', values=(
                trans_id, trans['date'], trans['type'], f"€{trans['amount']:.2f}",
                trans['category'], trans['description']), tags=(tag,))
        self.update_summary()

    def update_summary(self):
        fm = self.month_filter.get()
        base_income = self.state.budget_settings.get('monthly_income', 0)
        total_flex_income = sum(i['amount'] for i in self.state.incomes if i['date'].startswith(fm))
        total_income = base_income + total_flex_income

        total_flex_expenses = sum(e['amount'] for e in self.state.expenses if e['date'].startswith(fm))
        total_fixed_costs = sum(fc['amount'] for fc in self.state.budget_settings.get('fixed_costs', []))
        total_expenses = total_flex_expenses + total_fixed_costs
        net = total_income - total_expenses

        self.summary_label.config(text=(f"Total Income: €{total_income:.2f}  |  "
                                        f"Total Expenses: €{total_expenses:.2f}  |  "
                                        f"Flexible Costs Incurred: €{total_flex_expenses:.2f}  |  "
                                        f"Net: €{net:.2f}"))

    def delete_transaction(self):
        selected = self.transaction_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a transaction to delete.")
            return
        if not messagebox.askyesno("Confirm", "Are you sure you want to delete the selected transaction?"):
            return

        v = self.transaction_tree.item(selected[0])['values']
        trans_id = v[0]
        trans_type = v[2]
        if trans_id:
            ok = self.state.delete_transaction_by_id(trans_type, trans_id)
            if not ok:
                messagebox.showerror("Error", "Could not delete the transaction.")
        else:
            # Legacy no-id fallback
            date_str, _, amount_str, category, desc = v[1:]
            target = self.state.expenses if trans_type == "Expense" else self.state.incomes
            try:
                target.remove({
                    'date': date_str,
                    'amount': float(amount_str.replace('€', '')),
                    'category': category,
                    'description': desc
                })
                self.state.save()
            except ValueError:
                messagebox.showerror("Error", "Could not delete the transaction (fallback failed).")
                return
        self.on_data_changed()

    def open_modify_window(self):
        selected = self.transaction_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a transaction to modify.")
            return
        values = self.transaction_tree.item(selected[0])['values']
        trans_id = values[0]

        original = None
        original_list_name = None
        for t in self.state.expenses:
            if t.get('id') == trans_id:
                original = t
                original_list_name = "Expense"
                break
        if not original:
            for t in self.state.incomes:
                if t.get('id') == trans_id:
                    original = t
                    original_list_name = "Income"
                    break
        if not original:
            messagebox.showerror("Error", "Could not find the selected transaction in the data.")
            return

        win = tk.Toplevel(self.frame)
        win.title("Modify Transaction")
        win.transient(self.frame)
        win.grab_set()

        form = ttk.Frame(win, padding="20")
        form.pack(fill='both', expand=True)

        ttk.Label(form, text="Transaction Type:").grid(row=0, column=0, sticky='w', pady=10)
        mod_type_var = tk.StringVar(value=original_list_name)
        type_frame = ttk.Frame(form)
        type_frame.grid(row=0, column=1, sticky='w', pady=5)

        mod_category_var = tk.StringVar(value=original.get('category', ''))
        mod_category_combo = ttk.Combobox(form, textvariable=mod_category_var, width=28, state='readonly')

        def update_mod_cats():
            cats = self.state.categories.get(mod_type_var.get(), [])
            mod_category_combo.config(values=cats)
            if mod_category_var.get() in cats:
                mod_category_combo.set(mod_category_var.get())
            else:
                mod_category_combo.set(cats[0] if cats else "")

        ttk.Radiobutton(type_frame, text="Expense", variable=mod_type_var, value="Expense",
                        command=update_mod_cats).pack(side='left', padx=5)
        ttk.Radiobutton(type_frame, text="Income", variable=mod_type_var, value="Income",
                        command=update_mod_cats).pack(side='left', padx=5)

        ttk.Label(form, text="Date:").grid(row=1, column=0, sticky='w', pady=5)
        mod_date_entry = ttk.Entry(form, width=30)
        mod_date_entry.insert(0, original.get('date', ''))
        mod_date_entry.grid(row=1, column=1, pady=5, sticky='w')

        ttk.Label(form, text="Amount:").grid(row=2, column=0, sticky='w', pady=5)
        mod_amount_entry = ttk.Entry(form, width=30)
        mod_amount_entry.insert(0, original.get('amount', ''))
        mod_amount_entry.grid(row=2, column=1, pady=5, sticky='w')

        ttk.Label(form, text="Category:").grid(row=3, column=0, sticky='w', pady=5)
        mod_category_combo.grid(row=3, column=1, pady=5, sticky='w')
        update_mod_cats()

        ttk.Label(form, text="Description:").grid(row=4, column=0, sticky='w', pady=5)
        mod_desc_entry = ttk.Entry(form, width=30)
        mod_desc_entry.insert(0, original.get('description', ''))
        mod_desc_entry.grid(row=4, column=1, pady=5, sticky='w')

        def save_changes():
            try:
                new_date = mod_date_entry.get()
                datetime.strptime(new_date, "%Y-%m-%d")
                new_amount = float(mod_amount_entry.get())
                new_cat = mod_category_var.get()
                new_desc = mod_desc_entry.get()
                new_type = mod_type_var.get()
                if not new_cat:
                    messagebox.showerror("Error", "Please select a category.", parent=win)
                    return

                # Update existing
                original['date'] = new_date
                original['amount'] = new_amount
                original['category'] = new_cat
                original['description'] = new_desc

                if new_type != original_list_name:
                    source = self.state.expenses if original_list_name == "Expense" else self.state.incomes
                    source.remove(original)
                    (self.state.expenses if new_type == "Expense" else self.state.incomes).append(original)

                self.state.save()
                self.on_data_changed()
                win.destroy()
            except ValueError:
                messagebox.showerror("Error", "Invalid amount or date format (YYYY-MM-DD).", parent=win)

        ttk.Button(form, text="Save Changes", command=save_changes).grid(row=5, column=1, pady=20, sticky='w')import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from datetime import datetime
from ...services.projection_service import projection_text

class ProjectionTab:
    def __init__(self, notebook, state):
        self.state = state

        main = ttk.Frame(notebook, padding="10")
        notebook.add(main, text="Projection")
        main.rowconfigure(1, weight=1)
        main.columnconfigure(0, weight=1)

        controls = ttk.LabelFrame(main, text="Projection Options", padding="10")
        controls.grid(row=0, column=0, sticky='ew', pady=5)
        ttk.Label(controls, text="Number of months to project:").pack(side='left', padx=5)
        self.months_entry = ttk.Entry(controls, width=10)
        self.months_entry.insert(0, "12")
        self.months_entry.pack(side='left', padx=5)
        ttk.Button(controls, text="Generate Projection", command=self.generate).pack(side='left', padx=20)
        ttk.Button(controls, text="Export Projection", command=self.export).pack(side='left', padx=5)

        self.text = tk.Text(main, height=20, width=90, font=('Courier New', 9))
        self.text.grid(row=1, column=0, sticky='nsew', pady=10)

    def generate(self):
        try:
            months = int(self.months_entry.get())
            if months <= 0:
                messagebox.showerror("Error", "Number of months must be positive.")
                return
        except ValueError:
            messagebox.showerror("Error", "Invalid number of months.")
            return
        report = projection_text(self.state, months)
        self.text.delete("1.0", tk.END)
        self.text.insert("1.0", report)

    def export(self):
        content = self.text.get("1.0", tk.END).strip()
        if not content:
            messagebox.showwarning("Warning", "Please generate a projection before exporting.")
            return
        today = datetime.now().strftime("%Y-%m-%d")
        default_filename = f"bank_projection_{today}.txt"
        path = filedialog.asksaveasfilename(
            initialfile=default_filename,
            defaultextension=".txt",
            filetypes=[("Text Documents", "*.txt"), ("All Files", "*.*")]
        )
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(content)
            messagebox.showinfo("Success", f"Projection successfully exported to:\n{path}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export projection.\nError: {e}")from tkinter import ttk

def apply_styles():
    style = ttk.Style()
    style.configure("Treeview.Heading", font=('Arial', 10, 'bold'))
    style.configure("TLabel", font=('Arial', 10))
    style.configure("TButton", font=('Arial', 10))
    style.configure("TRadiobutton", font=('Arial', 10))
    style.configure("Help.TButton", font=('Arial', 12, 'bold'))import tkinter as tk
from tkinter import ttk

def show_help(root):
    help_win = tk.Toplevel(root)
    help_win.title("Help & Instructions")
    help_win.geometry("800x600")
    help_win.minsize(600, 400)

    main_frame = ttk.Frame(help_win, padding=10)
    main_frame.pack(fill='both', expand=True)

    text_frame = ttk.Frame(main_frame)
    text_frame.pack(fill='both', expand=True)

    help_text_widget = tk.Text(text_frame, wrap='word', font=('Arial', 10), spacing3=5)
    scrollbar = ttk.Scrollbar(text_frame, orient='vertical', command=help_text_widget.yview)
    help_text_widget.configure(yscrollcommand=scrollbar.set)
    scrollbar.pack(side='right', fill='y')
    help_text_widget.pack(side='left', fill='both', expand=True)

    help_text_widget.tag_configure('h1', font=('Arial', 16, 'bold'), spacing1=10)
    help_text_widget.tag_configure('h2', font=('Arial', 12, 'bold'), spacing1=10)
    help_text_widget.tag_configure('bold', font=('Arial', 10, 'bold'))
    help_text_widget.tag_configure('italic', font=('Arial', 10, 'italic'))

    content = [
        ("Core Concepts", "h1"),
        ("To use this tracker effectively, it's important to understand these key ideas:", "italic"),

        ("\n• Assets (Your Accounts):", "bold"),
        (" The main ones are 'Bank', 'Wallet', 'Savings', 'Investments', and 'Money Lent'. Balances are in 'Budget & Settings'.", "none"),

        ("\n• Transactions (Income/Expense):", "bold"),
        (" Money entering/leaving your finances.", "none"),

        ("\n• Transfers:", "bold"),
        (" Move money between your accounts (doesn't change net worth).", "none"),

        ("\nHow To Use Each Tab", "h1"),

        ("\nAdd Transaction Tab", "h2"),
        ("Log income or expense with date, amount, category, description.", "none"),

        ("\nView Transactions Tab", "h2"),
        ("Filter by month, modify/delete, see monthly summary.", "none"),

        ("\nTransfers Tab", "h2"),
        ("Move funds between accounts (e.g., Bank → Wallet).", "none"),

        ("\Charts Tab", "h2"),
        ("Pie chart or historical bar chart. Optional fixed/base income, budget overlays.", "none"),

        ("\nBudget Report Tab", "h2"),
        ("Balances, fixed costs, daily budget report.", "none"),

        ("\nBudgets Limits Tab", "h2"),
        ("Manage category budget limits as % of monthly flexible budget. Auto-Assign from expenses; Normalize.", "none"),

        ("\nProjection Tab", "h2"),
        ("Project future total assets based on daily savings goal.", "none"),
    ]
    for text, tag in content:
        if tag == "none":
            help_text_widget.insert(tk.END, text)
        else:
            help_text_widget.insert(tk.END, text, tag)

    help_text_widget.config(state='disabled')# ui packageimport tkinter as tk
from tkinter import ttk

from .style import apply_styles
from .help_window import show_help

from .tabs.add_transaction_tab import AddTransactionTab
from .tabs.view_transactions_tab import ViewTransactionsTab
from .tabs.transfers_tab import TransfersTab
from .tabs.reports_tab import ReportsTab
from .tabs.settings_tab import SettingsTab
from .tabs.budgets_tab import BudgetsTab
from .tabs.projection_tab import ProjectionTab

class MainView:
    def __init__(self, root, state):
        self.root = root
        self.root.title("Personal Finance Tracker")
        self.root.minsize(1250, 750)
        apply_styles()

        self.state = state

        main_frame = ttk.Frame(root)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)

        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill='both', expand=True)

        # Callback to refresh UI after data changes
        def on_data_changed():
            self.view_tab.refresh()
            self.settings_tab.refresh_fixed_costs_tree()
            self.settings_tab.refresh_balance_entries()
        self.on_data_changed = on_data_changed

        # Tabs
        self.add_tab = AddTransactionTab(self.notebook, self.state, self.on_data_changed)
        self.view_tab = ViewTransactionsTab(self.notebook, self.state, self.on_data_changed)
        self.transfers_tab = TransfersTab(self.notebook, self.state, self.on_data_changed)
        self.reports_tab = ReportsTab(self.notebook, self.state)
        self.settings_tab = SettingsTab(self.notebook, self.state)
        self.budgets_tab = BudgetsTab(self.notebook, self.state)
        self.projection_tab = ProjectionTab(self.notebook, self.state)

        # Help Button
        help_button_frame = ttk.Frame(main_frame)
        help_button_frame.pack(fill='x', pady=(5, 0))
        ttk.Button(help_button_frame, text="?", style="Help.TButton",
                   width=3, command=lambda: show_help(self.root)).pack(side='right')from datetime import date
from dateutil.relativedelta import relativedelta

def pie_data(state, month_str: str, chart_type: str, include_fixed: bool, include_base_income: bool):
    if chart_type == "Expense":
        data = state.expenses
        title = f"Expenses for {month_str}"
        category_totals = {}
        if include_fixed:
            total_fc = sum(fc['amount'] for fc in state.budget_settings.get('fixed_costs', []))
            if total_fc > 0:
                category_totals["Fixed Costs"] = total_fc
    else:
        data = state.incomes
        title = f"Incomes for {month_str}"
        category_totals = {}
        if include_base_income:
            base_income = state.budget_settings.get('monthly_income', 0)
            if base_income > 0:
                category_totals["Base Income"] = base_income

    for item in data:
        if item['date'].startswith(month_str):
            category_totals[item['category']] = category_totals.get(item['category'], 0) + item['amount']

    return title, category_totals

def history_data(state, num_months: int, chart_type: str, include_fixed: bool, include_base_income: bool):
    today = date.today()
    monthly_totals = {}
    if chart_type == "Expense":
        fixed_value = sum(fc['amount'] for fc in state.budget_settings.get('fixed_costs', [])) if include_fixed else 0
        data = state.expenses
        title = f"Historical Expenses for the Last {num_months} Months"
    else:
        fixed_value = state.budget_settings.get('monthly_income', 0) if include_base_income else 0
        data = state.incomes
        title = f"Historical Incomes for the Last {num_months} Months"

    for i in range(num_months - 1, -1, -1):
        month_date = today - relativedelta(months=i)
        key = month_date.strftime("%Y-%m")
        monthly_totals[key] = fixed_value

    for item in data:
        month = item['date'][:7]
        if month in monthly_totals:
            monthly_totals[month] += item['amount']

    labels = list(monthly_totals.keys())
    values = list(monthly_totals.values())
    return title, labels, values# service namespace# finance_tracker/services/budget_calculator.py

from datetime import datetime
import calendar

def days_in_month_str(month_str: str) -> int:
    try:
        year, month = map(int, month_str.split("-"))
        return calendar.monthrange(year, month)[1]
    except Exception:
        return 30

def compute_net_available_for_spending(state, month_str: str) -> float:
    try:
        datetime.strptime(month_str, "%Y-%m")
    except ValueError:
        month_str = datetime.now().strftime("%Y-%m")

    base_income = state.budget_settings.get("monthly_income", 0)
    daily_savings_goal = state.budget_settings.get("daily_savings_goal", 0)
    flex_income_month = sum(i["amount"] for i in state.incomes if i["date"].startswith(month_str))
    total_income = base_income + flex_income_month
    fixed_costs = sum(fc["amount"] for fc in state.budget_settings.get("fixed_costs", []))

    dim = days_in_month_str(month_str)
    monthly_savings_goal = daily_savings_goal * dim
    flexible = total_income - fixed_costs - monthly_savings_goal
    return max(flexible, 0)

def generate_daily_budget_report(state, month_str: str) -> str:
    try:
        year, month = map(int, month_str.split("-"))
    except ValueError:
        return "Invalid month format. Use YYYY-MM."

    base_income = state.budget_settings.get("monthly_income", 0)
    daily_savings_goal = state.budget_settings.get("daily_savings_goal", 0)
    flex_income_month = sum(i['amount'] for i in state.incomes if i['date'].startswith(month_str))
    total_income = base_income + flex_income_month
    fixed_costs = sum(fc['amount'] for fc in state.budget_settings.get('fixed_costs', []))

    days_in_month = calendar.monthrange(year, month)[1]
    monthly_savings_goal = daily_savings_goal * days_in_month
    monthly_flexible_spending_budget = total_income - fixed_costs - monthly_savings_goal
    initial_daily_spending_target = monthly_flexible_spending_budget / days_in_month if days_in_month else 0

    flex_expenses_month = [e for e in state.expenses if e['date'].startswith(month_str)]
    daily_expenses = {}
    for e in flex_expenses_month:
        daily_expenses.setdefault(e['date'], []).append(e)

    from datetime import datetime as dt, date as ddate
    report = f"{'='*80}\n"
    report += f"DAILY BUDGET REPORT - {calendar.month_name[month]} {year}\n"
    report += f"{'='*80}\n\n"
    report += f"Base Monthly Income:                      €{base_income:>10.2f}\n"
    report += f"Flexible Income (This Month):             €{flex_income_month:>10.2f}\n"
    report += f"TOTAL INCOME:                             €{total_income:>10.2f}\n"
    report += f"Total Fixed Costs:                       -€{fixed_costs:>10.2f}\n"
    report += f"{'-'*50}\n"
    report += f"Monthly Savings Goal:                    -€{monthly_savings_goal:>10.2f}\n"
    report += f"NET MONTHLY FLEXIBLE BUDGET:              €{monthly_flexible_spending_budget:>10.2f}\n"
    report += f"INITIAL DAILY SPENDING TARGET:            €{initial_daily_spending_target:>10.2f}\n"
    report += f"{'-'*80}\n\n"
    report += f"DAILY BREAKDOWN (Flexible daily target adjusts based on remaining budget)\n"
    report += f"{'-'*80}\n"
    report += f"{'Date':<12} {'Target':<12} {'Spent':<12} {'Daily +/-':<12} {'Cumulative':<12} {'Status'}\n"
    report += f"{'-'*80}\n"

    cumulative_flexible_balance = monthly_flexible_spending_budget
    today = dt.now().date()
    
    for day in range(1, days_in_month + 1):
        date_str = f"{year}-{month:02d}-{day:02d}"
        date_obj = dt.strptime(date_str, "%Y-%m-%d").date()
        if date_obj > today:
            break
        
        # Calculate flexible target for THIS day based on remaining days INCLUDING today
        # If budget is depleted (≤0), target becomes 0
        remaining_days_including_today = days_in_month - day + 1
        if cumulative_flexible_balance <= 0:
            daily_target_for_this_day = 0
        else:
            daily_target_for_this_day = cumulative_flexible_balance / remaining_days_including_today if remaining_days_including_today > 0 else 0
        
        day_spent = sum(e['amount'] for e in daily_expenses.get(date_str, []))
        cumulative_flexible_balance -= day_spent
        daily_plus_minus = daily_target_for_this_day - day_spent
        
        status = "✓ On Track" if daily_plus_minus >= 0 else "✗ Overspent"
        if day_spent == 0:
            status = "- No spending"
        
        report += (f"{date_str:<12} €{daily_target_for_this_day:<10.2f} "
                   f"€{day_spent:<10.2f} €{daily_plus_minus:<10.2f} "
                   f"€{cumulative_flexible_balance:<10.2f} {status}\n")

    report += f"{'-'*80}\n\n"

    if today.year == year and today.month == month and today.day < days_in_month:
        remaining_days = days_in_month - today.day
        if remaining_days > 0:
            new_daily_target = cumulative_flexible_balance / remaining_days if cumulative_flexible_balance > 0 else 0
            
            report += f"{'='*80}\n"
            report += f"YOUR PATH FORWARD\n"
            report += f"{'='*80}\n\n"
            
            if cumulative_flexible_balance <= 0:
                total_flexible_expenses_incurred = sum(e['amount'] for e in flex_expenses_month)
                overall_net_value = total_income - fixed_costs - total_flexible_expenses_incurred - monthly_savings_goal
                overspend_amount = abs(cumulative_flexible_balance)
                
                report += f"⚠️  BUDGET DEPLETED: You have overspent your flexible budget by €{overspend_amount:.2f}\n\n"
                report += f"To get back on track, you have {remaining_days} days remaining and need to:\n\n"
                report += f"OPTION 1: Zero Spending Challenge\n"
                report += f"  • Spend €0.00 per day for the remaining {remaining_days} days\n"
                report += f"  • This will keep your deficit at €{overspend_amount:.2f}\n\n"
                report += f"OPTION 2: Accept the Deficit\n"
                report += f"  • Continue spending normally\n"
                report += f"  • Make up the €{overspend_amount:.2f} deficit next month\n\n"
                report += f"OPTION 3: Partial Recovery\n"
                report += f"  • Reduce spending as much as possible\n"
                report += f"  • Any amount you save reduces the deficit\n\n"
                report += f"--- Key Numbers for Context ---\n"
                report += f"Overall Net Value (Income - All Expenses - Savings): €{overall_net_value:.2f}\n"
                report += f"Current Flexible Budget Balance:                      €{cumulative_flexible_balance:.2f}\n\n"
            elif new_daily_target <= initial_daily_spending_target * 0.7:
                report += f"⚠️  SPENDING CAUTION NEEDED\n\n"
                report += f"You've spent more than planned in the first part of the month.\n"
                report += f"Your adjusted daily target is now: €{new_daily_target:.2f}/day (= €{cumulative_flexible_balance:.2f} / {remaining_days})\n"
                report += f"(Original target was: €{initial_daily_spending_target:.2f}/day)\n\n"
                report += f"Action Steps:\n"
                report += f"  • Try to limit spending to €{new_daily_target:.2f} per day\n"
                report += f"  • You have {remaining_days} days left to stay within budget\n"
                report += f"  • Current remaining budget: €{cumulative_flexible_balance:.2f}\n\n"
            elif new_daily_target >= initial_daily_spending_target * 1.3:
                report += f"✓ EXCELLENT PROGRESS!\n\n"
                report += f"You're doing great! You've been spending less than planned.\n"
                report += f"Your adjusted daily target is now: €{new_daily_target:.2f}/day\n"
                report += f"(Original target was: €{initial_daily_spending_target:.2f}/day)\n\n"
                report += f"Your Options:\n"
                report += f"  • Continue at your current pace and build a buffer\n"
                report += f"  • Enjoy up to €{new_daily_target:.2f}/day for the next {remaining_days} days\n"
                report += f"  • Current remaining budget: €{cumulative_flexible_balance:.2f}\n\n"
            else:
                report += f"✓ ON TRACK\n\n"
                report += f"You can spend up to €{new_daily_target:.2f} per day for the next {remaining_days} days.\n\n"
                report += f"Budget Status:\n"
                report += f"  • Days remaining: {remaining_days}\n"
                report += f"  • Remaining flexible budget: €{cumulative_flexible_balance:.2f}\n"
                report += f"  • Adjusted daily target: €{new_daily_target:.2f}\n\n"
        else:
            new_daily_target = cumulative_flexible_balance
            if new_daily_target < 0:
                report += f"Month Complete: You overspent your flexible budget by €{abs(new_daily_target):.2f}\n"
            else:
                report += f"Month Complete: You have €{new_daily_target:.2f} remaining in your flexible budget.\n"
    
    return report

def auto_assign_percentages(state, month_str: str, cat_type: str, categories: list):
    """
    Returns:
        (percentages_dict, message, is_overspent)
    """
    if cat_type != "Expense":
        return {}, "Auto-assign is only available for Expense budgets.", False

    try:
        datetime.strptime(month_str, "%Y-%m")
    except ValueError:
        return {}, "Invalid month format. Use YYYY-MM.", False

    net_available = compute_net_available_for_spending(state, month_str)
    if net_available <= 0:
        return {}, "Net available for spending is €0 for this month. Cannot auto-assign.", False

    spend_by_cat = {c: 0.0 for c in categories}
    for e in state.expenses:
        if e['date'].startswith(month_str) and e['category'] in spend_by_cat:
            spend_by_cat[e['category']] += float(e['amount'])

    total_spent = sum(spend_by_cat.values())
    if total_spent == 0:
        return {}, "No expenses recorded for the selected month. Nothing to auto-assign.", False

    if total_spent <= net_available:
        percentages = {c: (spend_by_cat[c] / net_available) * 100.0 for c in categories}
        remaining = net_available - total_spent
        remaining_pct = 100.0 - sum(percentages.values())
        msg = (f"Budgets set to match current expenses for {month_str}.\n"
               f"Remaining unallocated budget: €{remaining:.2f} (~{remaining_pct:.1f}%).\n"
               f"Please assign the remaining budget to one or more categories.")
        return percentages, msg, False
    else:
        percentages = {c: ((spend_by_cat[c] / total_spent) * 100.0 if total_spent > 0 else 0.0) for c in categories}
        over = total_spent - net_available
        msg = (f"You have spent €{total_spent:.2f} which exceeds your flexible budget of "
               f"€{net_available:.2f} by €{over:.2f}. Budgets were set proportionally to actual spend.")
        return percentages, msg, True
from datetime import date
from dateutil.relativedelta import relativedelta

def projection_text(state, num_months: int) -> str:
    bank_balance = state.budget_settings.get('bank_account_balance', 0)
    wallet_balance = state.budget_settings.get('wallet_balance', 0)
    savings_balance = state.budget_settings.get('savings_balance', 0)
    investment_balance = state.budget_settings.get('investment_balance', 0)
    money_lent_balance = state.budget_settings.get('money_lent_balance', 0)
    daily_savings_goal = state.budget_settings.get('daily_savings_goal', 0)

    starting_total_balance = (bank_balance + wallet_balance + savings_balance +
                              investment_balance + money_lent_balance)

    report = f"{'='*80}\n"
    report += f"FINANCIAL PROJECTION\n"
    report += f"{'='*80}\n\n"
    report += f"This report projects your total financial balance (Bank + Wallet + Savings + Investments + Money Lent).\n"
    report += f"It assumes you will meet your daily savings goal every day.\n\n"
    report += f"Bank Account Balance:       €{bank_balance:>10.2f}\n"
    report += f"Wallet Balance:             €{wallet_balance:>10.2f}\n"
    report += f"Current Savings Balance:    €{savings_balance:>10.2f}\n"
    report += f"Current Investment Balance: €{investment_balance:>10.2f}\n"
    report += f"Money Lent Balance:         €{money_lent_balance:>10.2f}\n"
    report += f"-----------------------------------------\n"
    report += f"Total Starting Balance:     €{starting_total_balance:>10.2f}\n"
    report += f"Target Daily Savings Goal:  €{daily_savings_goal:>10.2f}\n"
    report += f"{'-'*80}\n\n"
    report += f"{'Month':<15} {'Projected Monthly Savings':<30} {'Projected Total Balance'}\n"
    report += f"{'-'*80}\n"

    projected_balance = starting_total_balance
    current_date = date.today()

    for _ in range(num_months):
        next_month_date = current_date + relativedelta(months=1)
        days_in_month = (next_month_date - current_date).days
        monthly_savings = daily_savings_goal * days_in_month
        projected_balance += monthly_savings
        report += f"{current_date.strftime('%Y-%m'):<15} €{monthly_savings:<28.2f} €{projected_balance:10.2f}\n"
        current_date = next_month_date

    report += f"{'-'*80}\n"
    return report